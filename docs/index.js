var B1 = Object.defineProperty;
var k1 = (i, e, t) => e in i ? B1(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var $i = (i, e, t) => k1(i, typeof e != "symbol" ? e + "" : e, t);
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const td = "158", aa = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, oa = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, By = 0, op = 1, ky = 2, z1 = 3, zy = 0, nd = 1, Am = 2, zi = 3, Wi = 0, Wn = 1, $t = 2, H1 = 2, vt = 0, Gi = 1, Ta = 2, Tu = 3, Eu = 4, Fo = 5, mi = 100, Cm = 101, Rm = 102, Au = 103, Cu = 104, Bo = 200, Lc = 201, id = 202, sd = 203, Sr = 204, wr = 205, Ic = 206, rd = 207, Dc = 208, ad = 209, Pm = 210, Hy = 211, Gy = 212, Vy = 213, Wy = 214, Xy = 0, qy = 1, Yy = 2, nc = 3, jy = 4, Zy = 5, $y = 6, Ky = 7, Oc = 0, Qy = 1, Jy = 2, ps = 0, od = 1, ld = 2, cd = 3, hd = 4, ex = 5, lp = "attached", tx = "detached", ud = 300, Gs = 301, Tr = 302, ko = 303, ic = 304, tl = 306, Tn = 1e3, Kt = 1001, Er = 1002, lt = 1003, sc = 1004, G1 = 1004, Eo = 1005, V1 = 1005, Nt = 1006, dd = 1007, W1 = 1007, ys = 1008, X1 = 1008, ks = 1009, nx = 1010, ix = 1011, Nc = 1012, Lm = 1013, Fs = 1014, hs = 1015, zt = 1016, Im = 1017, Dm = 1018, zs = 1020, sx = 1021, gi = 1023, rx = 1024, ax = 1025, gr = 1026, Ar = 1027, ox = 1028, Om = 1029, lx = 1030, Nm = 1031, Um = 1033, hu = 33776, uu = 33777, du = 33778, fu = 33779, cp = 35840, hp = 35841, up = 35842, dp = 35843, cx = 36196, fp = 37492, pp = 37496, mp = 37808, gp = 37809, vp = 37810, _p = 37811, yp = 37812, xp = 37813, Mp = 37814, bp = 37815, Sp = 37816, wp = 37817, Tp = 37818, Ep = 37819, Ap = 37820, Cp = 37821, pu = 36492, Rp = 36494, Pp = 36495, hx = 36283, Lp = 36284, Ip = 36285, Dp = 36286, Fm = 2200, Bm = 2201, ux = 2202, zo = 2300, Ea = 2301, mu = 2302, fa = 2400, pa = 2401, rc = 2402, fd = 2500, km = 2501, dx = 0, zm = 1, Ru = 2, Hm = 3e3, vr = 3001, fx = 3200, Gm = 3201, Ur = 0, px = 1, vi = "", ft = "srgb", en = "srgb-linear", pd = "display-p3", Uc = "display-p3-linear", ac = "linear", Mt = "srgb", oc = "rec709", lc = "p3", q1 = 0, la = 7680, Y1 = 7681, j1 = 7682, Z1 = 7683, $1 = 34055, K1 = 34056, Q1 = 5386, J1 = 512, eS = 513, tS = 514, nS = 515, iS = 516, sS = 517, rS = 518, Op = 519, mx = 512, gx = 513, vx = 514, _x = 515, yx = 516, xx = 517, Mx = 518, bx = 519, cc = 35044, aS = 35048, oS = 35040, lS = 35045, cS = 35049, hS = 35041, uS = 35046, dS = 35050, fS = 35042, pS = "100", Np = "300 es", Pu = 1035, us = 2e3, hc = 2001;
class bs {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const s = this._listeners[e];
    if (s !== void 0) {
      const r = s.indexOf(t);
      r !== -1 && s.splice(r, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const s = n.slice(0);
      for (let r = 0, a = s.length; r < a; r++)
        s[r].call(this, e);
      e.target = null;
    }
  }
}
const An = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let _0 = 1234567;
const _a = Math.PI / 180, Ho = 180 / Math.PI;
function xi() {
  const i = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (An[i & 255] + An[i >> 8 & 255] + An[i >> 16 & 255] + An[i >> 24 & 255] + "-" + An[e & 255] + An[e >> 8 & 255] + "-" + An[e >> 16 & 15 | 64] + An[e >> 24 & 255] + "-" + An[t & 63 | 128] + An[t >> 8 & 255] + "-" + An[t >> 16 & 255] + An[t >> 24 & 255] + An[n & 255] + An[n >> 8 & 255] + An[n >> 16 & 255] + An[n >> 24 & 255]).toLowerCase();
}
function Ht(i, e, t) {
  return Math.max(e, Math.min(t, i));
}
function Vm(i, e) {
  return (i % e + e) % e;
}
function mS(i, e, t, n, s) {
  return n + (i - e) * (s - n) / (t - e);
}
function gS(i, e, t) {
  return i !== e ? (t - i) / (e - i) : 0;
}
function kl(i, e, t) {
  return (1 - t) * i + t * e;
}
function vS(i, e, t, n) {
  return kl(i, e, 1 - Math.exp(-t * n));
}
function _S(i, e = 1) {
  return e - Math.abs(Vm(i, e * 2) - e);
}
function yS(i, e, t) {
  return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * (3 - 2 * i));
}
function xS(i, e, t) {
  return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * i * (i * (i * 6 - 15) + 10));
}
function MS(i, e) {
  return i + Math.floor(Math.random() * (e - i + 1));
}
function bS(i, e) {
  return i + Math.random() * (e - i);
}
function SS(i) {
  return i * (0.5 - Math.random());
}
function wS(i) {
  i !== void 0 && (_0 = i);
  let e = _0 += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function TS(i) {
  return i * _a;
}
function ES(i) {
  return i * Ho;
}
function Up(i) {
  return (i & i - 1) === 0 && i !== 0;
}
function Sx(i) {
  return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
}
function Lu(i) {
  return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
}
function AS(i, e, t, n, s) {
  const r = Math.cos, a = Math.sin, o = r(t / 2), l = a(t / 2), c = r((e + n) / 2), h = a((e + n) / 2), u = r((e - n) / 2), d = a((e - n) / 2), f = r((n - e) / 2), m = a((n - e) / 2);
  switch (s) {
    case "XYX":
      i.set(o * h, l * u, l * d, o * c);
      break;
    case "YZY":
      i.set(l * d, o * h, l * u, o * c);
      break;
    case "ZXZ":
      i.set(l * u, l * d, o * h, o * c);
      break;
    case "XZX":
      i.set(o * h, l * m, l * f, o * c);
      break;
    case "YXY":
      i.set(l * f, o * h, l * m, o * c);
      break;
    case "ZYZ":
      i.set(l * m, l * f, o * h, o * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
  }
}
function $n(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return i / 4294967295;
    case Uint16Array:
      return i / 65535;
    case Uint8Array:
      return i / 255;
    case Int32Array:
      return Math.max(i / 2147483647, -1);
    case Int16Array:
      return Math.max(i / 32767, -1);
    case Int8Array:
      return Math.max(i / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Je(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return Math.round(i * 4294967295);
    case Uint16Array:
      return Math.round(i * 65535);
    case Uint8Array:
      return Math.round(i * 255);
    case Int32Array:
      return Math.round(i * 2147483647);
    case Int16Array:
      return Math.round(i * 32767);
    case Int8Array:
      return Math.round(i * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Kn = {
  DEG2RAD: _a,
  RAD2DEG: Ho,
  generateUUID: xi,
  clamp: Ht,
  euclideanModulo: Vm,
  mapLinear: mS,
  inverseLerp: gS,
  lerp: kl,
  damp: vS,
  pingpong: _S,
  smoothstep: yS,
  smootherstep: xS,
  randInt: MS,
  randFloat: bS,
  randFloatSpread: SS,
  seededRandom: wS,
  degToRad: TS,
  radToDeg: ES,
  isPowerOfTwo: Up,
  ceilPowerOfTwo: Sx,
  floorPowerOfTwo: Lu,
  setQuaternionFromProperEuler: AS,
  normalize: Je,
  denormalize: $n
};
class k {
  constructor(e = 0, t = 0) {
    k.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, s = e.elements;
    return this.x = s[0] * t + s[3] * n + s[6], this.y = s[1] * t + s[4] * n + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Ht(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), s = Math.sin(t), r = this.x - e.x, a = this.y - e.y;
    return this.x = r * n - a * s + e.x, this.y = r * s + a * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Qe {
  constructor(e, t, n, s, r, a, o, l, c) {
    Qe.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, s, r, a, o, l, c);
  }
  set(e, t, n, s, r, a, o, l, c) {
    const h = this.elements;
    return h[0] = e, h[1] = s, h[2] = o, h[3] = t, h[4] = r, h[5] = l, h[6] = n, h[7] = a, h[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, s = t.elements, r = this.elements, a = n[0], o = n[3], l = n[6], c = n[1], h = n[4], u = n[7], d = n[2], f = n[5], m = n[8], g = s[0], p = s[3], v = s[6], y = s[1], _ = s[4], x = s[7], M = s[2], S = s[5], w = s[8];
    return r[0] = a * g + o * y + l * M, r[3] = a * p + o * _ + l * S, r[6] = a * v + o * x + l * w, r[1] = c * g + h * y + u * M, r[4] = c * p + h * _ + u * S, r[7] = c * v + h * x + u * w, r[2] = d * g + f * y + m * M, r[5] = d * p + f * _ + m * S, r[8] = d * v + f * x + m * w, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], s = e[2], r = e[3], a = e[4], o = e[5], l = e[6], c = e[7], h = e[8];
    return t * a * h - t * o * c - n * r * h + n * o * l + s * r * c - s * a * l;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], s = e[2], r = e[3], a = e[4], o = e[5], l = e[6], c = e[7], h = e[8], u = h * a - o * c, d = o * l - h * r, f = c * r - a * l, m = t * u + n * d + s * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const g = 1 / m;
    return e[0] = u * g, e[1] = (s * c - h * n) * g, e[2] = (o * n - s * a) * g, e[3] = d * g, e[4] = (h * t - s * l) * g, e[5] = (s * r - o * t) * g, e[6] = f * g, e[7] = (n * l - c * t) * g, e[8] = (a * t - n * r) * g, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, s, r, a, o) {
    const l = Math.cos(r), c = Math.sin(r);
    return this.set(
      n * l,
      n * c,
      -n * (l * a + c * o) + a + e,
      -s * c,
      s * l,
      -s * (-c * a + l * o) + o + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply($d.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply($d.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply($d.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      n,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let s = 0; s < 9; s++)
      if (t[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const $d = /* @__PURE__ */ new Qe();
function wx(i) {
  for (let e = i.length - 1; e >= 0; --e)
    if (i[e] >= 65535) return !0;
  return !1;
}
const CS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function go(i, e) {
  return new CS[i](e);
}
function uc(i) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", i);
}
function Tx() {
  const i = uc("canvas");
  return i.style.display = "block", i;
}
const y0 = {};
function zl(i) {
  i in y0 || (y0[i] = !0, console.warn(i));
}
const x0 = /* @__PURE__ */ new Qe().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), M0 = /* @__PURE__ */ new Qe().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), sh = {
  [en]: {
    transfer: ac,
    primaries: oc,
    toReference: (i) => i,
    fromReference: (i) => i
  },
  [ft]: {
    transfer: Mt,
    primaries: oc,
    toReference: (i) => i.convertSRGBToLinear(),
    fromReference: (i) => i.convertLinearToSRGB()
  },
  [Uc]: {
    transfer: ac,
    primaries: lc,
    toReference: (i) => i.applyMatrix3(M0),
    fromReference: (i) => i.applyMatrix3(x0)
  },
  [pd]: {
    transfer: Mt,
    primaries: lc,
    toReference: (i) => i.convertSRGBToLinear().applyMatrix3(M0),
    fromReference: (i) => i.applyMatrix3(x0).convertLinearToSRGB()
  }
}, RS = /* @__PURE__ */ new Set([en, Uc]), gt = {
  enabled: !0,
  _workingColorSpace: en,
  get legacyMode() {
    return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled;
  },
  set legacyMode(i) {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !i;
  },
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(i) {
    if (!RS.has(i))
      throw new Error(`Unsupported working color space, "${i}".`);
    this._workingColorSpace = i;
  },
  convert: function(i, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return i;
    const n = sh[e].toReference, s = sh[t].fromReference;
    return s(n(i));
  },
  fromWorkingColorSpace: function(i, e) {
    return this.convert(i, this._workingColorSpace, e);
  },
  toWorkingColorSpace: function(i, e) {
    return this.convert(i, e, this._workingColorSpace);
  },
  getPrimaries: function(i) {
    return sh[i].primaries;
  },
  getTransfer: function(i) {
    return i === vi ? ac : sh[i].transfer;
  }
};
function Ao(i) {
  return i < 0.04045 ? i * 0.0773993808 : Math.pow(i * 0.9478672986 + 0.0521327014, 2.4);
}
function Kd(i) {
  return i < 31308e-7 ? i * 12.92 : 1.055 * Math.pow(i, 0.41666) - 0.055;
}
let Ga;
class Wm {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      Ga === void 0 && (Ga = uc("canvas")), Ga.width = e.width, Ga.height = e.height;
      const n = Ga.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Ga;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = uc("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const s = n.getImageData(0, 0, e.width, e.height), r = s.data;
      for (let a = 0; a < r.length; a++)
        r[a] = Ao(r[a] / 255) * 255;
      return n.putImageData(s, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Ao(t[n] / 255) * 255) : t[n] = Ao(t[n]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let PS = 0;
class ma {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: PS++ }), this.uuid = xi(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, s = this.data;
    if (s !== null) {
      let r;
      if (Array.isArray(s)) {
        r = [];
        for (let a = 0, o = s.length; a < o; a++)
          s[a].isDataTexture ? r.push(Qd(s[a].image)) : r.push(Qd(s[a]));
      } else
        r = Qd(s);
      n.url = r;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function Qd(i) {
  return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? Wm.getDataURL(i) : i.data ? {
    data: Array.from(i.data),
    width: i.width,
    height: i.height,
    type: i.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let LS = 0;
class At extends bs {
  constructor(e = At.DEFAULT_IMAGE, t = At.DEFAULT_MAPPING, n = Kt, s = Kt, r = Nt, a = ys, o = gi, l = ks, c = At.DEFAULT_ANISOTROPY, h = vi) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: LS++ }), this.uuid = xi(), this.name = "", this.source = new ma(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = s, this.magFilter = r, this.minFilter = a, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = l, this.offset = new k(0, 0), this.repeat = new k(1, 1), this.center = new k(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Qe(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof h == "string" ? this.colorSpace = h : (zl("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = h === vr ? ft : vi), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== ud) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Tn:
          e.x = e.x - Math.floor(e.x);
          break;
        case Kt:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Er:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Tn:
          e.y = e.y - Math.floor(e.y);
          break;
        case Kt:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Er:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  get encoding() {
    return zl("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === ft ? vr : Hm;
  }
  set encoding(e) {
    zl("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === vr ? ft : vi;
  }
}
At.DEFAULT_IMAGE = null;
At.DEFAULT_MAPPING = ud;
At.DEFAULT_ANISOTROPY = 1;
class tt {
  constructor(e = 0, t = 0, n = 0, s = 1) {
    tt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = s;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, s) {
    return this.x = e, this.y = t, this.z = n, this.w = s, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, s = this.z, r = this.w, a = e.elements;
    return this.x = a[0] * t + a[4] * n + a[8] * s + a[12] * r, this.y = a[1] * t + a[5] * n + a[9] * s + a[13] * r, this.z = a[2] * t + a[6] * n + a[10] * s + a[14] * r, this.w = a[3] * t + a[7] * n + a[11] * s + a[15] * r, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, s, r;
    const l = e.elements, c = l[0], h = l[4], u = l[8], d = l[1], f = l[5], m = l[9], g = l[2], p = l[6], v = l[10];
    if (Math.abs(h - d) < 0.01 && Math.abs(u - g) < 0.01 && Math.abs(m - p) < 0.01) {
      if (Math.abs(h + d) < 0.1 && Math.abs(u + g) < 0.1 && Math.abs(m + p) < 0.1 && Math.abs(c + f + v - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const _ = (c + 1) / 2, x = (f + 1) / 2, M = (v + 1) / 2, S = (h + d) / 4, w = (u + g) / 4, E = (m + p) / 4;
      return _ > x && _ > M ? _ < 0.01 ? (n = 0, s = 0.707106781, r = 0.707106781) : (n = Math.sqrt(_), s = S / n, r = w / n) : x > M ? x < 0.01 ? (n = 0.707106781, s = 0, r = 0.707106781) : (s = Math.sqrt(x), n = S / s, r = E / s) : M < 0.01 ? (n = 0.707106781, s = 0.707106781, r = 0) : (r = Math.sqrt(M), n = w / r, s = E / r), this.set(n, s, r, t), this;
    }
    let y = Math.sqrt((p - m) * (p - m) + (u - g) * (u - g) + (d - h) * (d - h));
    return Math.abs(y) < 1e-3 && (y = 1), this.x = (p - m) / y, this.y = (u - g) / y, this.z = (d - h) / y, this.w = Math.acos((c + f + v - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Ex extends bs {
  constructor(e = 1, t = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new tt(0, 0, e, t), this.scissorTest = !1, this.viewport = new tt(0, 0, e, t);
    const s = { width: e, height: t, depth: 1 };
    n.encoding !== void 0 && (zl("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), n.colorSpace = n.encoding === vr ? ft : vi), n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: Nt,
      depthBuffer: !0,
      stencilBuffer: !1,
      depthTexture: null,
      samples: 0
    }, n), this.texture = new At(s, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps, this.texture.internalFormat = n.internalFormat, this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  setSize(e, t, n = 1) {
    (this.width !== e || this.height !== t || this.depth !== n) && (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new ma(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class xt extends Ex {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), this.isWebGLRenderTarget = !0;
  }
}
class md extends At {
  constructor(e = null, t = 1, n = 1, s = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: s }, this.magFilter = lt, this.minFilter = lt, this.wrapR = Kt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class IS extends xt {
  constructor(e = 1, t = 1, n = 1) {
    super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new md(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class Xm extends At {
  constructor(e = null, t = 1, n = 1, s = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: s }, this.magFilter = lt, this.minFilter = lt, this.wrapR = Kt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class DS extends xt {
  constructor(e = 1, t = 1, n = 1) {
    super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new Xm(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class OS extends xt {
  constructor(e = 1, t = 1, n = 1, s = {}) {
    super(e, t, s), this.isWebGLMultipleRenderTargets = !0;
    const r = this.texture;
    this.texture = [];
    for (let a = 0; a < n; a++)
      this.texture[a] = r.clone(), this.texture[a].isRenderTargetTexture = !0;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      this.width = e, this.height = t, this.depth = n;
      for (let s = 0, r = this.texture.length; s < r; s++)
        this.texture[s].image.width = e, this.texture[s].image.height = t, this.texture[s].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, n = e.texture.length; t < n; t++)
      this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
}
class pt {
  constructor(e = 0, t = 0, n = 0, s = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = s;
  }
  static slerpFlat(e, t, n, s, r, a, o) {
    let l = n[s + 0], c = n[s + 1], h = n[s + 2], u = n[s + 3];
    const d = r[a + 0], f = r[a + 1], m = r[a + 2], g = r[a + 3];
    if (o === 0) {
      e[t + 0] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = u;
      return;
    }
    if (o === 1) {
      e[t + 0] = d, e[t + 1] = f, e[t + 2] = m, e[t + 3] = g;
      return;
    }
    if (u !== g || l !== d || c !== f || h !== m) {
      let p = 1 - o;
      const v = l * d + c * f + h * m + u * g, y = v >= 0 ? 1 : -1, _ = 1 - v * v;
      if (_ > Number.EPSILON) {
        const M = Math.sqrt(_), S = Math.atan2(M, v * y);
        p = Math.sin(p * S) / M, o = Math.sin(o * S) / M;
      }
      const x = o * y;
      if (l = l * p + d * x, c = c * p + f * x, h = h * p + m * x, u = u * p + g * x, p === 1 - o) {
        const M = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
        l *= M, c *= M, h *= M, u *= M;
      }
    }
    e[t] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = u;
  }
  static multiplyQuaternionsFlat(e, t, n, s, r, a) {
    const o = n[s], l = n[s + 1], c = n[s + 2], h = n[s + 3], u = r[a], d = r[a + 1], f = r[a + 2], m = r[a + 3];
    return e[t] = o * m + h * u + l * f - c * d, e[t + 1] = l * m + h * d + c * u - o * f, e[t + 2] = c * m + h * f + o * d - l * u, e[t + 3] = h * m - o * u - l * d - c * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, n, s) {
    return this._x = e, this._y = t, this._z = n, this._w = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const n = e._x, s = e._y, r = e._z, a = e._order, o = Math.cos, l = Math.sin, c = o(n / 2), h = o(s / 2), u = o(r / 2), d = l(n / 2), f = l(s / 2), m = l(r / 2);
    switch (a) {
      case "XYZ":
        this._x = d * h * u + c * f * m, this._y = c * f * u - d * h * m, this._z = c * h * m + d * f * u, this._w = c * h * u - d * f * m;
        break;
      case "YXZ":
        this._x = d * h * u + c * f * m, this._y = c * f * u - d * h * m, this._z = c * h * m - d * f * u, this._w = c * h * u + d * f * m;
        break;
      case "ZXY":
        this._x = d * h * u - c * f * m, this._y = c * f * u + d * h * m, this._z = c * h * m + d * f * u, this._w = c * h * u - d * f * m;
        break;
      case "ZYX":
        this._x = d * h * u - c * f * m, this._y = c * f * u + d * h * m, this._z = c * h * m - d * f * u, this._w = c * h * u + d * f * m;
        break;
      case "YZX":
        this._x = d * h * u + c * f * m, this._y = c * f * u + d * h * m, this._z = c * h * m - d * f * u, this._w = c * h * u - d * f * m;
        break;
      case "XZY":
        this._x = d * h * u - c * f * m, this._y = c * f * u - d * h * m, this._z = c * h * m + d * f * u, this._w = c * h * u + d * f * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2, s = Math.sin(n);
    return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], s = t[4], r = t[8], a = t[1], o = t[5], l = t[9], c = t[2], h = t[6], u = t[10], d = n + o + u;
    if (d > 0) {
      const f = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / f, this._x = (h - l) * f, this._y = (r - c) * f, this._z = (a - s) * f;
    } else if (n > o && n > u) {
      const f = 2 * Math.sqrt(1 + n - o - u);
      this._w = (h - l) / f, this._x = 0.25 * f, this._y = (s + a) / f, this._z = (r + c) / f;
    } else if (o > u) {
      const f = 2 * Math.sqrt(1 + o - n - u);
      this._w = (r - c) / f, this._x = (s + a) / f, this._y = 0.25 * f, this._z = (l + h) / f;
    } else {
      const f = 2 * Math.sqrt(1 + u - n - o);
      this._w = (a - s) / f, this._x = (r + c) / f, this._y = (l + h) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Ht(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const s = Math.min(1, t / n);
    return this.slerp(e, s), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x, s = e._y, r = e._z, a = e._w, o = t._x, l = t._y, c = t._z, h = t._w;
    return this._x = n * h + a * o + s * c - r * l, this._y = s * h + a * l + r * o - n * c, this._z = r * h + a * c + n * l - s * o, this._w = a * h - n * o - s * l - r * c, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x, s = this._y, r = this._z, a = this._w;
    let o = a * e._w + n * e._x + s * e._y + r * e._z;
    if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1)
      return this._w = a, this._x = n, this._y = s, this._z = r, this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const f = 1 - t;
      return this._w = f * a + t * this._w, this._x = f * n + t * this._x, this._y = f * s + t * this._y, this._z = f * r + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const c = Math.sqrt(l), h = Math.atan2(c, o), u = Math.sin((1 - t) * h) / c, d = Math.sin(t * h) / c;
    return this._w = a * u + this._w * d, this._x = n * u + this._x * d, this._y = s * u + this._y * d, this._z = r * u + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), n = Math.sqrt(e), s = 2 * Math.PI * Math.random(), r = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(s),
      n * Math.sin(r),
      n * Math.cos(r),
      t * Math.sin(s)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class T {
  constructor(e = 0, t = 0, n = 0) {
    T.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
  }
  set(e, t, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(b0.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(b0.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, s = this.z, r = e.elements;
    return this.x = r[0] * t + r[3] * n + r[6] * s, this.y = r[1] * t + r[4] * n + r[7] * s, this.z = r[2] * t + r[5] * n + r[8] * s, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, s = this.z, r = e.elements, a = 1 / (r[3] * t + r[7] * n + r[11] * s + r[15]);
    return this.x = (r[0] * t + r[4] * n + r[8] * s + r[12]) * a, this.y = (r[1] * t + r[5] * n + r[9] * s + r[13]) * a, this.z = (r[2] * t + r[6] * n + r[10] * s + r[14]) * a, this;
  }
  applyQuaternion(e) {
    const t = this.x, n = this.y, s = this.z, r = e.x, a = e.y, o = e.z, l = e.w, c = 2 * (a * s - o * n), h = 2 * (o * t - r * s), u = 2 * (r * n - a * t);
    return this.x = t + l * c + a * u - o * h, this.y = n + l * h + o * c - r * u, this.z = s + l * u + r * h - a * c, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, n = this.y, s = this.z, r = e.elements;
    return this.x = r[0] * t + r[4] * n + r[8] * s, this.y = r[1] * t + r[5] * n + r[9] * s, this.z = r[2] * t + r[6] * n + r[10] * s, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x, s = e.y, r = e.z, a = t.x, o = t.y, l = t.z;
    return this.x = s * l - r * o, this.y = r * a - n * l, this.z = n * o - s * a, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return Jd.copy(this).projectOnVector(e), this.sub(Jd);
  }
  reflect(e) {
    return this.sub(Jd.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Ht(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, s = this.z - e.z;
    return t * t + n * n + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const s = Math.sin(t) * e;
    return this.x = s * Math.sin(n), this.y = Math.cos(t) * e, this.z = s * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = s, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, n = Math.sqrt(1 - e ** 2);
    return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Jd = /* @__PURE__ */ new T(), b0 = /* @__PURE__ */ new pt();
class ln {
  constructor(e = new T(1 / 0, 1 / 0, 1 / 0), t = new T(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(Ui.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(Ui.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Ui.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const r = n.getAttribute("position");
      if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, o = r.count; a < o; a++)
          e.isMesh === !0 ? e.getVertexPosition(a, Ui) : Ui.fromBufferAttribute(r, a), Ui.applyMatrix4(e.matrixWorld), this.expandByPoint(Ui);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), rh.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), rh.copy(n.boundingBox)), rh.applyMatrix4(e.matrixWorld), this.union(rh);
    }
    const s = e.children;
    for (let r = 0, a = s.length; r < a; r++)
      this.expandByObject(s[r], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Ui), Ui.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(dl), ah.subVectors(this.max, dl), Va.subVectors(e.a, dl), Wa.subVectors(e.b, dl), Xa.subVectors(e.c, dl), Ks.subVectors(Wa, Va), Qs.subVectors(Xa, Wa), Yr.subVectors(Va, Xa);
    let t = [
      0,
      -Ks.z,
      Ks.y,
      0,
      -Qs.z,
      Qs.y,
      0,
      -Yr.z,
      Yr.y,
      Ks.z,
      0,
      -Ks.x,
      Qs.z,
      0,
      -Qs.x,
      Yr.z,
      0,
      -Yr.x,
      -Ks.y,
      Ks.x,
      0,
      -Qs.y,
      Qs.x,
      0,
      -Yr.y,
      Yr.x,
      0
    ];
    return !ef(t, Va, Wa, Xa, ah) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !ef(t, Va, Wa, Xa, ah)) ? !1 : (oh.crossVectors(Ks, Qs), t = [oh.x, oh.y, oh.z], ef(t, Va, Wa, Xa, ah));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Ui).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Ui).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (As[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), As[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), As[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), As[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), As[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), As[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), As[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), As[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(As), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const As = [
  /* @__PURE__ */ new T(),
  /* @__PURE__ */ new T(),
  /* @__PURE__ */ new T(),
  /* @__PURE__ */ new T(),
  /* @__PURE__ */ new T(),
  /* @__PURE__ */ new T(),
  /* @__PURE__ */ new T(),
  /* @__PURE__ */ new T()
], Ui = /* @__PURE__ */ new T(), rh = /* @__PURE__ */ new ln(), Va = /* @__PURE__ */ new T(), Wa = /* @__PURE__ */ new T(), Xa = /* @__PURE__ */ new T(), Ks = /* @__PURE__ */ new T(), Qs = /* @__PURE__ */ new T(), Yr = /* @__PURE__ */ new T(), dl = /* @__PURE__ */ new T(), ah = /* @__PURE__ */ new T(), oh = /* @__PURE__ */ new T(), jr = /* @__PURE__ */ new T();
function ef(i, e, t, n, s) {
  for (let r = 0, a = i.length - 3; r <= a; r += 3) {
    jr.fromArray(i, r);
    const o = s.x * Math.abs(jr.x) + s.y * Math.abs(jr.y) + s.z * Math.abs(jr.z), l = e.dot(jr), c = t.dot(jr), h = n.dot(jr);
    if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > o)
      return !1;
  }
  return !0;
}
const NS = /* @__PURE__ */ new ln(), fl = /* @__PURE__ */ new T(), tf = /* @__PURE__ */ new T();
class oi {
  constructor(e = new T(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : NS.setFromPoints(e).getCenter(n);
    let s = 0;
    for (let r = 0, a = e.length; r < a; r++)
      s = Math.max(s, n.distanceToSquared(e[r]));
    return this.radius = Math.sqrt(s), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    fl.subVectors(e, this.center);
    const t = fl.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t), s = (n - this.radius) * 0.5;
      this.center.addScaledVector(fl, s / n), this.radius += s;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (tf.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(fl.copy(e.center).add(tf)), this.expandByPoint(fl.copy(e.center).sub(tf))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Cs = /* @__PURE__ */ new T(), nf = /* @__PURE__ */ new T(), lh = /* @__PURE__ */ new T(), Js = /* @__PURE__ */ new T(), sf = /* @__PURE__ */ new T(), ch = /* @__PURE__ */ new T(), rf = /* @__PURE__ */ new T();
class Oa {
  constructor(e = new T(), t = new T(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Cs)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Cs.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (Cs.copy(this.origin).addScaledVector(this.direction, t), Cs.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, s) {
    nf.copy(e).add(t).multiplyScalar(0.5), lh.copy(t).sub(e).normalize(), Js.copy(this.origin).sub(nf);
    const r = e.distanceTo(t) * 0.5, a = -this.direction.dot(lh), o = Js.dot(this.direction), l = -Js.dot(lh), c = Js.lengthSq(), h = Math.abs(1 - a * a);
    let u, d, f, m;
    if (h > 0)
      if (u = a * l - o, d = a * o - l, m = r * h, u >= 0)
        if (d >= -m)
          if (d <= m) {
            const g = 1 / h;
            u *= g, d *= g, f = u * (u + a * d + 2 * o) + d * (a * u + d + 2 * l) + c;
          } else
            d = r, u = Math.max(0, -(a * d + o)), f = -u * u + d * (d + 2 * l) + c;
        else
          d = -r, u = Math.max(0, -(a * d + o)), f = -u * u + d * (d + 2 * l) + c;
      else
        d <= -m ? (u = Math.max(0, -(-a * r + o)), d = u > 0 ? -r : Math.min(Math.max(-r, -l), r), f = -u * u + d * (d + 2 * l) + c) : d <= m ? (u = 0, d = Math.min(Math.max(-r, -l), r), f = d * (d + 2 * l) + c) : (u = Math.max(0, -(a * r + o)), d = u > 0 ? r : Math.min(Math.max(-r, -l), r), f = -u * u + d * (d + 2 * l) + c);
    else
      d = a > 0 ? -r : r, u = Math.max(0, -(a * d + o)), f = -u * u + d * (d + 2 * l) + c;
    return n && n.copy(this.origin).addScaledVector(this.direction, u), s && s.copy(nf).addScaledVector(lh, d), f;
  }
  intersectSphere(e, t) {
    Cs.subVectors(e.center, this.origin);
    const n = Cs.dot(this.direction), s = Cs.dot(Cs) - n * n, r = e.radius * e.radius;
    if (s > r) return null;
    const a = Math.sqrt(r - s), o = n - a, l = n + a;
    return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, s, r, a, o, l;
    const c = 1 / this.direction.x, h = 1 / this.direction.y, u = 1 / this.direction.z, d = this.origin;
    return c >= 0 ? (n = (e.min.x - d.x) * c, s = (e.max.x - d.x) * c) : (n = (e.max.x - d.x) * c, s = (e.min.x - d.x) * c), h >= 0 ? (r = (e.min.y - d.y) * h, a = (e.max.y - d.y) * h) : (r = (e.max.y - d.y) * h, a = (e.min.y - d.y) * h), n > a || r > s || ((r > n || isNaN(n)) && (n = r), (a < s || isNaN(s)) && (s = a), u >= 0 ? (o = (e.min.z - d.z) * u, l = (e.max.z - d.z) * u) : (o = (e.max.z - d.z) * u, l = (e.min.z - d.z) * u), n > l || o > s) || ((o > n || n !== n) && (n = o), (l < s || s !== s) && (s = l), s < 0) ? null : this.at(n >= 0 ? n : s, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Cs) !== null;
  }
  intersectTriangle(e, t, n, s, r) {
    sf.subVectors(t, e), ch.subVectors(n, e), rf.crossVectors(sf, ch);
    let a = this.direction.dot(rf), o;
    if (a > 0) {
      if (s) return null;
      o = 1;
    } else if (a < 0)
      o = -1, a = -a;
    else
      return null;
    Js.subVectors(this.origin, e);
    const l = o * this.direction.dot(ch.crossVectors(Js, ch));
    if (l < 0)
      return null;
    const c = o * this.direction.dot(sf.cross(Js));
    if (c < 0 || l + c > a)
      return null;
    const h = -o * Js.dot(rf);
    return h < 0 ? null : this.at(h / a, r);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class _e {
  constructor(e, t, n, s, r, a, o, l, c, h, u, d, f, m, g, p) {
    _e.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, s, r, a, o, l, c, h, u, d, f, m, g, p);
  }
  set(e, t, n, s, r, a, o, l, c, h, u, d, f, m, g, p) {
    const v = this.elements;
    return v[0] = e, v[4] = t, v[8] = n, v[12] = s, v[1] = r, v[5] = a, v[9] = o, v[13] = l, v[2] = c, v[6] = h, v[10] = u, v[14] = d, v[3] = f, v[7] = m, v[11] = g, v[15] = p, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new _e().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, n) {
    return this.set(
      e.x,
      t.x,
      n.x,
      0,
      e.y,
      t.y,
      n.y,
      0,
      e.z,
      t.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, n = e.elements, s = 1 / qa.setFromMatrixColumn(e, 0).length(), r = 1 / qa.setFromMatrixColumn(e, 1).length(), a = 1 / qa.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * s, t[1] = n[1] * s, t[2] = n[2] * s, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, s = e.y, r = e.z, a = Math.cos(n), o = Math.sin(n), l = Math.cos(s), c = Math.sin(s), h = Math.cos(r), u = Math.sin(r);
    if (e.order === "XYZ") {
      const d = a * h, f = a * u, m = o * h, g = o * u;
      t[0] = l * h, t[4] = -l * u, t[8] = c, t[1] = f + m * c, t[5] = d - g * c, t[9] = -o * l, t[2] = g - d * c, t[6] = m + f * c, t[10] = a * l;
    } else if (e.order === "YXZ") {
      const d = l * h, f = l * u, m = c * h, g = c * u;
      t[0] = d + g * o, t[4] = m * o - f, t[8] = a * c, t[1] = a * u, t[5] = a * h, t[9] = -o, t[2] = f * o - m, t[6] = g + d * o, t[10] = a * l;
    } else if (e.order === "ZXY") {
      const d = l * h, f = l * u, m = c * h, g = c * u;
      t[0] = d - g * o, t[4] = -a * u, t[8] = m + f * o, t[1] = f + m * o, t[5] = a * h, t[9] = g - d * o, t[2] = -a * c, t[6] = o, t[10] = a * l;
    } else if (e.order === "ZYX") {
      const d = a * h, f = a * u, m = o * h, g = o * u;
      t[0] = l * h, t[4] = m * c - f, t[8] = d * c + g, t[1] = l * u, t[5] = g * c + d, t[9] = f * c - m, t[2] = -c, t[6] = o * l, t[10] = a * l;
    } else if (e.order === "YZX") {
      const d = a * l, f = a * c, m = o * l, g = o * c;
      t[0] = l * h, t[4] = g - d * u, t[8] = m * u + f, t[1] = u, t[5] = a * h, t[9] = -o * h, t[2] = -c * h, t[6] = f * u + m, t[10] = d - g * u;
    } else if (e.order === "XZY") {
      const d = a * l, f = a * c, m = o * l, g = o * c;
      t[0] = l * h, t[4] = -u, t[8] = c * h, t[1] = d * u + g, t[5] = a * h, t[9] = f * u - m, t[2] = m * u - f, t[6] = o * h, t[10] = g * u + d;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(US, e, FS);
  }
  lookAt(e, t, n) {
    const s = this.elements;
    return ui.subVectors(e, t), ui.lengthSq() === 0 && (ui.z = 1), ui.normalize(), er.crossVectors(n, ui), er.lengthSq() === 0 && (Math.abs(n.z) === 1 ? ui.x += 1e-4 : ui.z += 1e-4, ui.normalize(), er.crossVectors(n, ui)), er.normalize(), hh.crossVectors(ui, er), s[0] = er.x, s[4] = hh.x, s[8] = ui.x, s[1] = er.y, s[5] = hh.y, s[9] = ui.y, s[2] = er.z, s[6] = hh.z, s[10] = ui.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, s = t.elements, r = this.elements, a = n[0], o = n[4], l = n[8], c = n[12], h = n[1], u = n[5], d = n[9], f = n[13], m = n[2], g = n[6], p = n[10], v = n[14], y = n[3], _ = n[7], x = n[11], M = n[15], S = s[0], w = s[4], E = s[8], b = s[12], A = s[1], D = s[5], B = s[9], X = s[13], L = s[2], F = s[6], H = s[10], G = s[14], te = s[3], j = s[7], J = s[11], N = s[15];
    return r[0] = a * S + o * A + l * L + c * te, r[4] = a * w + o * D + l * F + c * j, r[8] = a * E + o * B + l * H + c * J, r[12] = a * b + o * X + l * G + c * N, r[1] = h * S + u * A + d * L + f * te, r[5] = h * w + u * D + d * F + f * j, r[9] = h * E + u * B + d * H + f * J, r[13] = h * b + u * X + d * G + f * N, r[2] = m * S + g * A + p * L + v * te, r[6] = m * w + g * D + p * F + v * j, r[10] = m * E + g * B + p * H + v * J, r[14] = m * b + g * X + p * G + v * N, r[3] = y * S + _ * A + x * L + M * te, r[7] = y * w + _ * D + x * F + M * j, r[11] = y * E + _ * B + x * H + M * J, r[15] = y * b + _ * X + x * G + M * N, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[4], s = e[8], r = e[12], a = e[1], o = e[5], l = e[9], c = e[13], h = e[2], u = e[6], d = e[10], f = e[14], m = e[3], g = e[7], p = e[11], v = e[15];
    return m * (+r * l * u - s * c * u - r * o * d + n * c * d + s * o * f - n * l * f) + g * (+t * l * f - t * c * d + r * a * d - s * a * f + s * c * h - r * l * h) + p * (+t * c * u - t * o * f - r * a * u + n * a * f + r * o * h - n * c * h) + v * (-s * o * h - t * l * u + t * o * d + s * a * u - n * a * d + n * l * h);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, n) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = t, s[14] = n), this;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], s = e[2], r = e[3], a = e[4], o = e[5], l = e[6], c = e[7], h = e[8], u = e[9], d = e[10], f = e[11], m = e[12], g = e[13], p = e[14], v = e[15], y = u * p * c - g * d * c + g * l * f - o * p * f - u * l * v + o * d * v, _ = m * d * c - h * p * c - m * l * f + a * p * f + h * l * v - a * d * v, x = h * g * c - m * u * c + m * o * f - a * g * f - h * o * v + a * u * v, M = m * u * l - h * g * l - m * o * d + a * g * d + h * o * p - a * u * p, S = t * y + n * _ + s * x + r * M;
    if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / S;
    return e[0] = y * w, e[1] = (g * d * r - u * p * r - g * s * f + n * p * f + u * s * v - n * d * v) * w, e[2] = (o * p * r - g * l * r + g * s * c - n * p * c - o * s * v + n * l * v) * w, e[3] = (u * l * r - o * d * r - u * s * c + n * d * c + o * s * f - n * l * f) * w, e[4] = _ * w, e[5] = (h * p * r - m * d * r + m * s * f - t * p * f - h * s * v + t * d * v) * w, e[6] = (m * l * r - a * p * r - m * s * c + t * p * c + a * s * v - t * l * v) * w, e[7] = (a * d * r - h * l * r + h * s * c - t * d * c - a * s * f + t * l * f) * w, e[8] = x * w, e[9] = (m * u * r - h * g * r - m * n * f + t * g * f + h * n * v - t * u * v) * w, e[10] = (a * g * r - m * o * r + m * n * c - t * g * c - a * n * v + t * o * v) * w, e[11] = (h * o * r - a * u * r - h * n * c + t * u * c + a * n * f - t * o * f) * w, e[12] = M * w, e[13] = (h * g * s - m * u * s + m * n * d - t * g * d - h * n * p + t * u * p) * w, e[14] = (m * o * s - a * g * s - m * n * l + t * g * l + a * n * p - t * o * p) * w, e[15] = (a * u * s - h * o * s + h * n * l - t * u * l - a * n * d + t * o * d) * w, this;
  }
  scale(e) {
    const t = this.elements, n = e.x, s = e.y, r = e.z;
    return t[0] *= n, t[4] *= s, t[8] *= r, t[1] *= n, t[5] *= s, t[9] *= r, t[2] *= n, t[6] *= s, t[10] *= r, t[3] *= n, t[7] *= s, t[11] *= r, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, s));
  }
  makeTranslation(e, t, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t), s = Math.sin(t), r = 1 - n, a = e.x, o = e.y, l = e.z, c = r * a, h = r * o;
    return this.set(
      c * a + n,
      c * o - s * l,
      c * l + s * o,
      0,
      c * o + s * l,
      h * o + n,
      h * l - s * a,
      0,
      c * l - s * o,
      h * l + s * a,
      r * l * l + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, n, s, r, a) {
    return this.set(
      1,
      n,
      r,
      0,
      e,
      1,
      a,
      0,
      t,
      s,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, n) {
    const s = this.elements, r = t._x, a = t._y, o = t._z, l = t._w, c = r + r, h = a + a, u = o + o, d = r * c, f = r * h, m = r * u, g = a * h, p = a * u, v = o * u, y = l * c, _ = l * h, x = l * u, M = n.x, S = n.y, w = n.z;
    return s[0] = (1 - (g + v)) * M, s[1] = (f + x) * M, s[2] = (m - _) * M, s[3] = 0, s[4] = (f - x) * S, s[5] = (1 - (d + v)) * S, s[6] = (p + y) * S, s[7] = 0, s[8] = (m + _) * w, s[9] = (p - y) * w, s[10] = (1 - (d + g)) * w, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  decompose(e, t, n) {
    const s = this.elements;
    let r = qa.set(s[0], s[1], s[2]).length();
    const a = qa.set(s[4], s[5], s[6]).length(), o = qa.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (r = -r), e.x = s[12], e.y = s[13], e.z = s[14], Fi.copy(this);
    const c = 1 / r, h = 1 / a, u = 1 / o;
    return Fi.elements[0] *= c, Fi.elements[1] *= c, Fi.elements[2] *= c, Fi.elements[4] *= h, Fi.elements[5] *= h, Fi.elements[6] *= h, Fi.elements[8] *= u, Fi.elements[9] *= u, Fi.elements[10] *= u, t.setFromRotationMatrix(Fi), n.x = r, n.y = a, n.z = o, this;
  }
  makePerspective(e, t, n, s, r, a, o = us) {
    const l = this.elements, c = 2 * r / (t - e), h = 2 * r / (n - s), u = (t + e) / (t - e), d = (n + s) / (n - s);
    let f, m;
    if (o === us)
      f = -(a + r) / (a - r), m = -2 * a * r / (a - r);
    else if (o === hc)
      f = -a / (a - r), m = -a * r / (a - r);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
    return l[0] = c, l[4] = 0, l[8] = u, l[12] = 0, l[1] = 0, l[5] = h, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = f, l[14] = m, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(e, t, n, s, r, a, o = us) {
    const l = this.elements, c = 1 / (t - e), h = 1 / (n - s), u = 1 / (a - r), d = (t + e) * c, f = (n + s) * h;
    let m, g;
    if (o === us)
      m = (a + r) * u, g = -2 * u;
    else if (o === hc)
      m = r * u, g = -1 * u;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
    return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * h, l[9] = 0, l[13] = -f, l[2] = 0, l[6] = 0, l[10] = g, l[14] = -m, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let s = 0; s < 16; s++)
      if (t[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
}
const qa = /* @__PURE__ */ new T(), Fi = /* @__PURE__ */ new _e(), US = /* @__PURE__ */ new T(0, 0, 0), FS = /* @__PURE__ */ new T(1, 1, 1), er = /* @__PURE__ */ new T(), hh = /* @__PURE__ */ new T(), ui = /* @__PURE__ */ new T(), S0 = /* @__PURE__ */ new _e(), w0 = /* @__PURE__ */ new pt();
class Jn {
  constructor(e = 0, t = 0, n = 0, s = Jn.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, n, s = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const s = e.elements, r = s[0], a = s[4], o = s[8], l = s[1], c = s[5], h = s[9], u = s[2], d = s[6], f = s[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Ht(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(d, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Ht(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(o, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, r), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Ht(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-u, f), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(l, r));
        break;
      case "ZYX":
        this._y = Math.asin(-Ht(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-a, c));
        break;
      case "YZX":
        this._z = Math.asin(Ht(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(o, f));
        break;
      case "XZY":
        this._z = Math.asin(-Ht(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-h, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return S0.makeRotationFromQuaternion(e), this.setFromRotationMatrix(S0, t, n);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return w0.setFromEuler(this), this.setFromQuaternion(w0, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Jn.DEFAULT_ORDER = "XYZ";
class gd {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let BS = 0;
const T0 = /* @__PURE__ */ new T(), Ya = /* @__PURE__ */ new pt(), Rs = /* @__PURE__ */ new _e(), uh = /* @__PURE__ */ new T(), pl = /* @__PURE__ */ new T(), kS = /* @__PURE__ */ new T(), zS = /* @__PURE__ */ new pt(), E0 = /* @__PURE__ */ new T(1, 0, 0), A0 = /* @__PURE__ */ new T(0, 1, 0), C0 = /* @__PURE__ */ new T(0, 0, 1), HS = { type: "added" }, GS = { type: "removed" };
class Ze extends bs {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: BS++ }), this.uuid = xi(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ze.DEFAULT_UP.clone();
    const e = new T(), t = new Jn(), n = new pt(), s = new T(1, 1, 1);
    function r() {
      n.setFromEuler(t, !1);
    }
    function a() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(r), n._onChange(a), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: s
      },
      modelViewMatrix: {
        value: new _e()
      },
      normalMatrix: {
        value: new Qe()
      }
    }), this.matrix = new _e(), this.matrixWorld = new _e(), this.matrixAutoUpdate = Ze.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = Ze.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new gd(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Ya.setFromAxisAngle(e, t), this.quaternion.multiply(Ya), this;
  }
  rotateOnWorldAxis(e, t) {
    return Ya.setFromAxisAngle(e, t), this.quaternion.premultiply(Ya), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(E0, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(A0, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(C0, e);
  }
  translateOnAxis(e, t) {
    return T0.copy(e).applyQuaternion(this.quaternion), this.position.add(T0.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(E0, e);
  }
  translateY(e) {
    return this.translateOnAxis(A0, e);
  }
  translateZ(e) {
    return this.translateOnAxis(C0, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Rs.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? uh.copy(e) : uh.set(e, t, n);
    const s = this.parent;
    this.updateWorldMatrix(!0, !1), pl.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Rs.lookAt(pl, uh, this.up) : Rs.lookAt(uh, pl, this.up), this.quaternion.setFromRotationMatrix(Rs), s && (Rs.extractRotation(s.matrixWorld), Ya.setFromRotationMatrix(Rs), this.quaternion.premultiply(Ya.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(HS)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(GS)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Rs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Rs.multiply(e.parent.matrixWorld)), e.applyMatrix4(Rs), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, s = this.children.length; n < s; n++) {
      const a = this.children[n].getObjectByProperty(e, t);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, t) {
    let n = [];
    this[e] === t && n.push(this);
    for (let s = 0, r = this.children.length; s < r; s++) {
      const a = this.children[s].getObjectsByProperty(e, t);
      a.length > 0 && (n = n.concat(a));
    }
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(pl, e, kS), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(pl, zS, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, s = t.length; n < s; n++)
      t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, s = t.length; n < s; n++)
      t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let n = 0, s = t.length; n < s; n++) {
      const r = t[n];
      (r.matrixWorldAutoUpdate === !0 || e === !0) && r.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const s = this.children;
      for (let r = 0, a = s.length; r < a; r++) {
        const o = s[r];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", n = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const s = {};
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON()));
    function r(o, l) {
      return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = r(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const l = o.shapes;
        if (Array.isArray(l))
          for (let c = 0, h = l.length; c < h; c++) {
            const u = l[c];
            r(e.shapes, u);
          }
        else
          r(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          o.push(r(e.materials, this.material[l]));
        s.material = o;
      } else
        s.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let o = 0; o < this.children.length; o++)
        s.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      s.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const l = this.animations[o];
        s.animations.push(r(e.animations, l));
      }
    }
    if (t) {
      const o = a(e.geometries), l = a(e.materials), c = a(e.textures), h = a(e.images), u = a(e.shapes), d = a(e.skeletons), f = a(e.animations), m = a(e.nodes);
      o.length > 0 && (n.geometries = o), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), u.length > 0 && (n.shapes = u), d.length > 0 && (n.skeletons = d), f.length > 0 && (n.animations = f), m.length > 0 && (n.nodes = m);
    }
    return n.object = s, n;
    function a(o) {
      const l = [];
      for (const c in o) {
        const h = o[c];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let n = 0; n < e.children.length; n++) {
        const s = e.children[n];
        this.add(s.clone());
      }
    return this;
  }
}
Ze.DEFAULT_UP = /* @__PURE__ */ new T(0, 1, 0);
Ze.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ze.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Bi = /* @__PURE__ */ new T(), Ps = /* @__PURE__ */ new T(), af = /* @__PURE__ */ new T(), Ls = /* @__PURE__ */ new T(), ja = /* @__PURE__ */ new T(), Za = /* @__PURE__ */ new T(), R0 = /* @__PURE__ */ new T(), of = /* @__PURE__ */ new T(), lf = /* @__PURE__ */ new T(), cf = /* @__PURE__ */ new T();
let dh = !1;
class Zn {
  constructor(e = new T(), t = new T(), n = new T()) {
    this.a = e, this.b = t, this.c = n;
  }
  static getNormal(e, t, n, s) {
    s.subVectors(n, t), Bi.subVectors(e, t), s.cross(Bi);
    const r = s.lengthSq();
    return r > 0 ? s.multiplyScalar(1 / Math.sqrt(r)) : s.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, n, s, r) {
    Bi.subVectors(s, t), Ps.subVectors(n, t), af.subVectors(e, t);
    const a = Bi.dot(Bi), o = Bi.dot(Ps), l = Bi.dot(af), c = Ps.dot(Ps), h = Ps.dot(af), u = a * c - o * o;
    if (u === 0)
      return r.set(-2, -1, -1);
    const d = 1 / u, f = (c * l - o * h) * d, m = (a * h - o * l) * d;
    return r.set(1 - f - m, m, f);
  }
  static containsPoint(e, t, n, s) {
    return this.getBarycoord(e, t, n, s, Ls), Ls.x >= 0 && Ls.y >= 0 && Ls.x + Ls.y <= 1;
  }
  static getUV(e, t, n, s, r, a, o, l) {
    return dh === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), dh = !0), this.getInterpolation(e, t, n, s, r, a, o, l);
  }
  static getInterpolation(e, t, n, s, r, a, o, l) {
    return this.getBarycoord(e, t, n, s, Ls), l.setScalar(0), l.addScaledVector(r, Ls.x), l.addScaledVector(a, Ls.y), l.addScaledVector(o, Ls.z), l;
  }
  static isFrontFacing(e, t, n, s) {
    return Bi.subVectors(n, t), Ps.subVectors(e, t), Bi.cross(Ps).dot(s) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, s) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[s]), this;
  }
  setFromAttributeAndIndices(e, t, n, s) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, s), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Bi.subVectors(this.c, this.b), Ps.subVectors(this.a, this.b), Bi.cross(Ps).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Zn.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Zn.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, n, s, r) {
    return dh === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), dh = !0), Zn.getInterpolation(e, this.a, this.b, this.c, t, n, s, r);
  }
  getInterpolation(e, t, n, s, r) {
    return Zn.getInterpolation(e, this.a, this.b, this.c, t, n, s, r);
  }
  containsPoint(e) {
    return Zn.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Zn.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a, s = this.b, r = this.c;
    let a, o;
    ja.subVectors(s, n), Za.subVectors(r, n), of.subVectors(e, n);
    const l = ja.dot(of), c = Za.dot(of);
    if (l <= 0 && c <= 0)
      return t.copy(n);
    lf.subVectors(e, s);
    const h = ja.dot(lf), u = Za.dot(lf);
    if (h >= 0 && u <= h)
      return t.copy(s);
    const d = l * u - h * c;
    if (d <= 0 && l >= 0 && h <= 0)
      return a = l / (l - h), t.copy(n).addScaledVector(ja, a);
    cf.subVectors(e, r);
    const f = ja.dot(cf), m = Za.dot(cf);
    if (m >= 0 && f <= m)
      return t.copy(r);
    const g = f * c - l * m;
    if (g <= 0 && c >= 0 && m <= 0)
      return o = c / (c - m), t.copy(n).addScaledVector(Za, o);
    const p = h * m - f * u;
    if (p <= 0 && u - h >= 0 && f - m >= 0)
      return R0.subVectors(r, s), o = (u - h) / (u - h + (f - m)), t.copy(s).addScaledVector(R0, o);
    const v = 1 / (p + g + d);
    return a = g * v, o = d * v, t.copy(n).addScaledVector(ja, a).addScaledVector(Za, o);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const Ax = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, tr = { h: 0, s: 0, l: 0 }, fh = { h: 0, s: 0, l: 0 };
function hf(i, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? i + (e - i) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? i + (e - i) * 6 * (2 / 3 - t) : i;
}
let Q = class {
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const s = e;
      s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
    } else
      this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = ft) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, gt.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, s = gt.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, gt.toWorkingColorSpace(this, s), this;
  }
  setHSL(e, t, n, s = gt.workingColorSpace) {
    if (e = Vm(e, 1), t = Ht(t, 0, 1), n = Ht(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const r = n <= 0.5 ? n * (1 + t) : n + t - n * t, a = 2 * n - r;
      this.r = hf(a, r, e + 1 / 3), this.g = hf(a, r, e), this.b = hf(a, r, e - 1 / 3);
    }
    return gt.toWorkingColorSpace(this, s), this;
  }
  setStyle(e, t = ft) {
    function n(r) {
      r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let s;
    if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let r;
      const a = s[1], o = s[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return n(r[4]), this.setRGB(
              Math.min(255, parseInt(r[1], 10)) / 255,
              Math.min(255, parseInt(r[2], 10)) / 255,
              Math.min(255, parseInt(r[3], 10)) / 255,
              t
            );
          if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return n(r[4]), this.setRGB(
              Math.min(100, parseInt(r[1], 10)) / 100,
              Math.min(100, parseInt(r[2], 10)) / 100,
              Math.min(100, parseInt(r[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return n(r[4]), this.setHSL(
              parseFloat(r[1]) / 360,
              parseFloat(r[2]) / 100,
              parseFloat(r[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const r = s[1], a = r.length;
      if (a === 3)
        return this.setRGB(
          parseInt(r.charAt(0), 16) / 15,
          parseInt(r.charAt(1), 16) / 15,
          parseInt(r.charAt(2), 16) / 15,
          t
        );
      if (a === 6)
        return this.setHex(parseInt(r, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = ft) {
    const n = Ax[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Ao(e.r), this.g = Ao(e.g), this.b = Ao(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Kd(e.r), this.g = Kd(e.g), this.b = Kd(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = ft) {
    return gt.fromWorkingColorSpace(Cn.copy(this), e), Math.round(Ht(Cn.r * 255, 0, 255)) * 65536 + Math.round(Ht(Cn.g * 255, 0, 255)) * 256 + Math.round(Ht(Cn.b * 255, 0, 255));
  }
  getHexString(e = ft) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = gt.workingColorSpace) {
    gt.fromWorkingColorSpace(Cn.copy(this), t);
    const n = Cn.r, s = Cn.g, r = Cn.b, a = Math.max(n, s, r), o = Math.min(n, s, r);
    let l, c;
    const h = (o + a) / 2;
    if (o === a)
      l = 0, c = 0;
    else {
      const u = a - o;
      switch (c = h <= 0.5 ? u / (a + o) : u / (2 - a - o), a) {
        case n:
          l = (s - r) / u + (s < r ? 6 : 0);
          break;
        case s:
          l = (r - n) / u + 2;
          break;
        case r:
          l = (n - s) / u + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = c, e.l = h, e;
  }
  getRGB(e, t = gt.workingColorSpace) {
    return gt.fromWorkingColorSpace(Cn.copy(this), t), e.r = Cn.r, e.g = Cn.g, e.b = Cn.b, e;
  }
  getStyle(e = ft) {
    gt.fromWorkingColorSpace(Cn.copy(this), e);
    const t = Cn.r, n = Cn.g, s = Cn.b;
    return e !== ft ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(tr), this.setHSL(tr.h + e, tr.s + t, tr.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(tr), e.getHSL(fh);
    const n = kl(tr.h, fh.h, t), s = kl(tr.s, fh.s, t), r = kl(tr.l, fh.l, t);
    return this.setHSL(n, s, r), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, n = this.g, s = this.b, r = e.elements;
    return this.r = r[0] * t + r[3] * n + r[6] * s, this.g = r[1] * t + r[4] * n + r[7] * s, this.b = r[2] * t + r[5] * n + r[8] * s, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
const Cn = /* @__PURE__ */ new Q();
Q.NAMES = Ax;
let VS = 0;
class Qt extends bs {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: VS++ }), this.uuid = xi(), this.name = "", this.type = "Material", this.blending = Gi, this.side = Wi, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Sr, this.blendDst = wr, this.blendEquation = mi, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Q(0, 0, 0), this.blendAlpha = 0, this.depthFunc = nc, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Op, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = la, this.stencilZFail = la, this.stencilZPass = la, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const s = this[t];
        if (s === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        s && s.isColor ? s.set(n) : s && s.isVector3 && n && n.isVector3 ? s.copy(n) : this[t] = n;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Gi && (n.blending = this.blending), this.side !== Wi && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== Sr && (n.blendSrc = this.blendSrc), this.blendDst !== wr && (n.blendDst = this.blendDst), this.blendEquation !== mi && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== nc && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Op && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== la && (n.stencilFail = this.stencilFail), this.stencilZFail !== la && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== la && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function s(r) {
      const a = [];
      for (const o in r) {
        const l = r[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (t) {
      const r = s(e.textures), a = s(e.images);
      r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const s = t.length;
      n = new Array(s);
      for (let r = 0; r !== s; ++r)
        n[r] = t[r].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class on extends Qt {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Q(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Oc, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Us = /* @__PURE__ */ WS();
function WS() {
  const i = new ArrayBuffer(4), e = new Float32Array(i), t = new Uint32Array(i), n = new Uint32Array(512), s = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27 ? (n[l] = 0, n[l | 256] = 32768, s[l] = 24, s[l | 256] = 24) : c < -14 ? (n[l] = 1024 >> -c - 14, n[l | 256] = 1024 >> -c - 14 | 32768, s[l] = -c - 1, s[l | 256] = -c - 1) : c <= 15 ? (n[l] = c + 15 << 10, n[l | 256] = c + 15 << 10 | 32768, s[l] = 13, s[l | 256] = 13) : c < 128 ? (n[l] = 31744, n[l | 256] = 64512, s[l] = 24, s[l | 256] = 24) : (n[l] = 31744, n[l | 256] = 64512, s[l] = 13, s[l | 256] = 13);
  }
  const r = new Uint32Array(2048), a = new Uint32Array(64), o = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13, h = 0;
    for (; !(c & 8388608); )
      c <<= 1, h -= 8388608;
    c &= -8388609, h += 947912704, r[l] = c | h;
  }
  for (let l = 1024; l < 2048; ++l)
    r[l] = 939524096 + (l - 1024 << 13);
  for (let l = 1; l < 31; ++l)
    a[l] = l << 23;
  a[31] = 1199570944, a[32] = 2147483648;
  for (let l = 33; l < 63; ++l)
    a[l] = 2147483648 + (l - 32 << 23);
  a[63] = 3347054592;
  for (let l = 1; l < 64; ++l)
    l !== 32 && (o[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: s,
    mantissaTable: r,
    exponentTable: a,
    offsetTable: o
  };
}
function qn(i) {
  Math.abs(i) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), i = Ht(i, -65504, 65504), Us.floatView[0] = i;
  const e = Us.uint32View[0], t = e >> 23 & 511;
  return Us.baseTable[t] + ((e & 8388607) >> Us.shiftTable[t]);
}
function Rl(i) {
  const e = i >> 10;
  return Us.uint32View[0] = Us.mantissaTable[Us.offsetTable[e] + (i & 1023)] + Us.exponentTable[e], Us.floatView[0];
}
const XS = {
  toHalfFloat: qn,
  fromHalfFloat: Rl
}, sn = /* @__PURE__ */ new T(), ph = /* @__PURE__ */ new k();
class dt {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = cc, this.updateRange = { offset: 0, count: -1 }, this.gpuType = hs, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let s = 0, r = this.itemSize; s < r; s++)
      this.array[e + s] = t.array[n + s];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        ph.fromBufferAttribute(this, t), ph.applyMatrix3(e), this.setXY(t, ph.x, ph.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        sn.fromBufferAttribute(this, t), sn.applyMatrix3(e), this.setXYZ(t, sn.x, sn.y, sn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      sn.fromBufferAttribute(this, t), sn.applyMatrix4(e), this.setXYZ(t, sn.x, sn.y, sn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      sn.fromBufferAttribute(this, t), sn.applyNormalMatrix(e), this.setXYZ(t, sn.x, sn.y, sn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      sn.fromBufferAttribute(this, t), sn.transformDirection(e), this.setXYZ(t, sn.x, sn.y, sn.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = $n(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = Je(n, this.array)), this.array[e * this.itemSize + t] = n, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = $n(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = Je(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = $n(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = Je(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = $n(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = Je(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = $n(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = Je(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = Je(t, this.array), n = Je(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, s) {
    return e *= this.itemSize, this.normalized && (t = Je(t, this.array), n = Je(n, this.array), s = Je(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = s, this;
  }
  setXYZW(e, t, n, s, r) {
    return e *= this.itemSize, this.normalized && (t = Je(t, this.array), n = Je(n, this.array), s = Je(s, this.array), r = Je(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = s, this.array[e + 3] = r, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== cc && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
}
class qS extends dt {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class YS extends dt {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class jS extends dt {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class ZS extends dt {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class vd extends dt {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class $S extends dt {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class qm extends dt {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class KS extends dt {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = Rl(this.array[e * this.itemSize]);
    return this.normalized && (t = $n(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = Je(t, this.array)), this.array[e * this.itemSize] = qn(t), this;
  }
  getY(e) {
    let t = Rl(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = $n(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = Je(t, this.array)), this.array[e * this.itemSize + 1] = qn(t), this;
  }
  getZ(e) {
    let t = Rl(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = $n(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = Je(t, this.array)), this.array[e * this.itemSize + 2] = qn(t), this;
  }
  getW(e) {
    let t = Rl(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = $n(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = Je(t, this.array)), this.array[e * this.itemSize + 3] = qn(t), this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = Je(t, this.array), n = Je(n, this.array)), this.array[e + 0] = qn(t), this.array[e + 1] = qn(n), this;
  }
  setXYZ(e, t, n, s) {
    return e *= this.itemSize, this.normalized && (t = Je(t, this.array), n = Je(n, this.array), s = Je(s, this.array)), this.array[e + 0] = qn(t), this.array[e + 1] = qn(n), this.array[e + 2] = qn(s), this;
  }
  setXYZW(e, t, n, s, r) {
    return e *= this.itemSize, this.normalized && (t = Je(t, this.array), n = Je(n, this.array), s = Je(s, this.array), r = Je(r, this.array)), this.array[e + 0] = qn(t), this.array[e + 1] = qn(n), this.array[e + 2] = qn(s), this.array[e + 3] = qn(r), this;
  }
}
class ye extends dt {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
class QS extends dt {
  constructor(e, t, n) {
    super(new Float64Array(e), t, n);
  }
}
let JS = 0;
const Ei = /* @__PURE__ */ new _e(), uf = /* @__PURE__ */ new Ze(), $a = /* @__PURE__ */ new T(), di = /* @__PURE__ */ new ln(), ml = /* @__PURE__ */ new ln(), fn = /* @__PURE__ */ new T();
class Be extends bs {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: JS++ }), this.uuid = xi(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (wx(e) ? qm : vd)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const r = new Qe().getNormalMatrix(e);
      n.applyNormalMatrix(r), n.needsUpdate = !0;
    }
    const s = this.attributes.tangent;
    return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Ei.makeRotationFromQuaternion(e), this.applyMatrix4(Ei), this;
  }
  rotateX(e) {
    return Ei.makeRotationX(e), this.applyMatrix4(Ei), this;
  }
  rotateY(e) {
    return Ei.makeRotationY(e), this.applyMatrix4(Ei), this;
  }
  rotateZ(e) {
    return Ei.makeRotationZ(e), this.applyMatrix4(Ei), this;
  }
  translate(e, t, n) {
    return Ei.makeTranslation(e, t, n), this.applyMatrix4(Ei), this;
  }
  scale(e, t, n) {
    return Ei.makeScale(e, t, n), this.applyMatrix4(Ei), this;
  }
  lookAt(e) {
    return uf.lookAt(e), uf.updateMatrix(), this.applyMatrix4(uf.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter($a).negate(), this.translate($a.x, $a.y, $a.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, s = e.length; n < s; n++) {
      const r = e[n];
      t.push(r.x, r.y, r.z || 0);
    }
    return this.setAttribute("position", new ye(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new ln());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new T(-1 / 0, -1 / 0, -1 / 0),
        new T(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let n = 0, s = t.length; n < s; n++) {
          const r = t[n];
          di.setFromBufferAttribute(r), this.morphTargetsRelative ? (fn.addVectors(this.boundingBox.min, di.min), this.boundingBox.expandByPoint(fn), fn.addVectors(this.boundingBox.max, di.max), this.boundingBox.expandByPoint(fn)) : (this.boundingBox.expandByPoint(di.min), this.boundingBox.expandByPoint(di.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new oi());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new T(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (di.setFromBufferAttribute(e), t)
        for (let r = 0, a = t.length; r < a; r++) {
          const o = t[r];
          ml.setFromBufferAttribute(o), this.morphTargetsRelative ? (fn.addVectors(di.min, ml.min), di.expandByPoint(fn), fn.addVectors(di.max, ml.max), di.expandByPoint(fn)) : (di.expandByPoint(ml.min), di.expandByPoint(ml.max));
        }
      di.getCenter(n);
      let s = 0;
      for (let r = 0, a = e.count; r < a; r++)
        fn.fromBufferAttribute(e, r), s = Math.max(s, n.distanceToSquared(fn));
      if (t)
        for (let r = 0, a = t.length; r < a; r++) {
          const o = t[r], l = this.morphTargetsRelative;
          for (let c = 0, h = o.count; c < h; c++)
            fn.fromBufferAttribute(o, c), l && ($a.fromBufferAttribute(e, c), fn.add($a)), s = Math.max(s, n.distanceToSquared(fn));
        }
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = e.array, s = t.position.array, r = t.normal.array, a = t.uv.array, o = s.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new dt(new Float32Array(4 * o), 4));
    const l = this.getAttribute("tangent").array, c = [], h = [];
    for (let A = 0; A < o; A++)
      c[A] = new T(), h[A] = new T();
    const u = new T(), d = new T(), f = new T(), m = new k(), g = new k(), p = new k(), v = new T(), y = new T();
    function _(A, D, B) {
      u.fromArray(s, A * 3), d.fromArray(s, D * 3), f.fromArray(s, B * 3), m.fromArray(a, A * 2), g.fromArray(a, D * 2), p.fromArray(a, B * 2), d.sub(u), f.sub(u), g.sub(m), p.sub(m);
      const X = 1 / (g.x * p.y - p.x * g.y);
      isFinite(X) && (v.copy(d).multiplyScalar(p.y).addScaledVector(f, -g.y).multiplyScalar(X), y.copy(f).multiplyScalar(g.x).addScaledVector(d, -p.x).multiplyScalar(X), c[A].add(v), c[D].add(v), c[B].add(v), h[A].add(y), h[D].add(y), h[B].add(y));
    }
    let x = this.groups;
    x.length === 0 && (x = [{
      start: 0,
      count: n.length
    }]);
    for (let A = 0, D = x.length; A < D; ++A) {
      const B = x[A], X = B.start, L = B.count;
      for (let F = X, H = X + L; F < H; F += 3)
        _(
          n[F + 0],
          n[F + 1],
          n[F + 2]
        );
    }
    const M = new T(), S = new T(), w = new T(), E = new T();
    function b(A) {
      w.fromArray(r, A * 3), E.copy(w);
      const D = c[A];
      M.copy(D), M.sub(w.multiplyScalar(w.dot(D))).normalize(), S.crossVectors(E, D);
      const X = S.dot(h[A]) < 0 ? -1 : 1;
      l[A * 4] = M.x, l[A * 4 + 1] = M.y, l[A * 4 + 2] = M.z, l[A * 4 + 3] = X;
    }
    for (let A = 0, D = x.length; A < D; ++A) {
      const B = x[A], X = B.start, L = B.count;
      for (let F = X, H = X + L; F < H; F += 3)
        b(n[F + 0]), b(n[F + 1]), b(n[F + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new dt(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let d = 0, f = n.count; d < f; d++)
          n.setXYZ(d, 0, 0, 0);
      const s = new T(), r = new T(), a = new T(), o = new T(), l = new T(), c = new T(), h = new T(), u = new T();
      if (e)
        for (let d = 0, f = e.count; d < f; d += 3) {
          const m = e.getX(d + 0), g = e.getX(d + 1), p = e.getX(d + 2);
          s.fromBufferAttribute(t, m), r.fromBufferAttribute(t, g), a.fromBufferAttribute(t, p), h.subVectors(a, r), u.subVectors(s, r), h.cross(u), o.fromBufferAttribute(n, m), l.fromBufferAttribute(n, g), c.fromBufferAttribute(n, p), o.add(h), l.add(h), c.add(h), n.setXYZ(m, o.x, o.y, o.z), n.setXYZ(g, l.x, l.y, l.z), n.setXYZ(p, c.x, c.y, c.z);
        }
      else
        for (let d = 0, f = t.count; d < f; d += 3)
          s.fromBufferAttribute(t, d + 0), r.fromBufferAttribute(t, d + 1), a.fromBufferAttribute(t, d + 2), h.subVectors(a, r), u.subVectors(s, r), h.cross(u), n.setXYZ(d + 0, h.x, h.y, h.z), n.setXYZ(d + 1, h.x, h.y, h.z), n.setXYZ(d + 2, h.x, h.y, h.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      fn.fromBufferAttribute(e, t), fn.normalize(), e.setXYZ(t, fn.x, fn.y, fn.z);
  }
  toNonIndexed() {
    function e(o, l) {
      const c = o.array, h = o.itemSize, u = o.normalized, d = new c.constructor(l.length * h);
      let f = 0, m = 0;
      for (let g = 0, p = l.length; g < p; g++) {
        o.isInterleavedBufferAttribute ? f = l[g] * o.data.stride + o.offset : f = l[g] * h;
        for (let v = 0; v < h; v++)
          d[m++] = c[f++];
      }
      return new dt(d, h, u);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Be(), n = this.index.array, s = this.attributes;
    for (const o in s) {
      const l = s[o], c = e(l, n);
      t.setAttribute(o, c);
    }
    const r = this.morphAttributes;
    for (const o in r) {
      const l = [], c = r[o];
      for (let h = 0, u = c.length; h < u; h++) {
        const d = c[h], f = e(d, n);
        l.push(f);
      }
      t.morphAttributes[o] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, l = a.length; o < l; o++) {
      const c = a[o];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const c in l)
        l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const n = this.attributes;
    for (const l in n) {
      const c = n[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const s = {};
    let r = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l], h = [];
      for (let u = 0, d = c.length; u < d; u++) {
        const f = c[u];
        h.push(f.toJSON(e.data));
      }
      h.length > 0 && (s[l] = h, r = !0);
    }
    r && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return o !== null && (e.data.boundingSphere = {
      center: o.center.toArray(),
      radius: o.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const s = e.attributes;
    for (const c in s) {
      const h = s[c];
      this.setAttribute(c, h.clone(t));
    }
    const r = e.morphAttributes;
    for (const c in r) {
      const h = [], u = r[c];
      for (let d = 0, f = u.length; d < f; d++)
        h.push(u[d].clone(t));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let c = 0, h = a.length; c < h; c++) {
      const u = a[c];
      this.addGroup(u.start, u.count, u.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const P0 = /* @__PURE__ */ new _e(), Zr = /* @__PURE__ */ new Oa(), mh = /* @__PURE__ */ new oi(), L0 = /* @__PURE__ */ new T(), Ka = /* @__PURE__ */ new T(), Qa = /* @__PURE__ */ new T(), Ja = /* @__PURE__ */ new T(), df = /* @__PURE__ */ new T(), gh = /* @__PURE__ */ new T(), vh = /* @__PURE__ */ new k(), _h = /* @__PURE__ */ new k(), yh = /* @__PURE__ */ new k(), I0 = /* @__PURE__ */ new T(), D0 = /* @__PURE__ */ new T(), O0 = /* @__PURE__ */ new T(), xh = /* @__PURE__ */ new T(), Mh = /* @__PURE__ */ new T();
class le extends Ze {
  constructor(e = new Be(), t = new on()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const s = t[n[0]];
      if (s !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = s.length; r < a; r++) {
          const o = s[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry, s = n.attributes.position, r = n.morphAttributes.position, a = n.morphTargetsRelative;
    t.fromBufferAttribute(s, e);
    const o = this.morphTargetInfluences;
    if (r && o) {
      gh.set(0, 0, 0);
      for (let l = 0, c = r.length; l < c; l++) {
        const h = o[l], u = r[l];
        h !== 0 && (df.fromBufferAttribute(u, e), a ? gh.addScaledVector(df, h) : gh.addScaledVector(df.sub(t), h));
      }
      t.add(gh);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry, s = this.material, r = this.matrixWorld;
    s !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), mh.copy(n.boundingSphere), mh.applyMatrix4(r), Zr.copy(e.ray).recast(e.near), !(mh.containsPoint(Zr.origin) === !1 && (Zr.intersectSphere(mh, L0) === null || Zr.origin.distanceToSquared(L0) > (e.far - e.near) ** 2)) && (P0.copy(r).invert(), Zr.copy(e.ray).applyMatrix4(P0), !(n.boundingBox !== null && Zr.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, Zr)));
  }
  _computeIntersections(e, t, n) {
    let s;
    const r = this.geometry, a = this.material, o = r.index, l = r.attributes.position, c = r.attributes.uv, h = r.attributes.uv1, u = r.attributes.normal, d = r.groups, f = r.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let m = 0, g = d.length; m < g; m++) {
          const p = d[m], v = a[p.materialIndex], y = Math.max(p.start, f.start), _ = Math.min(o.count, Math.min(p.start + p.count, f.start + f.count));
          for (let x = y, M = _; x < M; x += 3) {
            const S = o.getX(x), w = o.getX(x + 1), E = o.getX(x + 2);
            s = bh(this, v, e, n, c, h, u, S, w, E), s && (s.faceIndex = Math.floor(x / 3), s.face.materialIndex = p.materialIndex, t.push(s));
          }
        }
      else {
        const m = Math.max(0, f.start), g = Math.min(o.count, f.start + f.count);
        for (let p = m, v = g; p < v; p += 3) {
          const y = o.getX(p), _ = o.getX(p + 1), x = o.getX(p + 2);
          s = bh(this, a, e, n, c, h, u, y, _, x), s && (s.faceIndex = Math.floor(p / 3), t.push(s));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let m = 0, g = d.length; m < g; m++) {
          const p = d[m], v = a[p.materialIndex], y = Math.max(p.start, f.start), _ = Math.min(l.count, Math.min(p.start + p.count, f.start + f.count));
          for (let x = y, M = _; x < M; x += 3) {
            const S = x, w = x + 1, E = x + 2;
            s = bh(this, v, e, n, c, h, u, S, w, E), s && (s.faceIndex = Math.floor(x / 3), s.face.materialIndex = p.materialIndex, t.push(s));
          }
        }
      else {
        const m = Math.max(0, f.start), g = Math.min(l.count, f.start + f.count);
        for (let p = m, v = g; p < v; p += 3) {
          const y = p, _ = p + 1, x = p + 2;
          s = bh(this, a, e, n, c, h, u, y, _, x), s && (s.faceIndex = Math.floor(p / 3), t.push(s));
        }
      }
  }
}
function ew(i, e, t, n, s, r, a, o) {
  let l;
  if (e.side === Wn ? l = n.intersectTriangle(a, r, s, !0, o) : l = n.intersectTriangle(s, r, a, e.side === Wi, o), l === null) return null;
  Mh.copy(o), Mh.applyMatrix4(i.matrixWorld);
  const c = t.ray.origin.distanceTo(Mh);
  return c < t.near || c > t.far ? null : {
    distance: c,
    point: Mh.clone(),
    object: i
  };
}
function bh(i, e, t, n, s, r, a, o, l, c) {
  i.getVertexPosition(o, Ka), i.getVertexPosition(l, Qa), i.getVertexPosition(c, Ja);
  const h = ew(i, e, t, n, Ka, Qa, Ja, xh);
  if (h) {
    s && (vh.fromBufferAttribute(s, o), _h.fromBufferAttribute(s, l), yh.fromBufferAttribute(s, c), h.uv = Zn.getInterpolation(xh, Ka, Qa, Ja, vh, _h, yh, new k())), r && (vh.fromBufferAttribute(r, o), _h.fromBufferAttribute(r, l), yh.fromBufferAttribute(r, c), h.uv1 = Zn.getInterpolation(xh, Ka, Qa, Ja, vh, _h, yh, new k()), h.uv2 = h.uv1), a && (I0.fromBufferAttribute(a, o), D0.fromBufferAttribute(a, l), O0.fromBufferAttribute(a, c), h.normal = Zn.getInterpolation(xh, Ka, Qa, Ja, I0, D0, O0, new T()), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const u = {
      a: o,
      b: l,
      c,
      normal: new T(),
      materialIndex: 0
    };
    Zn.getNormal(Ka, Qa, Ja, u.normal), h.face = u;
  }
  return h;
}
class Pt extends Be {
  constructor(e = 1, t = 1, n = 1, s = 1, r = 1, a = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: n,
      widthSegments: s,
      heightSegments: r,
      depthSegments: a
    };
    const o = this;
    s = Math.floor(s), r = Math.floor(r), a = Math.floor(a);
    const l = [], c = [], h = [], u = [];
    let d = 0, f = 0;
    m("z", "y", "x", -1, -1, n, t, e, a, r, 0), m("z", "y", "x", 1, -1, n, t, -e, a, r, 1), m("x", "z", "y", 1, 1, e, n, t, s, a, 2), m("x", "z", "y", 1, -1, e, n, -t, s, a, 3), m("x", "y", "z", 1, -1, e, t, n, s, r, 4), m("x", "y", "z", -1, -1, e, t, -n, s, r, 5), this.setIndex(l), this.setAttribute("position", new ye(c, 3)), this.setAttribute("normal", new ye(h, 3)), this.setAttribute("uv", new ye(u, 2));
    function m(g, p, v, y, _, x, M, S, w, E, b) {
      const A = x / w, D = M / E, B = x / 2, X = M / 2, L = S / 2, F = w + 1, H = E + 1;
      let G = 0, te = 0;
      const j = new T();
      for (let J = 0; J < H; J++) {
        const N = J * D - X;
        for (let q = 0; q < F; q++) {
          const ge = q * A - B;
          j[g] = ge * y, j[p] = N * _, j[v] = L, c.push(j.x, j.y, j.z), j[g] = 0, j[p] = 0, j[v] = S > 0 ? 1 : -1, h.push(j.x, j.y, j.z), u.push(q / w), u.push(1 - J / E), G += 1;
        }
      }
      for (let J = 0; J < E; J++)
        for (let N = 0; N < w; N++) {
          const q = d + N + F * J, ge = d + N + F * (J + 1), de = d + (N + 1) + F * (J + 1), be = d + (N + 1) + F * J;
          l.push(q, ge, be), l.push(ge, de, be), te += 6;
        }
      o.addGroup(f, te, b), f += te, d += G;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Pt(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Go(i) {
  const e = {};
  for (const t in i) {
    e[t] = {};
    for (const n in i[t]) {
      const s = i[t][n];
      s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = s.clone() : Array.isArray(s) ? e[t][n] = s.slice() : e[t][n] = s;
    }
  }
  return e;
}
function Fn(i) {
  const e = {};
  for (let t = 0; t < i.length; t++) {
    const n = Go(i[t]);
    for (const s in n)
      e[s] = n[s];
  }
  return e;
}
function tw(i) {
  const e = [];
  for (let t = 0; t < i.length; t++)
    e.push(i[t].clone());
  return e;
}
function Cx(i) {
  return i.getRenderTarget() === null ? i.outputColorSpace : gt.workingColorSpace;
}
const cn = { clone: Go, merge: Fn };
var nw = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, iw = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class mt extends Qt {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = nw, this.fragmentShader = iw, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1
      // set to use shader texture LOD
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Go(e.uniforms), this.uniformsGroups = tw(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const s in this.uniforms) {
      const a = this.uniforms[s].value;
      a && a.isTexture ? t.uniforms[s] = {
        type: "t",
        value: a.toJSON(e).uuid
      } : a && a.isColor ? t.uniforms[s] = {
        type: "c",
        value: a.getHex()
      } : a && a.isVector2 ? t.uniforms[s] = {
        type: "v2",
        value: a.toArray()
      } : a && a.isVector3 ? t.uniforms[s] = {
        type: "v3",
        value: a.toArray()
      } : a && a.isVector4 ? t.uniforms[s] = {
        type: "v4",
        value: a.toArray()
      } : a && a.isMatrix3 ? t.uniforms[s] = {
        type: "m3",
        value: a.toArray()
      } : a && a.isMatrix4 ? t.uniforms[s] = {
        type: "m4",
        value: a.toArray()
      } : t.uniforms[s] = {
        value: a
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const n = {};
    for (const s in this.extensions)
      this.extensions[s] === !0 && (n[s] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class _d extends Ze {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new _e(), this.projectionMatrix = new _e(), this.projectionMatrixInverse = new _e(), this.coordinateSystem = us;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Zt extends _d {
  constructor(e = 50, t = 1, n = 0.1, s = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = s, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = Ho * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(_a * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return Ho * 2 * Math.atan(
      Math.tan(_a * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, n, s, r, a) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = s, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(_a * 0.5 * this.fov) / this.zoom, n = 2 * t, s = this.aspect * n, r = -0.5 * s;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth, c = a.fullHeight;
      r += a.offsetX * s / l, t -= a.offsetY * n / c, s *= a.width / l, n *= a.height / c;
    }
    const o = this.filmOffset;
    o !== 0 && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + s, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const eo = -90, to = 1;
class Rx extends Ze {
  constructor(e, t, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const s = new Zt(eo, to, e, t);
    s.layers = this.layers, this.add(s);
    const r = new Zt(eo, to, e, t);
    r.layers = this.layers, this.add(r);
    const a = new Zt(eo, to, e, t);
    a.layers = this.layers, this.add(a);
    const o = new Zt(eo, to, e, t);
    o.layers = this.layers, this.add(o);
    const l = new Zt(eo, to, e, t);
    l.layers = this.layers, this.add(l);
    const c = new Zt(eo, to, e, t);
    c.layers = this.layers, this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [n, s, r, a, o, l] = t;
    for (const c of t) this.remove(c);
    if (e === us)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (e === hc)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const c of t)
      this.add(c), c.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: s } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [r, a, o, l, c, h] = this.children, u = e.getRenderTarget(), d = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), m = e.xr.enabled;
    e.xr.enabled = !1;
    const g = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, s), e.render(t, r), e.setRenderTarget(n, 1, s), e.render(t, a), e.setRenderTarget(n, 2, s), e.render(t, o), e.setRenderTarget(n, 3, s), e.render(t, l), e.setRenderTarget(n, 4, s), e.render(t, c), n.texture.generateMipmaps = g, e.setRenderTarget(n, 5, s), e.render(t, h), e.setRenderTarget(u, d, f), e.xr.enabled = m, n.texture.needsPMREMUpdate = !0;
  }
}
class Fc extends At {
  constructor(e, t, n, s, r, a, o, l, c, h) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : Gs, super(e, t, n, s, r, a, o, l, c, h), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Px extends xt {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, s = [n, n, n, n, n, n];
    t.encoding !== void 0 && (zl("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === vr ? ft : vi), this.texture = new Fc(s, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Nt;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, s = new Pt(5, 5, 5), r = new mt({
      name: "CubemapFromEquirect",
      uniforms: Go(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: Wn,
      blending: vt
    });
    r.uniforms.tEquirect.value = t;
    const a = new le(s, r), o = t.minFilter;
    return t.minFilter === ys && (t.minFilter = Nt), new Rx(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(e, t, n, s) {
    const r = e.getRenderTarget();
    for (let a = 0; a < 6; a++)
      e.setRenderTarget(this, a), e.clear(t, n, s);
    e.setRenderTarget(r);
  }
}
const ff = /* @__PURE__ */ new T(), sw = /* @__PURE__ */ new T(), rw = /* @__PURE__ */ new Qe();
class as {
  constructor(e = new T(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, n, s) {
    return this.normal.set(e, t, n), this.constant = s, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const s = ff.subVectors(n, t).cross(sw.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(s, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(ff), s = this.normal.dot(n);
    if (s === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / s;
    return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || rw.getNormalMatrix(e), s = this.coplanarPoint(ff).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize();
    return this.constant = -s.dot(r), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const $r = /* @__PURE__ */ new oi(), Sh = /* @__PURE__ */ new T();
class yd {
  constructor(e = new as(), t = new as(), n = new as(), s = new as(), r = new as(), a = new as()) {
    this.planes = [e, t, n, s, r, a];
  }
  set(e, t, n, s, r, a) {
    const o = this.planes;
    return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(s), o[4].copy(r), o[5].copy(a), this;
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = us) {
    const n = this.planes, s = e.elements, r = s[0], a = s[1], o = s[2], l = s[3], c = s[4], h = s[5], u = s[6], d = s[7], f = s[8], m = s[9], g = s[10], p = s[11], v = s[12], y = s[13], _ = s[14], x = s[15];
    if (n[0].setComponents(l - r, d - c, p - f, x - v).normalize(), n[1].setComponents(l + r, d + c, p + f, x + v).normalize(), n[2].setComponents(l + a, d + h, p + m, x + y).normalize(), n[3].setComponents(l - a, d - h, p - m, x - y).normalize(), n[4].setComponents(l - o, d - u, p - g, x - _).normalize(), t === us)
      n[5].setComponents(l + o, d + u, p + g, x + _).normalize();
    else if (t === hc)
      n[5].setComponents(o, u, g, _).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), $r.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), $r.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere($r);
  }
  intersectsSprite(e) {
    return $r.center.set(0, 0, 0), $r.radius = 0.7071067811865476, $r.applyMatrix4(e.matrixWorld), this.intersectsSphere($r);
  }
  intersectsSphere(e) {
    const t = this.planes, n = e.center, s = -e.radius;
    for (let r = 0; r < 6; r++)
      if (t[r].distanceToPoint(n) < s)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const s = t[n];
      if (Sh.x = s.normal.x > 0 ? e.max.x : e.min.x, Sh.y = s.normal.y > 0 ? e.max.y : e.min.y, Sh.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(Sh) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      if (t[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Lx() {
  let i = null, e = !1, t = null, n = null;
  function s(r, a) {
    t(r, a), n = i.requestAnimationFrame(s);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (n = i.requestAnimationFrame(s), e = !0);
    },
    stop: function() {
      i.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(r) {
      t = r;
    },
    setContext: function(r) {
      i = r;
    }
  };
}
function aw(i, e) {
  const t = e.isWebGL2, n = /* @__PURE__ */ new WeakMap();
  function s(c, h) {
    const u = c.array, d = c.usage, f = i.createBuffer();
    i.bindBuffer(h, f), i.bufferData(h, u, d), c.onUploadCallback();
    let m;
    if (u instanceof Float32Array)
      m = i.FLOAT;
    else if (u instanceof Uint16Array)
      if (c.isFloat16BufferAttribute)
        if (t)
          m = i.HALF_FLOAT;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        m = i.UNSIGNED_SHORT;
    else if (u instanceof Int16Array)
      m = i.SHORT;
    else if (u instanceof Uint32Array)
      m = i.UNSIGNED_INT;
    else if (u instanceof Int32Array)
      m = i.INT;
    else if (u instanceof Int8Array)
      m = i.BYTE;
    else if (u instanceof Uint8Array)
      m = i.UNSIGNED_BYTE;
    else if (u instanceof Uint8ClampedArray)
      m = i.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u);
    return {
      buffer: f,
      type: m,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: c.version
    };
  }
  function r(c, h, u) {
    const d = h.array, f = h.updateRange;
    i.bindBuffer(u, c), f.count === -1 ? i.bufferSubData(u, 0, d) : (t ? i.bufferSubData(
      u,
      f.offset * d.BYTES_PER_ELEMENT,
      d,
      f.offset,
      f.count
    ) : i.bufferSubData(
      u,
      f.offset * d.BYTES_PER_ELEMENT,
      d.subarray(f.offset, f.offset + f.count)
    ), f.count = -1), h.onUploadCallback();
  }
  function a(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), n.get(c);
  }
  function o(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const h = n.get(c);
    h && (i.deleteBuffer(h.buffer), n.delete(c));
  }
  function l(c, h) {
    if (c.isGLBufferAttribute) {
      const d = n.get(c);
      (!d || d.version < c.version) && n.set(c, {
        buffer: c.buffer,
        type: c.type,
        bytesPerElement: c.elementSize,
        version: c.version
      });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const u = n.get(c);
    u === void 0 ? n.set(c, s(c, h)) : u.version < c.version && (r(u.buffer, c, h), u.version = c.version);
  }
  return {
    get: a,
    remove: o,
    update: l
  };
}
class Fr extends Be {
  constructor(e = 1, t = 1, n = 1, s = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: n,
      heightSegments: s
    };
    const r = e / 2, a = t / 2, o = Math.floor(n), l = Math.floor(s), c = o + 1, h = l + 1, u = e / o, d = t / l, f = [], m = [], g = [], p = [];
    for (let v = 0; v < h; v++) {
      const y = v * d - a;
      for (let _ = 0; _ < c; _++) {
        const x = _ * u - r;
        m.push(x, -y, 0), g.push(0, 0, 1), p.push(_ / o), p.push(1 - v / l);
      }
    }
    for (let v = 0; v < l; v++)
      for (let y = 0; y < o; y++) {
        const _ = y + c * v, x = y + c * (v + 1), M = y + 1 + c * (v + 1), S = y + 1 + c * v;
        f.push(_, x, S), f.push(x, M, S);
      }
    this.setIndex(f), this.setAttribute("position", new ye(m, 3)), this.setAttribute("normal", new ye(g, 3)), this.setAttribute("uv", new ye(p, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Fr(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var ow = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, lw = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, cw = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, hw = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, uw = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, dw = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, fw = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, pw = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, mw = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, gw = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, vw = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, _w = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, yw = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, xw = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, Mw = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, bw = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Sw = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, ww = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, Tw = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, Ew = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, Aw = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, Cw = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, Rw = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, Pw = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Lw = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, Iw = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, Dw = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, Ow = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, Nw = "gl_FragColor = linearToOutputTexel( gl_FragColor );", Uw = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, Fw = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Bw = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, kw = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, zw = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, Hw = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, Gw = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, Vw = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, Ww = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, Xw = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, qw = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, Yw = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, jw = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Zw = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, $w = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, Kw = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Qw = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, Jw = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, eT = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, tT = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, nT = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, iT = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`, sT = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, rT = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, aT = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, oT = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, lT = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, cT = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, hT = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, uT = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, dT = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, fT = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, pT = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, mT = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, gT = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, vT = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, _T = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, yT = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, xT = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, MT = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, bT = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, ST = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, wT = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, TT = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, ET = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, AT = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, CT = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, RT = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, PT = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, LT = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, IT = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, DT = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, OT = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, NT = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, UT = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, FT = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, BT = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, kT = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, zT = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, HT = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, GT = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, VT = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, WT = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, XT = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, qT = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, YT = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, jT = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, ZT = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, $T = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, KT = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, QT = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, JT = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, eE = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, tE = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, nE = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, iE = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const sE = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, rE = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, aE = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, oE = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, lE = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, cE = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, hE = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, uE = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, dE = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, fE = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, pE = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, mE = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, gE = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, vE = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, _E = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, yE = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, xE = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, ME = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, bE = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, SE = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, wE = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, TE = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, EE = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, AE = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, CE = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, RE = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, PE = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, LE = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, IE = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, DE = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, OE = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, NE = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, UE = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, FE = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Ke = {
  alphahash_fragment: ow,
  alphahash_pars_fragment: lw,
  alphamap_fragment: cw,
  alphamap_pars_fragment: hw,
  alphatest_fragment: uw,
  alphatest_pars_fragment: dw,
  aomap_fragment: fw,
  aomap_pars_fragment: pw,
  begin_vertex: mw,
  beginnormal_vertex: gw,
  bsdfs: vw,
  iridescence_fragment: _w,
  bumpmap_pars_fragment: yw,
  clipping_planes_fragment: xw,
  clipping_planes_pars_fragment: Mw,
  clipping_planes_pars_vertex: bw,
  clipping_planes_vertex: Sw,
  color_fragment: ww,
  color_pars_fragment: Tw,
  color_pars_vertex: Ew,
  color_vertex: Aw,
  common: Cw,
  cube_uv_reflection_fragment: Rw,
  defaultnormal_vertex: Pw,
  displacementmap_pars_vertex: Lw,
  displacementmap_vertex: Iw,
  emissivemap_fragment: Dw,
  emissivemap_pars_fragment: Ow,
  colorspace_fragment: Nw,
  colorspace_pars_fragment: Uw,
  envmap_fragment: Fw,
  envmap_common_pars_fragment: Bw,
  envmap_pars_fragment: kw,
  envmap_pars_vertex: zw,
  envmap_physical_pars_fragment: Qw,
  envmap_vertex: Hw,
  fog_vertex: Gw,
  fog_pars_vertex: Vw,
  fog_fragment: Ww,
  fog_pars_fragment: Xw,
  gradientmap_pars_fragment: qw,
  lightmap_fragment: Yw,
  lightmap_pars_fragment: jw,
  lights_lambert_fragment: Zw,
  lights_lambert_pars_fragment: $w,
  lights_pars_begin: Kw,
  lights_toon_fragment: Jw,
  lights_toon_pars_fragment: eT,
  lights_phong_fragment: tT,
  lights_phong_pars_fragment: nT,
  lights_physical_fragment: iT,
  lights_physical_pars_fragment: sT,
  lights_fragment_begin: rT,
  lights_fragment_maps: aT,
  lights_fragment_end: oT,
  logdepthbuf_fragment: lT,
  logdepthbuf_pars_fragment: cT,
  logdepthbuf_pars_vertex: hT,
  logdepthbuf_vertex: uT,
  map_fragment: dT,
  map_pars_fragment: fT,
  map_particle_fragment: pT,
  map_particle_pars_fragment: mT,
  metalnessmap_fragment: gT,
  metalnessmap_pars_fragment: vT,
  morphcolor_vertex: _T,
  morphnormal_vertex: yT,
  morphtarget_pars_vertex: xT,
  morphtarget_vertex: MT,
  normal_fragment_begin: bT,
  normal_fragment_maps: ST,
  normal_pars_fragment: wT,
  normal_pars_vertex: TT,
  normal_vertex: ET,
  normalmap_pars_fragment: AT,
  clearcoat_normal_fragment_begin: CT,
  clearcoat_normal_fragment_maps: RT,
  clearcoat_pars_fragment: PT,
  iridescence_pars_fragment: LT,
  opaque_fragment: IT,
  packing: DT,
  premultiplied_alpha_fragment: OT,
  project_vertex: NT,
  dithering_fragment: UT,
  dithering_pars_fragment: FT,
  roughnessmap_fragment: BT,
  roughnessmap_pars_fragment: kT,
  shadowmap_pars_fragment: zT,
  shadowmap_pars_vertex: HT,
  shadowmap_vertex: GT,
  shadowmask_pars_fragment: VT,
  skinbase_vertex: WT,
  skinning_pars_vertex: XT,
  skinning_vertex: qT,
  skinnormal_vertex: YT,
  specularmap_fragment: jT,
  specularmap_pars_fragment: ZT,
  tonemapping_fragment: $T,
  tonemapping_pars_fragment: KT,
  transmission_fragment: QT,
  transmission_pars_fragment: JT,
  uv_pars_fragment: eE,
  uv_pars_vertex: tE,
  uv_vertex: nE,
  worldpos_vertex: iE,
  background_vert: sE,
  background_frag: rE,
  backgroundCube_vert: aE,
  backgroundCube_frag: oE,
  cube_vert: lE,
  cube_frag: cE,
  depth_vert: hE,
  depth_frag: uE,
  distanceRGBA_vert: dE,
  distanceRGBA_frag: fE,
  equirect_vert: pE,
  equirect_frag: mE,
  linedashed_vert: gE,
  linedashed_frag: vE,
  meshbasic_vert: _E,
  meshbasic_frag: yE,
  meshlambert_vert: xE,
  meshlambert_frag: ME,
  meshmatcap_vert: bE,
  meshmatcap_frag: SE,
  meshnormal_vert: wE,
  meshnormal_frag: TE,
  meshphong_vert: EE,
  meshphong_frag: AE,
  meshphysical_vert: CE,
  meshphysical_frag: RE,
  meshtoon_vert: PE,
  meshtoon_frag: LE,
  points_vert: IE,
  points_frag: DE,
  shadow_vert: OE,
  shadow_frag: NE,
  sprite_vert: UE,
  sprite_frag: FE
}, ve = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Q(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Qe() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Qe() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Qe() }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Qe() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Qe() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Qe() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Qe() },
    normalScale: { value: /* @__PURE__ */ new k(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Qe() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Qe() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Qe() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Qe() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Q(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Q(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Qe() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Qe() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Q(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new k(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Qe() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Qe() },
    alphaTest: { value: 0 }
  }
}, zn = {
  basic: {
    uniforms: /* @__PURE__ */ Fn([
      ve.common,
      ve.specularmap,
      ve.envmap,
      ve.aomap,
      ve.lightmap,
      ve.fog
    ]),
    vertexShader: Ke.meshbasic_vert,
    fragmentShader: Ke.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ Fn([
      ve.common,
      ve.specularmap,
      ve.envmap,
      ve.aomap,
      ve.lightmap,
      ve.emissivemap,
      ve.bumpmap,
      ve.normalmap,
      ve.displacementmap,
      ve.fog,
      ve.lights,
      {
        emissive: { value: /* @__PURE__ */ new Q(0) }
      }
    ]),
    vertexShader: Ke.meshlambert_vert,
    fragmentShader: Ke.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ Fn([
      ve.common,
      ve.specularmap,
      ve.envmap,
      ve.aomap,
      ve.lightmap,
      ve.emissivemap,
      ve.bumpmap,
      ve.normalmap,
      ve.displacementmap,
      ve.fog,
      ve.lights,
      {
        emissive: { value: /* @__PURE__ */ new Q(0) },
        specular: { value: /* @__PURE__ */ new Q(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Ke.meshphong_vert,
    fragmentShader: Ke.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ Fn([
      ve.common,
      ve.envmap,
      ve.aomap,
      ve.lightmap,
      ve.emissivemap,
      ve.bumpmap,
      ve.normalmap,
      ve.displacementmap,
      ve.roughnessmap,
      ve.metalnessmap,
      ve.fog,
      ve.lights,
      {
        emissive: { value: /* @__PURE__ */ new Q(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: Ke.meshphysical_vert,
    fragmentShader: Ke.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ Fn([
      ve.common,
      ve.aomap,
      ve.lightmap,
      ve.emissivemap,
      ve.bumpmap,
      ve.normalmap,
      ve.displacementmap,
      ve.gradientmap,
      ve.fog,
      ve.lights,
      {
        emissive: { value: /* @__PURE__ */ new Q(0) }
      }
    ]),
    vertexShader: Ke.meshtoon_vert,
    fragmentShader: Ke.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ Fn([
      ve.common,
      ve.bumpmap,
      ve.normalmap,
      ve.displacementmap,
      ve.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Ke.meshmatcap_vert,
    fragmentShader: Ke.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ Fn([
      ve.points,
      ve.fog
    ]),
    vertexShader: Ke.points_vert,
    fragmentShader: Ke.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ Fn([
      ve.common,
      ve.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Ke.linedashed_vert,
    fragmentShader: Ke.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ Fn([
      ve.common,
      ve.displacementmap
    ]),
    vertexShader: Ke.depth_vert,
    fragmentShader: Ke.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ Fn([
      ve.common,
      ve.bumpmap,
      ve.normalmap,
      ve.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Ke.meshnormal_vert,
    fragmentShader: Ke.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ Fn([
      ve.sprite,
      ve.fog
    ]),
    vertexShader: Ke.sprite_vert,
    fragmentShader: Ke.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Qe() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Ke.background_vert,
    fragmentShader: Ke.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Ke.backgroundCube_vert,
    fragmentShader: Ke.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Ke.cube_vert,
    fragmentShader: Ke.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Ke.equirect_vert,
    fragmentShader: Ke.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ Fn([
      ve.common,
      ve.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new T() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Ke.distanceRGBA_vert,
    fragmentShader: Ke.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ Fn([
      ve.lights,
      ve.fog,
      {
        color: { value: /* @__PURE__ */ new Q(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Ke.shadow_vert,
    fragmentShader: Ke.shadow_frag
  }
};
zn.physical = {
  uniforms: /* @__PURE__ */ Fn([
    zn.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Qe() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Qe() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new k(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Qe() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Qe() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Qe() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Q(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Qe() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Qe() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Qe() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new k() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Qe() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Q(0) },
      specularColor: { value: /* @__PURE__ */ new Q(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Qe() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Qe() },
      anisotropyVector: { value: /* @__PURE__ */ new k() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Qe() }
    }
  ]),
  vertexShader: Ke.meshphysical_vert,
  fragmentShader: Ke.meshphysical_frag
};
const wh = { r: 0, b: 0, g: 0 };
function BE(i, e, t, n, s, r, a) {
  const o = new Q(0);
  let l = r === !0 ? 0 : 1, c, h, u = null, d = 0, f = null;
  function m(p, v) {
    let y = !1, _ = v.isScene === !0 ? v.background : null;
    _ && _.isTexture && (_ = (v.backgroundBlurriness > 0 ? t : e).get(_)), _ === null ? g(o, l) : _ && _.isColor && (g(_, 1), y = !0);
    const x = i.xr.getEnvironmentBlendMode();
    x === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, a) : x === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a), (i.autoClear || y) && i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil), _ && (_.isCubeTexture || _.mapping === tl) ? (h === void 0 && (h = new le(
      new Pt(1, 1, 1),
      new mt({
        name: "BackgroundCubeMaterial",
        uniforms: Go(zn.backgroundCube.uniforms),
        vertexShader: zn.backgroundCube.vertexShader,
        fragmentShader: zn.backgroundCube.fragmentShader,
        side: Wn,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(M, S, w) {
      this.matrixWorld.copyPosition(w.matrixWorld);
    }, Object.defineProperty(h.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), s.update(h)), h.material.uniforms.envMap.value = _, h.material.uniforms.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = v.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, h.material.toneMapped = gt.getTransfer(_.colorSpace) !== Mt, (u !== _ || d !== _.version || f !== i.toneMapping) && (h.material.needsUpdate = !0, u = _, d = _.version, f = i.toneMapping), h.layers.enableAll(), p.unshift(h, h.geometry, h.material, 0, 0, null)) : _ && _.isTexture && (c === void 0 && (c = new le(
      new Fr(2, 2),
      new mt({
        name: "BackgroundMaterial",
        uniforms: Go(zn.background.uniforms),
        vertexShader: zn.background.vertexShader,
        fragmentShader: zn.background.fragmentShader,
        side: Wi,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), s.update(c)), c.material.uniforms.t2D.value = _, c.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, c.material.toneMapped = gt.getTransfer(_.colorSpace) !== Mt, _.matrixAutoUpdate === !0 && _.updateMatrix(), c.material.uniforms.uvTransform.value.copy(_.matrix), (u !== _ || d !== _.version || f !== i.toneMapping) && (c.material.needsUpdate = !0, u = _, d = _.version, f = i.toneMapping), c.layers.enableAll(), p.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function g(p, v) {
    p.getRGB(wh, Cx(i)), n.buffers.color.setClear(wh.r, wh.g, wh.b, v, a);
  }
  return {
    getClearColor: function() {
      return o;
    },
    setClearColor: function(p, v = 1) {
      o.set(p), l = v, g(o, l);
    },
    getClearAlpha: function() {
      return l;
    },
    setClearAlpha: function(p) {
      l = p, g(o, l);
    },
    render: m
  };
}
function kE(i, e, t, n) {
  const s = i.getParameter(i.MAX_VERTEX_ATTRIBS), r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"), a = n.isWebGL2 || r !== null, o = {}, l = p(null);
  let c = l, h = !1;
  function u(L, F, H, G, te) {
    let j = !1;
    if (a) {
      const J = g(G, H, F);
      c !== J && (c = J, f(c.object)), j = v(L, G, H, te), j && y(L, G, H, te);
    } else {
      const J = F.wireframe === !0;
      (c.geometry !== G.id || c.program !== H.id || c.wireframe !== J) && (c.geometry = G.id, c.program = H.id, c.wireframe = J, j = !0);
    }
    te !== null && t.update(te, i.ELEMENT_ARRAY_BUFFER), (j || h) && (h = !1, E(L, F, H, G), te !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, t.get(te).buffer));
  }
  function d() {
    return n.isWebGL2 ? i.createVertexArray() : r.createVertexArrayOES();
  }
  function f(L) {
    return n.isWebGL2 ? i.bindVertexArray(L) : r.bindVertexArrayOES(L);
  }
  function m(L) {
    return n.isWebGL2 ? i.deleteVertexArray(L) : r.deleteVertexArrayOES(L);
  }
  function g(L, F, H) {
    const G = H.wireframe === !0;
    let te = o[L.id];
    te === void 0 && (te = {}, o[L.id] = te);
    let j = te[F.id];
    j === void 0 && (j = {}, te[F.id] = j);
    let J = j[G];
    return J === void 0 && (J = p(d()), j[G] = J), J;
  }
  function p(L) {
    const F = [], H = [], G = [];
    for (let te = 0; te < s; te++)
      F[te] = 0, H[te] = 0, G[te] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: F,
      enabledAttributes: H,
      attributeDivisors: G,
      object: L,
      attributes: {},
      index: null
    };
  }
  function v(L, F, H, G) {
    const te = c.attributes, j = F.attributes;
    let J = 0;
    const N = H.getAttributes();
    for (const q in N)
      if (N[q].location >= 0) {
        const de = te[q];
        let be = j[q];
        if (be === void 0 && (q === "instanceMatrix" && L.instanceMatrix && (be = L.instanceMatrix), q === "instanceColor" && L.instanceColor && (be = L.instanceColor)), de === void 0 || de.attribute !== be || be && de.data !== be.data) return !0;
        J++;
      }
    return c.attributesNum !== J || c.index !== G;
  }
  function y(L, F, H, G) {
    const te = {}, j = F.attributes;
    let J = 0;
    const N = H.getAttributes();
    for (const q in N)
      if (N[q].location >= 0) {
        let de = j[q];
        de === void 0 && (q === "instanceMatrix" && L.instanceMatrix && (de = L.instanceMatrix), q === "instanceColor" && L.instanceColor && (de = L.instanceColor));
        const be = {};
        be.attribute = de, de && de.data && (be.data = de.data), te[q] = be, J++;
      }
    c.attributes = te, c.attributesNum = J, c.index = G;
  }
  function _() {
    const L = c.newAttributes;
    for (let F = 0, H = L.length; F < H; F++)
      L[F] = 0;
  }
  function x(L) {
    M(L, 0);
  }
  function M(L, F) {
    const H = c.newAttributes, G = c.enabledAttributes, te = c.attributeDivisors;
    H[L] = 1, G[L] === 0 && (i.enableVertexAttribArray(L), G[L] = 1), te[L] !== F && ((n.isWebGL2 ? i : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](L, F), te[L] = F);
  }
  function S() {
    const L = c.newAttributes, F = c.enabledAttributes;
    for (let H = 0, G = F.length; H < G; H++)
      F[H] !== L[H] && (i.disableVertexAttribArray(H), F[H] = 0);
  }
  function w(L, F, H, G, te, j, J) {
    J === !0 ? i.vertexAttribIPointer(L, F, H, te, j) : i.vertexAttribPointer(L, F, H, G, te, j);
  }
  function E(L, F, H, G) {
    if (n.isWebGL2 === !1 && (L.isInstancedMesh || G.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    _();
    const te = G.attributes, j = H.getAttributes(), J = F.defaultAttributeValues;
    for (const N in j) {
      const q = j[N];
      if (q.location >= 0) {
        let ge = te[N];
        if (ge === void 0 && (N === "instanceMatrix" && L.instanceMatrix && (ge = L.instanceMatrix), N === "instanceColor" && L.instanceColor && (ge = L.instanceColor)), ge !== void 0) {
          const de = ge.normalized, be = ge.itemSize, Fe = t.get(ge);
          if (Fe === void 0) continue;
          const ze = Fe.buffer, Ne = Fe.type, Xe = Fe.bytesPerElement, ct = n.isWebGL2 === !0 && (Ne === i.INT || Ne === i.UNSIGNED_INT || ge.gpuType === Lm);
          if (ge.isInterleavedBufferAttribute) {
            const He = ge.data, I = He.stride, xe = ge.offset;
            if (He.isInstancedInterleavedBuffer) {
              for (let ee = 0; ee < q.locationSize; ee++)
                M(q.location + ee, He.meshPerAttribute);
              L.isInstancedMesh !== !0 && G._maxInstanceCount === void 0 && (G._maxInstanceCount = He.meshPerAttribute * He.count);
            } else
              for (let ee = 0; ee < q.locationSize; ee++)
                x(q.location + ee);
            i.bindBuffer(i.ARRAY_BUFFER, ze);
            for (let ee = 0; ee < q.locationSize; ee++)
              w(
                q.location + ee,
                be / q.locationSize,
                Ne,
                de,
                I * Xe,
                (xe + be / q.locationSize * ee) * Xe,
                ct
              );
          } else {
            if (ge.isInstancedBufferAttribute) {
              for (let He = 0; He < q.locationSize; He++)
                M(q.location + He, ge.meshPerAttribute);
              L.isInstancedMesh !== !0 && G._maxInstanceCount === void 0 && (G._maxInstanceCount = ge.meshPerAttribute * ge.count);
            } else
              for (let He = 0; He < q.locationSize; He++)
                x(q.location + He);
            i.bindBuffer(i.ARRAY_BUFFER, ze);
            for (let He = 0; He < q.locationSize; He++)
              w(
                q.location + He,
                be / q.locationSize,
                Ne,
                de,
                be * Xe,
                be / q.locationSize * He * Xe,
                ct
              );
          }
        } else if (J !== void 0) {
          const de = J[N];
          if (de !== void 0)
            switch (de.length) {
              case 2:
                i.vertexAttrib2fv(q.location, de);
                break;
              case 3:
                i.vertexAttrib3fv(q.location, de);
                break;
              case 4:
                i.vertexAttrib4fv(q.location, de);
                break;
              default:
                i.vertexAttrib1fv(q.location, de);
            }
        }
      }
    }
    S();
  }
  function b() {
    B();
    for (const L in o) {
      const F = o[L];
      for (const H in F) {
        const G = F[H];
        for (const te in G)
          m(G[te].object), delete G[te];
        delete F[H];
      }
      delete o[L];
    }
  }
  function A(L) {
    if (o[L.id] === void 0) return;
    const F = o[L.id];
    for (const H in F) {
      const G = F[H];
      for (const te in G)
        m(G[te].object), delete G[te];
      delete F[H];
    }
    delete o[L.id];
  }
  function D(L) {
    for (const F in o) {
      const H = o[F];
      if (H[L.id] === void 0) continue;
      const G = H[L.id];
      for (const te in G)
        m(G[te].object), delete G[te];
      delete H[L.id];
    }
  }
  function B() {
    X(), h = !0, c !== l && (c = l, f(c.object));
  }
  function X() {
    l.geometry = null, l.program = null, l.wireframe = !1;
  }
  return {
    setup: u,
    reset: B,
    resetDefaultState: X,
    dispose: b,
    releaseStatesOfGeometry: A,
    releaseStatesOfProgram: D,
    initAttributes: _,
    enableAttribute: x,
    disableUnusedAttributes: S
  };
}
function zE(i, e, t, n) {
  const s = n.isWebGL2;
  let r;
  function a(c) {
    r = c;
  }
  function o(c, h) {
    i.drawArrays(r, c, h), t.update(h, r, 1);
  }
  function l(c, h, u) {
    if (u === 0) return;
    let d, f;
    if (s)
      d = i, f = "drawArraysInstanced";
    else if (d = e.get("ANGLE_instanced_arrays"), f = "drawArraysInstancedANGLE", d === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    d[f](r, c, h, u), t.update(h, r, u);
  }
  this.setMode = a, this.render = o, this.renderInstances = l;
}
function HE(i, e, t) {
  let n;
  function s() {
    if (n !== void 0) return n;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const w = e.get("EXT_texture_filter_anisotropic");
      n = i.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      n = 0;
    return n;
  }
  function r(w) {
    if (w === "highp") {
      if (i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision > 0)
        return "highp";
      w = "mediump";
    }
    return w === "mediump" && i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  const a = typeof WebGL2RenderingContext < "u" && i.constructor.name === "WebGL2RenderingContext";
  let o = t.precision !== void 0 ? t.precision : "highp";
  const l = r(o);
  l !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", l, "instead."), o = l);
  const c = a || e.has("WEBGL_draw_buffers"), h = t.logarithmicDepthBuffer === !0, u = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), d = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS), f = i.getParameter(i.MAX_TEXTURE_SIZE), m = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE), g = i.getParameter(i.MAX_VERTEX_ATTRIBS), p = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS), v = i.getParameter(i.MAX_VARYING_VECTORS), y = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS), _ = d > 0, x = a || e.has("OES_texture_float"), M = _ && x, S = a ? i.getParameter(i.MAX_SAMPLES) : 0;
  return {
    isWebGL2: a,
    drawBuffers: c,
    getMaxAnisotropy: s,
    getMaxPrecision: r,
    precision: o,
    logarithmicDepthBuffer: h,
    maxTextures: u,
    maxVertexTextures: d,
    maxTextureSize: f,
    maxCubemapSize: m,
    maxAttributes: g,
    maxVertexUniforms: p,
    maxVaryings: v,
    maxFragmentUniforms: y,
    vertexTextures: _,
    floatFragmentTextures: x,
    floatVertexTextures: M,
    maxSamples: S
  };
}
function GE(i) {
  const e = this;
  let t = null, n = 0, s = !1, r = !1;
  const a = new as(), o = new Qe(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(u, d) {
    const f = u.length !== 0 || d || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || s;
    return s = d, n = u.length, f;
  }, this.beginShadows = function() {
    r = !0, h(null);
  }, this.endShadows = function() {
    r = !1;
  }, this.setGlobalState = function(u, d) {
    t = h(u, d, 0);
  }, this.setState = function(u, d, f) {
    const m = u.clippingPlanes, g = u.clipIntersection, p = u.clipShadows, v = i.get(u);
    if (!s || m === null || m.length === 0 || r && !p)
      r ? h(null) : c();
    else {
      const y = r ? 0 : n, _ = y * 4;
      let x = v.clippingState || null;
      l.value = x, x = h(m, d, _, f);
      for (let M = 0; M !== _; ++M)
        x[M] = t[M];
      v.clippingState = x, this.numIntersection = g ? this.numPlanes : 0, this.numPlanes += y;
    }
  };
  function c() {
    l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function h(u, d, f, m) {
    const g = u !== null ? u.length : 0;
    let p = null;
    if (g !== 0) {
      if (p = l.value, m !== !0 || p === null) {
        const v = f + g * 4, y = d.matrixWorldInverse;
        o.getNormalMatrix(y), (p === null || p.length < v) && (p = new Float32Array(v));
        for (let _ = 0, x = f; _ !== g; ++_, x += 4)
          a.copy(u[_]).applyMatrix4(y, o), a.normal.toArray(p, x), p[x + 3] = a.constant;
      }
      l.value = p, l.needsUpdate = !0;
    }
    return e.numPlanes = g, e.numIntersection = 0, p;
  }
}
function VE(i) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(a, o) {
    return o === ko ? a.mapping = Gs : o === ic && (a.mapping = Tr), a;
  }
  function n(a) {
    if (a && a.isTexture && a.isRenderTargetTexture === !1) {
      const o = a.mapping;
      if (o === ko || o === ic)
        if (e.has(a)) {
          const l = e.get(a).texture;
          return t(l, a.mapping);
        } else {
          const l = a.image;
          if (l && l.height > 0) {
            const c = new Px(l.height / 2);
            return c.fromEquirectangularTexture(i, a), e.set(a, c), a.addEventListener("dispose", s), t(c.texture, a.mapping);
          } else
            return null;
        }
    }
    return a;
  }
  function s(a) {
    const o = a.target;
    o.removeEventListener("dispose", s);
    const l = e.get(o);
    l !== void 0 && (e.delete(o), l.dispose());
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: r
  };
}
class Na extends _d {
  constructor(e = -1, t = 1, n = 1, s = -1, r = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = s, this.near = r, this.far = a, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, n, s, r, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = s, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
    let r = n - e, a = n + e, o = s + t, l = s - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r += c * this.view.offsetX, a = r + c * this.view.width, o -= h * this.view.offsetY, l = o - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const vo = 4, N0 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], da = 20, pf = /* @__PURE__ */ new Na(), U0 = /* @__PURE__ */ new Q();
let mf = null, gf = 0, vf = 0;
const ca = (1 + Math.sqrt(5)) / 2, no = 1 / ca, F0 = [
  /* @__PURE__ */ new T(1, 1, 1),
  /* @__PURE__ */ new T(-1, 1, 1),
  /* @__PURE__ */ new T(1, 1, -1),
  /* @__PURE__ */ new T(-1, 1, -1),
  /* @__PURE__ */ new T(0, ca, no),
  /* @__PURE__ */ new T(0, ca, -no),
  /* @__PURE__ */ new T(no, 0, ca),
  /* @__PURE__ */ new T(-no, 0, ca),
  /* @__PURE__ */ new T(ca, no, 0),
  /* @__PURE__ */ new T(-ca, no, 0)
];
class Fp {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, n = 0.1, s = 100) {
    mf = this._renderer.getRenderTarget(), gf = this._renderer.getActiveCubeFace(), vf = this._renderer.getActiveMipmapLevel(), this._setSize(256);
    const r = this._allocateTargets();
    return r.depthBuffer = !0, this._sceneToCubeUV(e, n, s, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = z0(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = k0(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(mf, gf, vf), e.scissorTest = !1, Th(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Gs || e.mapping === Tr ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), mf = this._renderer.getRenderTarget(), gf = this._renderer.getActiveCubeFace(), vf = this._renderer.getActiveMipmapLevel();
    const n = t || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
      magFilter: Nt,
      minFilter: Nt,
      generateMipmaps: !1,
      type: zt,
      format: gi,
      colorSpace: en,
      depthBuffer: !1
    }, s = B0(e, t, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = B0(e, t, n);
      const { _lodMax: r } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = WE(r)), this._blurMaterial = XE(r, e, t);
    }
    return s;
  }
  _compileMaterial(e) {
    const t = new le(this._lodPlanes[0], e);
    this._renderer.compile(t, pf);
  }
  _sceneToCubeUV(e, t, n, s) {
    const o = new Zt(90, 1, t, n), l = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], h = this._renderer, u = h.autoClear, d = h.toneMapping;
    h.getClearColor(U0), h.toneMapping = ps, h.autoClear = !1;
    const f = new on({
      name: "PMREM.Background",
      side: Wn,
      depthWrite: !1,
      depthTest: !1
    }), m = new le(new Pt(), f);
    let g = !1;
    const p = e.background;
    p ? p.isColor && (f.color.copy(p), e.background = null, g = !0) : (f.color.copy(U0), g = !0);
    for (let v = 0; v < 6; v++) {
      const y = v % 3;
      y === 0 ? (o.up.set(0, l[v], 0), o.lookAt(c[v], 0, 0)) : y === 1 ? (o.up.set(0, 0, l[v]), o.lookAt(0, c[v], 0)) : (o.up.set(0, l[v], 0), o.lookAt(0, 0, c[v]));
      const _ = this._cubeSize;
      Th(s, y * _, v > 2 ? _ : 0, _, _), h.setRenderTarget(s), g && h.render(m, o), h.render(e, o);
    }
    m.geometry.dispose(), m.material.dispose(), h.toneMapping = d, h.autoClear = u, e.background = p;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, s = e.mapping === Gs || e.mapping === Tr;
    s ? (this._cubemapMaterial === null && (this._cubemapMaterial = z0()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = k0());
    const r = s ? this._cubemapMaterial : this._equirectMaterial, a = new le(this._lodPlanes[0], r), o = r.uniforms;
    o.envMap.value = e;
    const l = this._cubeSize;
    Th(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(a, pf);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    for (let s = 1; s < this._lodPlanes.length; s++) {
      const r = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]), a = F0[(s - 1) % F0.length];
      this._blur(e, s - 1, s, r, a);
    }
    t.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, n, s, r) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      a,
      t,
      n,
      s,
      "latitudinal",
      r
    ), this._halfBlur(
      a,
      e,
      n,
      n,
      s,
      "longitudinal",
      r
    );
  }
  _halfBlur(e, t, n, s, r, a, o) {
    const l = this._renderer, c = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const h = 3, u = new le(this._lodPlanes[s], c), d = c.uniforms, f = this._sizeLods[n] - 1, m = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * da - 1), g = r / m, p = isFinite(r) ? 1 + Math.floor(h * g) : da;
    p > da && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${da}`);
    const v = [];
    let y = 0;
    for (let w = 0; w < da; ++w) {
      const E = w / g, b = Math.exp(-E * E / 2);
      v.push(b), w === 0 ? y += b : w < p && (y += 2 * b);
    }
    for (let w = 0; w < v.length; w++)
      v[w] = v[w] / y;
    d.envMap.value = e.texture, d.samples.value = p, d.weights.value = v, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o);
    const { _lodMax: _ } = this;
    d.dTheta.value = m, d.mipInt.value = _ - n;
    const x = this._sizeLods[s], M = 3 * x * (s > _ - vo ? s - _ + vo : 0), S = 4 * (this._cubeSize - x);
    Th(t, M, S, 3 * x, 2 * x), l.setRenderTarget(t), l.render(u, pf);
  }
}
function WE(i) {
  const e = [], t = [], n = [];
  let s = i;
  const r = i - vo + 1 + N0.length;
  for (let a = 0; a < r; a++) {
    const o = Math.pow(2, s);
    t.push(o);
    let l = 1 / o;
    a > i - vo ? l = N0[a - i + vo - 1] : a === 0 && (l = 0), n.push(l);
    const c = 1 / (o - 2), h = -c, u = 1 + c, d = [h, h, u, h, u, u, h, h, u, u, h, u], f = 6, m = 6, g = 3, p = 2, v = 1, y = new Float32Array(g * m * f), _ = new Float32Array(p * m * f), x = new Float32Array(v * m * f);
    for (let S = 0; S < f; S++) {
      const w = S % 3 * 2 / 3 - 1, E = S > 2 ? 0 : -1, b = [
        w,
        E,
        0,
        w + 2 / 3,
        E,
        0,
        w + 2 / 3,
        E + 1,
        0,
        w,
        E,
        0,
        w + 2 / 3,
        E + 1,
        0,
        w,
        E + 1,
        0
      ];
      y.set(b, g * m * S), _.set(d, p * m * S);
      const A = [S, S, S, S, S, S];
      x.set(A, v * m * S);
    }
    const M = new Be();
    M.setAttribute("position", new dt(y, g)), M.setAttribute("uv", new dt(_, p)), M.setAttribute("faceIndex", new dt(x, v)), e.push(M), s > vo && s--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function B0(i, e, t) {
  const n = new xt(i, e, t);
  return n.texture.mapping = tl, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function Th(i, e, t, n, s) {
  i.viewport.set(e, t, n, s), i.scissor.set(e, t, n, s);
}
function XE(i, e, t) {
  const n = new Float32Array(da), s = new T(0, 1, 0);
  return new mt({
    name: "SphericalGaussianBlur",
    defines: {
      n: da,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${i}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: s }
    },
    vertexShader: Ym(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: vt,
    depthTest: !1,
    depthWrite: !1
  });
}
function k0() {
  return new mt({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: Ym(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: vt,
    depthTest: !1,
    depthWrite: !1
  });
}
function z0() {
  return new mt({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: Ym(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: vt,
    depthTest: !1,
    depthWrite: !1
  });
}
function Ym() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function qE(i) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function n(o) {
    if (o && o.isTexture) {
      const l = o.mapping, c = l === ko || l === ic, h = l === Gs || l === Tr;
      if (c || h)
        if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
          o.needsPMREMUpdate = !1;
          let u = e.get(o);
          return t === null && (t = new Fp(i)), u = c ? t.fromEquirectangular(o, u) : t.fromCubemap(o, u), e.set(o, u), u.texture;
        } else {
          if (e.has(o))
            return e.get(o).texture;
          {
            const u = o.image;
            if (c && u && u.height > 0 || h && u && s(u)) {
              t === null && (t = new Fp(i));
              const d = c ? t.fromEquirectangular(o) : t.fromCubemap(o);
              return e.set(o, d), o.addEventListener("dispose", r), d.texture;
            } else
              return null;
          }
        }
    }
    return o;
  }
  function s(o) {
    let l = 0;
    const c = 6;
    for (let h = 0; h < c; h++)
      o[h] !== void 0 && l++;
    return l === c;
  }
  function r(o) {
    const l = o.target;
    l.removeEventListener("dispose", r);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: n,
    dispose: a
  };
}
function YE(i) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0)
      return e[n];
    let s;
    switch (n) {
      case "WEBGL_depth_texture":
        s = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        s = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        s = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        s = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        s = i.getExtension(n);
    }
    return e[n] = s, s;
  }
  return {
    has: function(n) {
      return t(n) !== null;
    },
    init: function(n) {
      n.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(n) {
      const s = t(n);
      return s === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), s;
    }
  };
}
function jE(i, e, t, n) {
  const s = {}, r = /* @__PURE__ */ new WeakMap();
  function a(u) {
    const d = u.target;
    d.index !== null && e.remove(d.index);
    for (const m in d.attributes)
      e.remove(d.attributes[m]);
    for (const m in d.morphAttributes) {
      const g = d.morphAttributes[m];
      for (let p = 0, v = g.length; p < v; p++)
        e.remove(g[p]);
    }
    d.removeEventListener("dispose", a), delete s[d.id];
    const f = r.get(d);
    f && (e.remove(f), r.delete(d)), n.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, t.memory.geometries--;
  }
  function o(u, d) {
    return s[d.id] === !0 || (d.addEventListener("dispose", a), s[d.id] = !0, t.memory.geometries++), d;
  }
  function l(u) {
    const d = u.attributes;
    for (const m in d)
      e.update(d[m], i.ARRAY_BUFFER);
    const f = u.morphAttributes;
    for (const m in f) {
      const g = f[m];
      for (let p = 0, v = g.length; p < v; p++)
        e.update(g[p], i.ARRAY_BUFFER);
    }
  }
  function c(u) {
    const d = [], f = u.index, m = u.attributes.position;
    let g = 0;
    if (f !== null) {
      const y = f.array;
      g = f.version;
      for (let _ = 0, x = y.length; _ < x; _ += 3) {
        const M = y[_ + 0], S = y[_ + 1], w = y[_ + 2];
        d.push(M, S, S, w, w, M);
      }
    } else if (m !== void 0) {
      const y = m.array;
      g = m.version;
      for (let _ = 0, x = y.length / 3 - 1; _ < x; _ += 3) {
        const M = _ + 0, S = _ + 1, w = _ + 2;
        d.push(M, S, S, w, w, M);
      }
    } else
      return;
    const p = new (wx(d) ? qm : vd)(d, 1);
    p.version = g;
    const v = r.get(u);
    v && e.remove(v), r.set(u, p);
  }
  function h(u) {
    const d = r.get(u);
    if (d) {
      const f = u.index;
      f !== null && d.version < f.version && c(u);
    } else
      c(u);
    return r.get(u);
  }
  return {
    get: o,
    update: l,
    getWireframeAttribute: h
  };
}
function ZE(i, e, t, n) {
  const s = n.isWebGL2;
  let r;
  function a(d) {
    r = d;
  }
  let o, l;
  function c(d) {
    o = d.type, l = d.bytesPerElement;
  }
  function h(d, f) {
    i.drawElements(r, f, o, d * l), t.update(f, r, 1);
  }
  function u(d, f, m) {
    if (m === 0) return;
    let g, p;
    if (s)
      g = i, p = "drawElementsInstanced";
    else if (g = e.get("ANGLE_instanced_arrays"), p = "drawElementsInstancedANGLE", g === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    g[p](r, f, o, d * l, m), t.update(f, r, m);
  }
  this.setMode = a, this.setIndex = c, this.render = h, this.renderInstances = u;
}
function $E(i) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(r, a, o) {
    switch (t.calls++, a) {
      case i.TRIANGLES:
        t.triangles += o * (r / 3);
        break;
      case i.LINES:
        t.lines += o * (r / 2);
        break;
      case i.LINE_STRIP:
        t.lines += o * (r - 1);
        break;
      case i.LINE_LOOP:
        t.lines += o * r;
        break;
      case i.POINTS:
        t.points += o * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function s() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: s,
    update: n
  };
}
function KE(i, e) {
  return i[0] - e[0];
}
function QE(i, e) {
  return Math.abs(e[1]) - Math.abs(i[1]);
}
function JE(i, e, t) {
  const n = {}, s = new Float32Array(8), r = /* @__PURE__ */ new WeakMap(), a = new tt(), o = [];
  for (let c = 0; c < 8; c++)
    o[c] = [c, 0];
  function l(c, h, u) {
    const d = c.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const f = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color, m = f !== void 0 ? f.length : 0;
      let g = r.get(h);
      if (g === void 0 || g.count !== m) {
        let L = function() {
          B.dispose(), r.delete(h), h.removeEventListener("dispose", L);
        };
        g !== void 0 && g.texture.dispose();
        const y = h.morphAttributes.position !== void 0, _ = h.morphAttributes.normal !== void 0, x = h.morphAttributes.color !== void 0, M = h.morphAttributes.position || [], S = h.morphAttributes.normal || [], w = h.morphAttributes.color || [];
        let E = 0;
        y === !0 && (E = 1), _ === !0 && (E = 2), x === !0 && (E = 3);
        let b = h.attributes.position.count * E, A = 1;
        b > e.maxTextureSize && (A = Math.ceil(b / e.maxTextureSize), b = e.maxTextureSize);
        const D = new Float32Array(b * A * 4 * m), B = new md(D, b, A, m);
        B.type = hs, B.needsUpdate = !0;
        const X = E * 4;
        for (let F = 0; F < m; F++) {
          const H = M[F], G = S[F], te = w[F], j = b * A * 4 * F;
          for (let J = 0; J < H.count; J++) {
            const N = J * X;
            y === !0 && (a.fromBufferAttribute(H, J), D[j + N + 0] = a.x, D[j + N + 1] = a.y, D[j + N + 2] = a.z, D[j + N + 3] = 0), _ === !0 && (a.fromBufferAttribute(G, J), D[j + N + 4] = a.x, D[j + N + 5] = a.y, D[j + N + 6] = a.z, D[j + N + 7] = 0), x === !0 && (a.fromBufferAttribute(te, J), D[j + N + 8] = a.x, D[j + N + 9] = a.y, D[j + N + 10] = a.z, D[j + N + 11] = te.itemSize === 4 ? a.w : 1);
          }
        }
        g = {
          count: m,
          texture: B,
          size: new k(b, A)
        }, r.set(h, g), h.addEventListener("dispose", L);
      }
      let p = 0;
      for (let y = 0; y < d.length; y++)
        p += d[y];
      const v = h.morphTargetsRelative ? 1 : 1 - p;
      u.getUniforms().setValue(i, "morphTargetBaseInfluence", v), u.getUniforms().setValue(i, "morphTargetInfluences", d), u.getUniforms().setValue(i, "morphTargetsTexture", g.texture, t), u.getUniforms().setValue(i, "morphTargetsTextureSize", g.size);
    } else {
      const f = d === void 0 ? 0 : d.length;
      let m = n[h.id];
      if (m === void 0 || m.length !== f) {
        m = [];
        for (let _ = 0; _ < f; _++)
          m[_] = [_, 0];
        n[h.id] = m;
      }
      for (let _ = 0; _ < f; _++) {
        const x = m[_];
        x[0] = _, x[1] = d[_];
      }
      m.sort(QE);
      for (let _ = 0; _ < 8; _++)
        _ < f && m[_][1] ? (o[_][0] = m[_][0], o[_][1] = m[_][1]) : (o[_][0] = Number.MAX_SAFE_INTEGER, o[_][1] = 0);
      o.sort(KE);
      const g = h.morphAttributes.position, p = h.morphAttributes.normal;
      let v = 0;
      for (let _ = 0; _ < 8; _++) {
        const x = o[_], M = x[0], S = x[1];
        M !== Number.MAX_SAFE_INTEGER && S ? (g && h.getAttribute("morphTarget" + _) !== g[M] && h.setAttribute("morphTarget" + _, g[M]), p && h.getAttribute("morphNormal" + _) !== p[M] && h.setAttribute("morphNormal" + _, p[M]), s[_] = S, v += S) : (g && h.hasAttribute("morphTarget" + _) === !0 && h.deleteAttribute("morphTarget" + _), p && h.hasAttribute("morphNormal" + _) === !0 && h.deleteAttribute("morphNormal" + _), s[_] = 0);
      }
      const y = h.morphTargetsRelative ? 1 : 1 - v;
      u.getUniforms().setValue(i, "morphTargetBaseInfluence", y), u.getUniforms().setValue(i, "morphTargetInfluences", s);
    }
  }
  return {
    update: l
  };
}
function eA(i, e, t, n) {
  let s = /* @__PURE__ */ new WeakMap();
  function r(l) {
    const c = n.render.frame, h = l.geometry, u = e.get(l, h);
    if (s.get(u) !== c && (e.update(u), s.set(u, c)), l.isInstancedMesh && (l.hasEventListener("dispose", o) === !1 && l.addEventListener("dispose", o), s.get(l) !== c && (t.update(l.instanceMatrix, i.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, i.ARRAY_BUFFER), s.set(l, c))), l.isSkinnedMesh) {
      const d = l.skeleton;
      s.get(d) !== c && (d.update(), s.set(d, c));
    }
    return u;
  }
  function a() {
    s = /* @__PURE__ */ new WeakMap();
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return {
    update: r,
    dispose: a
  };
}
const Ix = /* @__PURE__ */ new At(), Dx = /* @__PURE__ */ new md(), Ox = /* @__PURE__ */ new Xm(), Nx = /* @__PURE__ */ new Fc(), H0 = [], G0 = [], V0 = new Float32Array(16), W0 = new Float32Array(9), X0 = new Float32Array(4);
function nl(i, e, t) {
  const n = i[0];
  if (n <= 0 || n > 0) return i;
  const s = e * t;
  let r = H0[s];
  if (r === void 0 && (r = new Float32Array(s), H0[s] = r), e !== 0) {
    n.toArray(r, 0);
    for (let a = 1, o = 0; a !== e; ++a)
      o += t, i[a].toArray(r, o);
  }
  return r;
}
function hn(i, e) {
  if (i.length !== e.length) return !1;
  for (let t = 0, n = i.length; t < n; t++)
    if (i[t] !== e[t]) return !1;
  return !0;
}
function un(i, e) {
  for (let t = 0, n = e.length; t < n; t++)
    i[t] = e[t];
}
function xd(i, e) {
  let t = G0[e];
  t === void 0 && (t = new Int32Array(e), G0[e] = t);
  for (let n = 0; n !== e; ++n)
    t[n] = i.allocateTextureUnit();
  return t;
}
function tA(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1f(this.addr, e), t[0] = e);
}
function nA(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (i.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (hn(t, e)) return;
    i.uniform2fv(this.addr, e), un(t, e);
  }
}
function iA(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (i.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (hn(t, e)) return;
    i.uniform3fv(this.addr, e), un(t, e);
  }
}
function sA(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (hn(t, e)) return;
    i.uniform4fv(this.addr, e), un(t, e);
  }
}
function rA(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (hn(t, e)) return;
    i.uniformMatrix2fv(this.addr, !1, e), un(t, e);
  } else {
    if (hn(t, n)) return;
    X0.set(n), i.uniformMatrix2fv(this.addr, !1, X0), un(t, n);
  }
}
function aA(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (hn(t, e)) return;
    i.uniformMatrix3fv(this.addr, !1, e), un(t, e);
  } else {
    if (hn(t, n)) return;
    W0.set(n), i.uniformMatrix3fv(this.addr, !1, W0), un(t, n);
  }
}
function oA(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (hn(t, e)) return;
    i.uniformMatrix4fv(this.addr, !1, e), un(t, e);
  } else {
    if (hn(t, n)) return;
    V0.set(n), i.uniformMatrix4fv(this.addr, !1, V0), un(t, n);
  }
}
function lA(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1i(this.addr, e), t[0] = e);
}
function cA(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (i.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (hn(t, e)) return;
    i.uniform2iv(this.addr, e), un(t, e);
  }
}
function hA(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (hn(t, e)) return;
    i.uniform3iv(this.addr, e), un(t, e);
  }
}
function uA(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (hn(t, e)) return;
    i.uniform4iv(this.addr, e), un(t, e);
  }
}
function dA(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1ui(this.addr, e), t[0] = e);
}
function fA(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (i.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (hn(t, e)) return;
    i.uniform2uiv(this.addr, e), un(t, e);
  }
}
function pA(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (hn(t, e)) return;
    i.uniform3uiv(this.addr, e), un(t, e);
  }
}
function mA(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (hn(t, e)) return;
    i.uniform4uiv(this.addr, e), un(t, e);
  }
}
function gA(i, e, t) {
  const n = this.cache, s = t.allocateTextureUnit();
  n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), t.setTexture2D(e || Ix, s);
}
function vA(i, e, t) {
  const n = this.cache, s = t.allocateTextureUnit();
  n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), t.setTexture3D(e || Ox, s);
}
function _A(i, e, t) {
  const n = this.cache, s = t.allocateTextureUnit();
  n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), t.setTextureCube(e || Nx, s);
}
function yA(i, e, t) {
  const n = this.cache, s = t.allocateTextureUnit();
  n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), t.setTexture2DArray(e || Dx, s);
}
function xA(i) {
  switch (i) {
    case 5126:
      return tA;
    case 35664:
      return nA;
    case 35665:
      return iA;
    case 35666:
      return sA;
    case 35674:
      return rA;
    case 35675:
      return aA;
    case 35676:
      return oA;
    case 5124:
    case 35670:
      return lA;
    case 35667:
    case 35671:
      return cA;
    case 35668:
    case 35672:
      return hA;
    case 35669:
    case 35673:
      return uA;
    case 5125:
      return dA;
    case 36294:
      return fA;
    case 36295:
      return pA;
    case 36296:
      return mA;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return gA;
    case 35679:
    case 36299:
    case 36307:
      return vA;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return _A;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return yA;
  }
}
function MA(i, e) {
  i.uniform1fv(this.addr, e);
}
function bA(i, e) {
  const t = nl(e, this.size, 2);
  i.uniform2fv(this.addr, t);
}
function SA(i, e) {
  const t = nl(e, this.size, 3);
  i.uniform3fv(this.addr, t);
}
function wA(i, e) {
  const t = nl(e, this.size, 4);
  i.uniform4fv(this.addr, t);
}
function TA(i, e) {
  const t = nl(e, this.size, 4);
  i.uniformMatrix2fv(this.addr, !1, t);
}
function EA(i, e) {
  const t = nl(e, this.size, 9);
  i.uniformMatrix3fv(this.addr, !1, t);
}
function AA(i, e) {
  const t = nl(e, this.size, 16);
  i.uniformMatrix4fv(this.addr, !1, t);
}
function CA(i, e) {
  i.uniform1iv(this.addr, e);
}
function RA(i, e) {
  i.uniform2iv(this.addr, e);
}
function PA(i, e) {
  i.uniform3iv(this.addr, e);
}
function LA(i, e) {
  i.uniform4iv(this.addr, e);
}
function IA(i, e) {
  i.uniform1uiv(this.addr, e);
}
function DA(i, e) {
  i.uniform2uiv(this.addr, e);
}
function OA(i, e) {
  i.uniform3uiv(this.addr, e);
}
function NA(i, e) {
  i.uniform4uiv(this.addr, e);
}
function UA(i, e, t) {
  const n = this.cache, s = e.length, r = xd(t, s);
  hn(n, r) || (i.uniform1iv(this.addr, r), un(n, r));
  for (let a = 0; a !== s; ++a)
    t.setTexture2D(e[a] || Ix, r[a]);
}
function FA(i, e, t) {
  const n = this.cache, s = e.length, r = xd(t, s);
  hn(n, r) || (i.uniform1iv(this.addr, r), un(n, r));
  for (let a = 0; a !== s; ++a)
    t.setTexture3D(e[a] || Ox, r[a]);
}
function BA(i, e, t) {
  const n = this.cache, s = e.length, r = xd(t, s);
  hn(n, r) || (i.uniform1iv(this.addr, r), un(n, r));
  for (let a = 0; a !== s; ++a)
    t.setTextureCube(e[a] || Nx, r[a]);
}
function kA(i, e, t) {
  const n = this.cache, s = e.length, r = xd(t, s);
  hn(n, r) || (i.uniform1iv(this.addr, r), un(n, r));
  for (let a = 0; a !== s; ++a)
    t.setTexture2DArray(e[a] || Dx, r[a]);
}
function zA(i) {
  switch (i) {
    case 5126:
      return MA;
    case 35664:
      return bA;
    case 35665:
      return SA;
    case 35666:
      return wA;
    case 35674:
      return TA;
    case 35675:
      return EA;
    case 35676:
      return AA;
    case 5124:
    case 35670:
      return CA;
    case 35667:
    case 35671:
      return RA;
    case 35668:
    case 35672:
      return PA;
    case 35669:
    case 35673:
      return LA;
    case 5125:
      return IA;
    case 36294:
      return DA;
    case 36295:
      return OA;
    case 36296:
      return NA;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return UA;
    case 35679:
    case 36299:
    case 36307:
      return FA;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return BA;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return kA;
  }
}
class HA {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.setValue = xA(t.type);
  }
}
class GA {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = zA(t.type);
  }
}
class VA {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, n) {
    const s = this.seq;
    for (let r = 0, a = s.length; r !== a; ++r) {
      const o = s[r];
      o.setValue(e, t[o.id], n);
    }
  }
}
const _f = /(\w+)(\])?(\[|\.)?/g;
function q0(i, e) {
  i.seq.push(e), i.map[e.id] = e;
}
function WA(i, e, t) {
  const n = i.name, s = n.length;
  for (_f.lastIndex = 0; ; ) {
    const r = _f.exec(n), a = _f.lastIndex;
    let o = r[1];
    const l = r[2] === "]", c = r[3];
    if (l && (o = o | 0), c === void 0 || c === "[" && a + 2 === s) {
      q0(t, c === void 0 ? new HA(o, i, e) : new GA(o, i, e));
      break;
    } else {
      let u = t.map[o];
      u === void 0 && (u = new VA(o), q0(t, u)), t = u;
    }
  }
}
class gu {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let s = 0; s < n; ++s) {
      const r = e.getActiveUniform(t, s), a = e.getUniformLocation(t, r.name);
      WA(r, a, this);
    }
  }
  setValue(e, t, n, s) {
    const r = this.map[t];
    r !== void 0 && r.setValue(e, n, s);
  }
  setOptional(e, t, n) {
    const s = t[n];
    s !== void 0 && this.setValue(e, n, s);
  }
  static upload(e, t, n, s) {
    for (let r = 0, a = t.length; r !== a; ++r) {
      const o = t[r], l = n[o.id];
      l.needsUpdate !== !1 && o.setValue(e, l.value, s);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let s = 0, r = e.length; s !== r; ++s) {
      const a = e[s];
      a.id in t && n.push(a);
    }
    return n;
  }
}
function Y0(i, e, t) {
  const n = i.createShader(e);
  return i.shaderSource(n, t), i.compileShader(n), n;
}
const XA = 37297;
let qA = 0;
function YA(i, e) {
  const t = i.split(`
`), n = [], s = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
  for (let a = s; a < r; a++) {
    const o = a + 1;
    n.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
  }
  return n.join(`
`);
}
function jA(i) {
  const e = gt.getPrimaries(gt.workingColorSpace), t = gt.getPrimaries(i);
  let n;
  switch (e === t ? n = "" : e === lc && t === oc ? n = "LinearDisplayP3ToLinearSRGB" : e === oc && t === lc && (n = "LinearSRGBToLinearDisplayP3"), i) {
    case en:
    case Uc:
      return [n, "LinearTransferOETF"];
    case ft:
    case pd:
      return [n, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", i), [n, "LinearTransferOETF"];
  }
}
function j0(i, e, t) {
  const n = i.getShaderParameter(e, i.COMPILE_STATUS), s = i.getShaderInfoLog(e).trim();
  if (n && s === "") return "";
  const r = /ERROR: 0:(\d+)/.exec(s);
  if (r) {
    const a = parseInt(r[1]);
    return t.toUpperCase() + `

` + s + `

` + YA(i.getShaderSource(e), a);
  } else
    return s;
}
function ZA(i, e) {
  const t = jA(e);
  return `vec4 ${i}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function $A(i, e) {
  let t;
  switch (e) {
    case od:
      t = "Linear";
      break;
    case ld:
      t = "Reinhard";
      break;
    case cd:
      t = "OptimizedCineon";
      break;
    case hd:
      t = "ACESFilmic";
      break;
    case ex:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function KA(i) {
  return [
    i.extensionDerivatives || i.envMapCubeUVHeight || i.bumpMap || i.normalMapTangentSpace || i.clearcoatNormalMap || i.flatShading || i.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (i.extensionFragDepth || i.logarithmicDepthBuffer) && i.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    i.extensionDrawBuffers && i.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (i.extensionShaderTextureLOD || i.envMap || i.transmission) && i.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(Pl).join(`
`);
}
function QA(i) {
  const e = [];
  for (const t in i) {
    const n = i[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function JA(i, e) {
  const t = {}, n = i.getProgramParameter(e, i.ACTIVE_ATTRIBUTES);
  for (let s = 0; s < n; s++) {
    const r = i.getActiveAttrib(e, s), a = r.name;
    let o = 1;
    r.type === i.FLOAT_MAT2 && (o = 2), r.type === i.FLOAT_MAT3 && (o = 3), r.type === i.FLOAT_MAT4 && (o = 4), t[a] = {
      type: r.type,
      location: i.getAttribLocation(e, a),
      locationSize: o
    };
  }
  return t;
}
function Pl(i) {
  return i !== "";
}
function Z0(i, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return i.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function $0(i, e) {
  return i.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const eC = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Bp(i) {
  return i.replace(eC, nC);
}
const tC = /* @__PURE__ */ new Map([
  ["encodings_fragment", "colorspace_fragment"],
  // @deprecated, r154
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  // @deprecated, r154
  ["output_fragment", "opaque_fragment"]
  // @deprecated, r154
]);
function nC(i, e) {
  let t = Ke[e];
  if (t === void 0) {
    const n = tC.get(e);
    if (n !== void 0)
      t = Ke[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return Bp(t);
}
const iC = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function K0(i) {
  return i.replace(iC, sC);
}
function sC(i, e, t, n) {
  let s = "";
  for (let r = parseInt(e); r < parseInt(t); r++)
    s += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
  return s;
}
function Q0(i) {
  let e = "precision " + i.precision + ` float;
precision ` + i.precision + " int;";
  return i.precision === "highp" ? e += `
#define HIGH_PRECISION` : i.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : i.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function rC(i) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return i.shadowMapType === nd ? e = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === Am ? e = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === zi && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function aC(i) {
  let e = "ENVMAP_TYPE_CUBE";
  if (i.envMap)
    switch (i.envMapMode) {
      case Gs:
      case Tr:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case tl:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function oC(i) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (i.envMap)
    switch (i.envMapMode) {
      case Tr:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function lC(i) {
  let e = "ENVMAP_BLENDING_NONE";
  if (i.envMap)
    switch (i.combine) {
      case Oc:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case Qy:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case Jy:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function cC(i) {
  const e = i.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: n, maxMip: t };
}
function hC(i, e, t, n) {
  const s = i.getContext(), r = t.defines;
  let a = t.vertexShader, o = t.fragmentShader;
  const l = rC(t), c = aC(t), h = oC(t), u = lC(t), d = cC(t), f = t.isWebGL2 ? "" : KA(t), m = QA(r), g = s.createProgram();
  let p, v, y = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (p = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m
  ].filter(Pl).join(`
`), p.length > 0 && (p += `
`), v = [
    f,
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m
  ].filter(Pl).join(`
`), v.length > 0 && (v += `
`)) : (p = [
    Q0(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m,
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + h : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Pl).join(`
`), v = [
    f,
    Q0(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + c : "",
    t.envMap ? "#define " + h : "",
    t.envMap ? "#define " + u : "",
    d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
    d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
    d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== ps ? "#define TONE_MAPPING" : "",
    t.toneMapping !== ps ? Ke.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== ps ? $A("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    Ke.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    ZA("linearToOutputTexel", t.outputColorSpace),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(Pl).join(`
`)), a = Bp(a), a = Z0(a, t), a = $0(a, t), o = Bp(o), o = Z0(o, t), o = $0(o, t), a = K0(a), o = K0(o), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (y = `#version 300 es
`, p = [
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + p, v = [
    "precision mediump sampler2DArray;",
    "#define varying in",
    t.glslVersion === Np ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === Np ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + v);
  const _ = y + p + a, x = y + v + o, M = Y0(s, s.VERTEX_SHADER, _), S = Y0(s, s.FRAGMENT_SHADER, x);
  s.attachShader(g, M), s.attachShader(g, S), t.index0AttributeName !== void 0 ? s.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && s.bindAttribLocation(g, 0, "position"), s.linkProgram(g);
  function w(D) {
    if (i.debug.checkShaderErrors) {
      const B = s.getProgramInfoLog(g).trim(), X = s.getShaderInfoLog(M).trim(), L = s.getShaderInfoLog(S).trim();
      let F = !0, H = !0;
      if (s.getProgramParameter(g, s.LINK_STATUS) === !1)
        if (F = !1, typeof i.debug.onShaderError == "function")
          i.debug.onShaderError(s, g, M, S);
        else {
          const G = j0(s, M, "vertex"), te = j0(s, S, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(g, s.VALIDATE_STATUS) + `

Program Info Log: ` + B + `
` + G + `
` + te
          );
        }
      else B !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", B) : (X === "" || L === "") && (H = !1);
      H && (D.diagnostics = {
        runnable: F,
        programLog: B,
        vertexShader: {
          log: X,
          prefix: p
        },
        fragmentShader: {
          log: L,
          prefix: v
        }
      });
    }
    s.deleteShader(M), s.deleteShader(S), E = new gu(s, g), b = JA(s, g);
  }
  let E;
  this.getUniforms = function() {
    return E === void 0 && w(this), E;
  };
  let b;
  this.getAttributes = function() {
    return b === void 0 && w(this), b;
  };
  let A = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return A === !1 && (A = s.getProgramParameter(g, XA)), A;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), s.deleteProgram(g), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = qA++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = M, this.fragmentShader = S, this;
}
let uC = 0;
class dC {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, n = e.fragmentShader, s = this._getShaderStage(t), r = this._getShaderStage(n), a = this._getShaderCacheForMaterial(e);
    return a.has(s) === !1 && (a.add(s), s.usedTimes++), a.has(r) === !1 && (a.add(r), r.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && (n = new fC(e), t.set(e, n)), n;
  }
}
class fC {
  constructor(e) {
    this.id = uC++, this.code = e, this.usedTimes = 0;
  }
}
function pC(i, e, t, n, s, r, a) {
  const o = new gd(), l = new dC(), c = [], h = s.isWebGL2, u = s.logarithmicDepthBuffer, d = s.vertexTextures;
  let f = s.precision;
  const m = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function g(b) {
    return b === 0 ? "uv" : `uv${b}`;
  }
  function p(b, A, D, B, X) {
    const L = B.fog, F = X.geometry, H = b.isMeshStandardMaterial ? B.environment : null, G = (b.isMeshStandardMaterial ? t : e).get(b.envMap || H), te = G && G.mapping === tl ? G.image.height : null, j = m[b.type];
    b.precision !== null && (f = s.getMaxPrecision(b.precision), f !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", f, "instead."));
    const J = F.morphAttributes.position || F.morphAttributes.normal || F.morphAttributes.color, N = J !== void 0 ? J.length : 0;
    let q = 0;
    F.morphAttributes.position !== void 0 && (q = 1), F.morphAttributes.normal !== void 0 && (q = 2), F.morphAttributes.color !== void 0 && (q = 3);
    let ge, de, be, Fe;
    if (j) {
      const tn = zn[j];
      ge = tn.vertexShader, de = tn.fragmentShader;
    } else
      ge = b.vertexShader, de = b.fragmentShader, l.update(b), be = l.getVertexShaderID(b), Fe = l.getFragmentShaderID(b);
    const ze = i.getRenderTarget(), Ne = X.isInstancedMesh === !0, Xe = !!b.map, ct = !!b.matcap, He = !!G, I = !!b.aoMap, xe = !!b.lightMap, ee = !!b.bumpMap, ce = !!b.normalMap, se = !!b.displacementMap, De = !!b.emissiveMap, Ee = !!b.metalnessMap, Re = !!b.roughnessMap, Ge = b.anisotropy > 0, nt = b.clearcoat > 0, Ct = b.iridescence > 0, P = b.sheen > 0, C = b.transmission > 0, W = Ge && !!b.anisotropyMap, he = nt && !!b.clearcoatMap, ae = nt && !!b.clearcoatNormalMap, ue = nt && !!b.clearcoatRoughnessMap, Pe = Ct && !!b.iridescenceMap, pe = Ct && !!b.iridescenceThicknessMap, we = P && !!b.sheenColorMap, O = P && !!b.sheenRoughnessMap, me = !!b.specularMap, ie = !!b.specularColorMap, Ve = !!b.specularIntensityMap, Ie = C && !!b.transmissionMap, ke = C && !!b.thicknessMap, Le = !!b.gradientMap, Ce = !!b.alphaMap, rt = b.alphaTest > 0, U = !!b.alphaHash, Me = !!b.extensions, oe = !!F.attributes.uv1, K = !!F.attributes.uv2, fe = !!F.attributes.uv3;
    let Ue = ps;
    return b.toneMapped && (ze === null || ze.isXRRenderTarget === !0) && (Ue = i.toneMapping), {
      isWebGL2: h,
      shaderID: j,
      shaderType: b.type,
      shaderName: b.name,
      vertexShader: ge,
      fragmentShader: de,
      defines: b.defines,
      customVertexShaderID: be,
      customFragmentShaderID: Fe,
      isRawShaderMaterial: b.isRawShaderMaterial === !0,
      glslVersion: b.glslVersion,
      precision: f,
      instancing: Ne,
      instancingColor: Ne && X.instanceColor !== null,
      supportsVertexTextures: d,
      outputColorSpace: ze === null ? i.outputColorSpace : ze.isXRRenderTarget === !0 ? ze.texture.colorSpace : en,
      map: Xe,
      matcap: ct,
      envMap: He,
      envMapMode: He && G.mapping,
      envMapCubeUVHeight: te,
      aoMap: I,
      lightMap: xe,
      bumpMap: ee,
      normalMap: ce,
      displacementMap: d && se,
      emissiveMap: De,
      normalMapObjectSpace: ce && b.normalMapType === px,
      normalMapTangentSpace: ce && b.normalMapType === Ur,
      metalnessMap: Ee,
      roughnessMap: Re,
      anisotropy: Ge,
      anisotropyMap: W,
      clearcoat: nt,
      clearcoatMap: he,
      clearcoatNormalMap: ae,
      clearcoatRoughnessMap: ue,
      iridescence: Ct,
      iridescenceMap: Pe,
      iridescenceThicknessMap: pe,
      sheen: P,
      sheenColorMap: we,
      sheenRoughnessMap: O,
      specularMap: me,
      specularColorMap: ie,
      specularIntensityMap: Ve,
      transmission: C,
      transmissionMap: Ie,
      thicknessMap: ke,
      gradientMap: Le,
      opaque: b.transparent === !1 && b.blending === Gi,
      alphaMap: Ce,
      alphaTest: rt,
      alphaHash: U,
      combine: b.combine,
      //
      mapUv: Xe && g(b.map.channel),
      aoMapUv: I && g(b.aoMap.channel),
      lightMapUv: xe && g(b.lightMap.channel),
      bumpMapUv: ee && g(b.bumpMap.channel),
      normalMapUv: ce && g(b.normalMap.channel),
      displacementMapUv: se && g(b.displacementMap.channel),
      emissiveMapUv: De && g(b.emissiveMap.channel),
      metalnessMapUv: Ee && g(b.metalnessMap.channel),
      roughnessMapUv: Re && g(b.roughnessMap.channel),
      anisotropyMapUv: W && g(b.anisotropyMap.channel),
      clearcoatMapUv: he && g(b.clearcoatMap.channel),
      clearcoatNormalMapUv: ae && g(b.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: ue && g(b.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Pe && g(b.iridescenceMap.channel),
      iridescenceThicknessMapUv: pe && g(b.iridescenceThicknessMap.channel),
      sheenColorMapUv: we && g(b.sheenColorMap.channel),
      sheenRoughnessMapUv: O && g(b.sheenRoughnessMap.channel),
      specularMapUv: me && g(b.specularMap.channel),
      specularColorMapUv: ie && g(b.specularColorMap.channel),
      specularIntensityMapUv: Ve && g(b.specularIntensityMap.channel),
      transmissionMapUv: Ie && g(b.transmissionMap.channel),
      thicknessMapUv: ke && g(b.thicknessMap.channel),
      alphaMapUv: Ce && g(b.alphaMap.channel),
      //
      vertexTangents: !!F.attributes.tangent && (ce || Ge),
      vertexColors: b.vertexColors,
      vertexAlphas: b.vertexColors === !0 && !!F.attributes.color && F.attributes.color.itemSize === 4,
      vertexUv1s: oe,
      vertexUv2s: K,
      vertexUv3s: fe,
      pointsUvs: X.isPoints === !0 && !!F.attributes.uv && (Xe || Ce),
      fog: !!L,
      useFog: b.fog === !0,
      fogExp2: L && L.isFogExp2,
      flatShading: b.flatShading === !0,
      sizeAttenuation: b.sizeAttenuation === !0,
      logarithmicDepthBuffer: u,
      skinning: X.isSkinnedMesh === !0,
      morphTargets: F.morphAttributes.position !== void 0,
      morphNormals: F.morphAttributes.normal !== void 0,
      morphColors: F.morphAttributes.color !== void 0,
      morphTargetsCount: N,
      morphTextureStride: q,
      numDirLights: A.directional.length,
      numPointLights: A.point.length,
      numSpotLights: A.spot.length,
      numSpotLightMaps: A.spotLightMap.length,
      numRectAreaLights: A.rectArea.length,
      numHemiLights: A.hemi.length,
      numDirLightShadows: A.directionalShadowMap.length,
      numPointLightShadows: A.pointShadowMap.length,
      numSpotLightShadows: A.spotShadowMap.length,
      numSpotLightShadowsWithMaps: A.numSpotLightShadowsWithMaps,
      numLightProbes: A.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: b.dithering,
      shadowMapEnabled: i.shadowMap.enabled && D.length > 0,
      shadowMapType: i.shadowMap.type,
      toneMapping: Ue,
      useLegacyLights: i._useLegacyLights,
      decodeVideoTexture: Xe && b.map.isVideoTexture === !0 && gt.getTransfer(b.map.colorSpace) === Mt,
      premultipliedAlpha: b.premultipliedAlpha,
      doubleSided: b.side === $t,
      flipSided: b.side === Wn,
      useDepthPacking: b.depthPacking >= 0,
      depthPacking: b.depthPacking || 0,
      index0AttributeName: b.index0AttributeName,
      extensionDerivatives: Me && b.extensions.derivatives === !0,
      extensionFragDepth: Me && b.extensions.fragDepth === !0,
      extensionDrawBuffers: Me && b.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: Me && b.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: h || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: h || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: h || n.has("EXT_shader_texture_lod"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: b.customProgramCacheKey()
    };
  }
  function v(b) {
    const A = [];
    if (b.shaderID ? A.push(b.shaderID) : (A.push(b.customVertexShaderID), A.push(b.customFragmentShaderID)), b.defines !== void 0)
      for (const D in b.defines)
        A.push(D), A.push(b.defines[D]);
    return b.isRawShaderMaterial === !1 && (y(A, b), _(A, b), A.push(i.outputColorSpace)), A.push(b.customProgramCacheKey), A.join();
  }
  function y(b, A) {
    b.push(A.precision), b.push(A.outputColorSpace), b.push(A.envMapMode), b.push(A.envMapCubeUVHeight), b.push(A.mapUv), b.push(A.alphaMapUv), b.push(A.lightMapUv), b.push(A.aoMapUv), b.push(A.bumpMapUv), b.push(A.normalMapUv), b.push(A.displacementMapUv), b.push(A.emissiveMapUv), b.push(A.metalnessMapUv), b.push(A.roughnessMapUv), b.push(A.anisotropyMapUv), b.push(A.clearcoatMapUv), b.push(A.clearcoatNormalMapUv), b.push(A.clearcoatRoughnessMapUv), b.push(A.iridescenceMapUv), b.push(A.iridescenceThicknessMapUv), b.push(A.sheenColorMapUv), b.push(A.sheenRoughnessMapUv), b.push(A.specularMapUv), b.push(A.specularColorMapUv), b.push(A.specularIntensityMapUv), b.push(A.transmissionMapUv), b.push(A.thicknessMapUv), b.push(A.combine), b.push(A.fogExp2), b.push(A.sizeAttenuation), b.push(A.morphTargetsCount), b.push(A.morphAttributeCount), b.push(A.numDirLights), b.push(A.numPointLights), b.push(A.numSpotLights), b.push(A.numSpotLightMaps), b.push(A.numHemiLights), b.push(A.numRectAreaLights), b.push(A.numDirLightShadows), b.push(A.numPointLightShadows), b.push(A.numSpotLightShadows), b.push(A.numSpotLightShadowsWithMaps), b.push(A.numLightProbes), b.push(A.shadowMapType), b.push(A.toneMapping), b.push(A.numClippingPlanes), b.push(A.numClipIntersection), b.push(A.depthPacking);
  }
  function _(b, A) {
    o.disableAll(), A.isWebGL2 && o.enable(0), A.supportsVertexTextures && o.enable(1), A.instancing && o.enable(2), A.instancingColor && o.enable(3), A.matcap && o.enable(4), A.envMap && o.enable(5), A.normalMapObjectSpace && o.enable(6), A.normalMapTangentSpace && o.enable(7), A.clearcoat && o.enable(8), A.iridescence && o.enable(9), A.alphaTest && o.enable(10), A.vertexColors && o.enable(11), A.vertexAlphas && o.enable(12), A.vertexUv1s && o.enable(13), A.vertexUv2s && o.enable(14), A.vertexUv3s && o.enable(15), A.vertexTangents && o.enable(16), A.anisotropy && o.enable(17), A.alphaHash && o.enable(18), b.push(o.mask), o.disableAll(), A.fog && o.enable(0), A.useFog && o.enable(1), A.flatShading && o.enable(2), A.logarithmicDepthBuffer && o.enable(3), A.skinning && o.enable(4), A.morphTargets && o.enable(5), A.morphNormals && o.enable(6), A.morphColors && o.enable(7), A.premultipliedAlpha && o.enable(8), A.shadowMapEnabled && o.enable(9), A.useLegacyLights && o.enable(10), A.doubleSided && o.enable(11), A.flipSided && o.enable(12), A.useDepthPacking && o.enable(13), A.dithering && o.enable(14), A.transmission && o.enable(15), A.sheen && o.enable(16), A.opaque && o.enable(17), A.pointsUvs && o.enable(18), A.decodeVideoTexture && o.enable(19), b.push(o.mask);
  }
  function x(b) {
    const A = m[b.type];
    let D;
    if (A) {
      const B = zn[A];
      D = cn.clone(B.uniforms);
    } else
      D = b.uniforms;
    return D;
  }
  function M(b, A) {
    let D;
    for (let B = 0, X = c.length; B < X; B++) {
      const L = c[B];
      if (L.cacheKey === A) {
        D = L, ++D.usedTimes;
        break;
      }
    }
    return D === void 0 && (D = new hC(i, A, b, r), c.push(D)), D;
  }
  function S(b) {
    if (--b.usedTimes === 0) {
      const A = c.indexOf(b);
      c[A] = c[c.length - 1], c.pop(), b.destroy();
    }
  }
  function w(b) {
    l.remove(b);
  }
  function E() {
    l.dispose();
  }
  return {
    getParameters: p,
    getProgramCacheKey: v,
    getUniforms: x,
    acquireProgram: M,
    releaseProgram: S,
    releaseShaderCache: w,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: c,
    dispose: E
  };
}
function mC() {
  let i = /* @__PURE__ */ new WeakMap();
  function e(r) {
    let a = i.get(r);
    return a === void 0 && (a = {}, i.set(r, a)), a;
  }
  function t(r) {
    i.delete(r);
  }
  function n(r, a, o) {
    i.get(r)[a] = o;
  }
  function s() {
    i = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: n,
    dispose: s
  };
}
function gC(i, e) {
  return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.material.id !== e.material.id ? i.material.id - e.material.id : i.z !== e.z ? i.z - e.z : i.id - e.id;
}
function J0(i, e) {
  return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? e.z - i.z : i.id - e.id;
}
function ev() {
  const i = [];
  let e = 0;
  const t = [], n = [], s = [];
  function r() {
    e = 0, t.length = 0, n.length = 0, s.length = 0;
  }
  function a(u, d, f, m, g, p) {
    let v = i[e];
    return v === void 0 ? (v = {
      id: u.id,
      object: u,
      geometry: d,
      material: f,
      groupOrder: m,
      renderOrder: u.renderOrder,
      z: g,
      group: p
    }, i[e] = v) : (v.id = u.id, v.object = u, v.geometry = d, v.material = f, v.groupOrder = m, v.renderOrder = u.renderOrder, v.z = g, v.group = p), e++, v;
  }
  function o(u, d, f, m, g, p) {
    const v = a(u, d, f, m, g, p);
    f.transmission > 0 ? n.push(v) : f.transparent === !0 ? s.push(v) : t.push(v);
  }
  function l(u, d, f, m, g, p) {
    const v = a(u, d, f, m, g, p);
    f.transmission > 0 ? n.unshift(v) : f.transparent === !0 ? s.unshift(v) : t.unshift(v);
  }
  function c(u, d) {
    t.length > 1 && t.sort(u || gC), n.length > 1 && n.sort(d || J0), s.length > 1 && s.sort(d || J0);
  }
  function h() {
    for (let u = e, d = i.length; u < d; u++) {
      const f = i[u];
      if (f.id === null) break;
      f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: s,
    init: r,
    push: o,
    unshift: l,
    finish: h,
    sort: c
  };
}
function vC() {
  let i = /* @__PURE__ */ new WeakMap();
  function e(n, s) {
    const r = i.get(n);
    let a;
    return r === void 0 ? (a = new ev(), i.set(n, [a])) : s >= r.length ? (a = new ev(), r.push(a)) : a = r[s], a;
  }
  function t() {
    i = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function _C() {
  const i = {};
  return {
    get: function(e) {
      if (i[e.id] !== void 0)
        return i[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new T(),
            color: new Q()
          };
          break;
        case "SpotLight":
          t = {
            position: new T(),
            direction: new T(),
            color: new Q(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new T(),
            color: new Q(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new T(),
            skyColor: new Q(),
            groundColor: new Q()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new Q(),
            position: new T(),
            halfWidth: new T(),
            halfHeight: new T()
          };
          break;
      }
      return i[e.id] = t, t;
    }
  };
}
function yC() {
  const i = {};
  return {
    get: function(e) {
      if (i[e.id] !== void 0)
        return i[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new k()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new k()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new k(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return i[e.id] = t, t;
    }
  };
}
let xC = 0;
function MC(i, e) {
  return (e.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (i.map ? 1 : 0);
}
function bC(i, e) {
  const t = new _C(), n = yC(), s = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let h = 0; h < 9; h++) s.probe.push(new T());
  const r = new T(), a = new _e(), o = new _e();
  function l(h, u) {
    let d = 0, f = 0, m = 0;
    for (let B = 0; B < 9; B++) s.probe[B].set(0, 0, 0);
    let g = 0, p = 0, v = 0, y = 0, _ = 0, x = 0, M = 0, S = 0, w = 0, E = 0, b = 0;
    h.sort(MC);
    const A = u === !0 ? Math.PI : 1;
    for (let B = 0, X = h.length; B < X; B++) {
      const L = h[B], F = L.color, H = L.intensity, G = L.distance, te = L.shadow && L.shadow.map ? L.shadow.map.texture : null;
      if (L.isAmbientLight)
        d += F.r * H * A, f += F.g * H * A, m += F.b * H * A;
      else if (L.isLightProbe) {
        for (let j = 0; j < 9; j++)
          s.probe[j].addScaledVector(L.sh.coefficients[j], H);
        b++;
      } else if (L.isDirectionalLight) {
        const j = t.get(L);
        if (j.color.copy(L.color).multiplyScalar(L.intensity * A), L.castShadow) {
          const J = L.shadow, N = n.get(L);
          N.shadowBias = J.bias, N.shadowNormalBias = J.normalBias, N.shadowRadius = J.radius, N.shadowMapSize = J.mapSize, s.directionalShadow[g] = N, s.directionalShadowMap[g] = te, s.directionalShadowMatrix[g] = L.shadow.matrix, x++;
        }
        s.directional[g] = j, g++;
      } else if (L.isSpotLight) {
        const j = t.get(L);
        j.position.setFromMatrixPosition(L.matrixWorld), j.color.copy(F).multiplyScalar(H * A), j.distance = G, j.coneCos = Math.cos(L.angle), j.penumbraCos = Math.cos(L.angle * (1 - L.penumbra)), j.decay = L.decay, s.spot[v] = j;
        const J = L.shadow;
        if (L.map && (s.spotLightMap[w] = L.map, w++, J.updateMatrices(L), L.castShadow && E++), s.spotLightMatrix[v] = J.matrix, L.castShadow) {
          const N = n.get(L);
          N.shadowBias = J.bias, N.shadowNormalBias = J.normalBias, N.shadowRadius = J.radius, N.shadowMapSize = J.mapSize, s.spotShadow[v] = N, s.spotShadowMap[v] = te, S++;
        }
        v++;
      } else if (L.isRectAreaLight) {
        const j = t.get(L);
        j.color.copy(F).multiplyScalar(H), j.halfWidth.set(L.width * 0.5, 0, 0), j.halfHeight.set(0, L.height * 0.5, 0), s.rectArea[y] = j, y++;
      } else if (L.isPointLight) {
        const j = t.get(L);
        if (j.color.copy(L.color).multiplyScalar(L.intensity * A), j.distance = L.distance, j.decay = L.decay, L.castShadow) {
          const J = L.shadow, N = n.get(L);
          N.shadowBias = J.bias, N.shadowNormalBias = J.normalBias, N.shadowRadius = J.radius, N.shadowMapSize = J.mapSize, N.shadowCameraNear = J.camera.near, N.shadowCameraFar = J.camera.far, s.pointShadow[p] = N, s.pointShadowMap[p] = te, s.pointShadowMatrix[p] = L.shadow.matrix, M++;
        }
        s.point[p] = j, p++;
      } else if (L.isHemisphereLight) {
        const j = t.get(L);
        j.skyColor.copy(L.color).multiplyScalar(H * A), j.groundColor.copy(L.groundColor).multiplyScalar(H * A), s.hemi[_] = j, _++;
      }
    }
    y > 0 && (e.isWebGL2 || i.has("OES_texture_float_linear") === !0 ? (s.rectAreaLTC1 = ve.LTC_FLOAT_1, s.rectAreaLTC2 = ve.LTC_FLOAT_2) : i.has("OES_texture_half_float_linear") === !0 ? (s.rectAreaLTC1 = ve.LTC_HALF_1, s.rectAreaLTC2 = ve.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), s.ambient[0] = d, s.ambient[1] = f, s.ambient[2] = m;
    const D = s.hash;
    (D.directionalLength !== g || D.pointLength !== p || D.spotLength !== v || D.rectAreaLength !== y || D.hemiLength !== _ || D.numDirectionalShadows !== x || D.numPointShadows !== M || D.numSpotShadows !== S || D.numSpotMaps !== w || D.numLightProbes !== b) && (s.directional.length = g, s.spot.length = v, s.rectArea.length = y, s.point.length = p, s.hemi.length = _, s.directionalShadow.length = x, s.directionalShadowMap.length = x, s.pointShadow.length = M, s.pointShadowMap.length = M, s.spotShadow.length = S, s.spotShadowMap.length = S, s.directionalShadowMatrix.length = x, s.pointShadowMatrix.length = M, s.spotLightMatrix.length = S + w - E, s.spotLightMap.length = w, s.numSpotLightShadowsWithMaps = E, s.numLightProbes = b, D.directionalLength = g, D.pointLength = p, D.spotLength = v, D.rectAreaLength = y, D.hemiLength = _, D.numDirectionalShadows = x, D.numPointShadows = M, D.numSpotShadows = S, D.numSpotMaps = w, D.numLightProbes = b, s.version = xC++);
  }
  function c(h, u) {
    let d = 0, f = 0, m = 0, g = 0, p = 0;
    const v = u.matrixWorldInverse;
    for (let y = 0, _ = h.length; y < _; y++) {
      const x = h[y];
      if (x.isDirectionalLight) {
        const M = s.directional[d];
        M.direction.setFromMatrixPosition(x.matrixWorld), r.setFromMatrixPosition(x.target.matrixWorld), M.direction.sub(r), M.direction.transformDirection(v), d++;
      } else if (x.isSpotLight) {
        const M = s.spot[m];
        M.position.setFromMatrixPosition(x.matrixWorld), M.position.applyMatrix4(v), M.direction.setFromMatrixPosition(x.matrixWorld), r.setFromMatrixPosition(x.target.matrixWorld), M.direction.sub(r), M.direction.transformDirection(v), m++;
      } else if (x.isRectAreaLight) {
        const M = s.rectArea[g];
        M.position.setFromMatrixPosition(x.matrixWorld), M.position.applyMatrix4(v), o.identity(), a.copy(x.matrixWorld), a.premultiply(v), o.extractRotation(a), M.halfWidth.set(x.width * 0.5, 0, 0), M.halfHeight.set(0, x.height * 0.5, 0), M.halfWidth.applyMatrix4(o), M.halfHeight.applyMatrix4(o), g++;
      } else if (x.isPointLight) {
        const M = s.point[f];
        M.position.setFromMatrixPosition(x.matrixWorld), M.position.applyMatrix4(v), f++;
      } else if (x.isHemisphereLight) {
        const M = s.hemi[p];
        M.direction.setFromMatrixPosition(x.matrixWorld), M.direction.transformDirection(v), p++;
      }
    }
  }
  return {
    setup: l,
    setupView: c,
    state: s
  };
}
function tv(i, e) {
  const t = new bC(i, e), n = [], s = [];
  function r() {
    n.length = 0, s.length = 0;
  }
  function a(u) {
    n.push(u);
  }
  function o(u) {
    s.push(u);
  }
  function l(u) {
    t.setup(n, u);
  }
  function c(u) {
    t.setupView(n, u);
  }
  return {
    init: r,
    state: {
      lightsArray: n,
      shadowsArray: s,
      lights: t
    },
    setupLights: l,
    setupLightsView: c,
    pushLight: a,
    pushShadow: o
  };
}
function SC(i, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function n(r, a = 0) {
    const o = t.get(r);
    let l;
    return o === void 0 ? (l = new tv(i, e), t.set(r, [l])) : a >= o.length ? (l = new tv(i, e), o.push(l)) : l = o[a], l;
  }
  function s() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: s
  };
}
class Md extends Qt {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = fx, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class jm extends Qt {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const wC = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, TC = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function EC(i, e, t) {
  let n = new yd();
  const s = new k(), r = new k(), a = new tt(), o = new Md({ depthPacking: Gm }), l = new jm(), c = {}, h = t.maxTextureSize, u = { [Wi]: Wn, [Wn]: Wi, [$t]: $t }, d = new mt({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new k() },
      radius: { value: 4 }
    },
    vertexShader: wC,
    fragmentShader: TC
  }), f = d.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const m = new Be();
  m.setAttribute(
    "position",
    new dt(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const g = new le(m, d), p = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = nd;
  let v = this.type;
  this.render = function(M, S, w) {
    if (p.enabled === !1 || p.autoUpdate === !1 && p.needsUpdate === !1 || M.length === 0) return;
    const E = i.getRenderTarget(), b = i.getActiveCubeFace(), A = i.getActiveMipmapLevel(), D = i.state;
    D.setBlending(vt), D.buffers.color.setClear(1, 1, 1, 1), D.buffers.depth.setTest(!0), D.setScissorTest(!1);
    const B = v !== zi && this.type === zi, X = v === zi && this.type !== zi;
    for (let L = 0, F = M.length; L < F; L++) {
      const H = M[L], G = H.shadow;
      if (G === void 0) {
        console.warn("THREE.WebGLShadowMap:", H, "has no shadow.");
        continue;
      }
      if (G.autoUpdate === !1 && G.needsUpdate === !1) continue;
      s.copy(G.mapSize);
      const te = G.getFrameExtents();
      if (s.multiply(te), r.copy(G.mapSize), (s.x > h || s.y > h) && (s.x > h && (r.x = Math.floor(h / te.x), s.x = r.x * te.x, G.mapSize.x = r.x), s.y > h && (r.y = Math.floor(h / te.y), s.y = r.y * te.y, G.mapSize.y = r.y)), G.map === null || B === !0 || X === !0) {
        const J = this.type !== zi ? { minFilter: lt, magFilter: lt } : {};
        G.map !== null && G.map.dispose(), G.map = new xt(s.x, s.y, J), G.map.texture.name = H.name + ".shadowMap", G.camera.updateProjectionMatrix();
      }
      i.setRenderTarget(G.map), i.clear();
      const j = G.getViewportCount();
      for (let J = 0; J < j; J++) {
        const N = G.getViewport(J);
        a.set(
          r.x * N.x,
          r.y * N.y,
          r.x * N.z,
          r.y * N.w
        ), D.viewport(a), G.updateMatrices(H, J), n = G.getFrustum(), x(S, w, G.camera, H, this.type);
      }
      G.isPointLightShadow !== !0 && this.type === zi && y(G, w), G.needsUpdate = !1;
    }
    v = this.type, p.needsUpdate = !1, i.setRenderTarget(E, b, A);
  };
  function y(M, S) {
    const w = e.update(g);
    d.defines.VSM_SAMPLES !== M.blurSamples && (d.defines.VSM_SAMPLES = M.blurSamples, f.defines.VSM_SAMPLES = M.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0), M.mapPass === null && (M.mapPass = new xt(s.x, s.y)), d.uniforms.shadow_pass.value = M.map.texture, d.uniforms.resolution.value = M.mapSize, d.uniforms.radius.value = M.radius, i.setRenderTarget(M.mapPass), i.clear(), i.renderBufferDirect(S, null, w, d, g, null), f.uniforms.shadow_pass.value = M.mapPass.texture, f.uniforms.resolution.value = M.mapSize, f.uniforms.radius.value = M.radius, i.setRenderTarget(M.map), i.clear(), i.renderBufferDirect(S, null, w, f, g, null);
  }
  function _(M, S, w, E) {
    let b = null;
    const A = w.isPointLight === !0 ? M.customDistanceMaterial : M.customDepthMaterial;
    if (A !== void 0)
      b = A;
    else if (b = w.isPointLight === !0 ? l : o, i.localClippingEnabled && S.clipShadows === !0 && Array.isArray(S.clippingPlanes) && S.clippingPlanes.length !== 0 || S.displacementMap && S.displacementScale !== 0 || S.alphaMap && S.alphaTest > 0 || S.map && S.alphaTest > 0) {
      const D = b.uuid, B = S.uuid;
      let X = c[D];
      X === void 0 && (X = {}, c[D] = X);
      let L = X[B];
      L === void 0 && (L = b.clone(), X[B] = L), b = L;
    }
    if (b.visible = S.visible, b.wireframe = S.wireframe, E === zi ? b.side = S.shadowSide !== null ? S.shadowSide : S.side : b.side = S.shadowSide !== null ? S.shadowSide : u[S.side], b.alphaMap = S.alphaMap, b.alphaTest = S.alphaTest, b.map = S.map, b.clipShadows = S.clipShadows, b.clippingPlanes = S.clippingPlanes, b.clipIntersection = S.clipIntersection, b.displacementMap = S.displacementMap, b.displacementScale = S.displacementScale, b.displacementBias = S.displacementBias, b.wireframeLinewidth = S.wireframeLinewidth, b.linewidth = S.linewidth, w.isPointLight === !0 && b.isMeshDistanceMaterial === !0) {
      const D = i.properties.get(b);
      D.light = w;
    }
    return b;
  }
  function x(M, S, w, E, b) {
    if (M.visible === !1) return;
    if (M.layers.test(S.layers) && (M.isMesh || M.isLine || M.isPoints) && (M.castShadow || M.receiveShadow && b === zi) && (!M.frustumCulled || n.intersectsObject(M))) {
      M.modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, M.matrixWorld);
      const B = e.update(M), X = M.material;
      if (Array.isArray(X)) {
        const L = B.groups;
        for (let F = 0, H = L.length; F < H; F++) {
          const G = L[F], te = X[G.materialIndex];
          if (te && te.visible) {
            const j = _(M, te, E, b);
            i.renderBufferDirect(w, null, B, j, M, G);
          }
        }
      } else if (X.visible) {
        const L = _(M, X, E, b);
        i.renderBufferDirect(w, null, B, L, M, null);
      }
    }
    const D = M.children;
    for (let B = 0, X = D.length; B < X; B++)
      x(D[B], S, w, E, b);
  }
}
function AC(i, e, t) {
  const n = t.isWebGL2;
  function s() {
    let U = !1;
    const Me = new tt();
    let oe = null;
    const K = new tt(0, 0, 0, 0);
    return {
      setMask: function(fe) {
        oe !== fe && !U && (i.colorMask(fe, fe, fe, fe), oe = fe);
      },
      setLocked: function(fe) {
        U = fe;
      },
      setClear: function(fe, Ue, at, tn, Ti) {
        Ti === !0 && (fe *= tn, Ue *= tn, at *= tn), Me.set(fe, Ue, at, tn), K.equals(Me) === !1 && (i.clearColor(fe, Ue, at, tn), K.copy(Me));
      },
      reset: function() {
        U = !1, oe = null, K.set(-1, 0, 0, 0);
      }
    };
  }
  function r() {
    let U = !1, Me = null, oe = null, K = null;
    return {
      setTest: function(fe) {
        fe ? Xe(i.DEPTH_TEST) : ct(i.DEPTH_TEST);
      },
      setMask: function(fe) {
        Me !== fe && !U && (i.depthMask(fe), Me = fe);
      },
      setFunc: function(fe) {
        if (oe !== fe) {
          switch (fe) {
            case Xy:
              i.depthFunc(i.NEVER);
              break;
            case qy:
              i.depthFunc(i.ALWAYS);
              break;
            case Yy:
              i.depthFunc(i.LESS);
              break;
            case nc:
              i.depthFunc(i.LEQUAL);
              break;
            case jy:
              i.depthFunc(i.EQUAL);
              break;
            case Zy:
              i.depthFunc(i.GEQUAL);
              break;
            case $y:
              i.depthFunc(i.GREATER);
              break;
            case Ky:
              i.depthFunc(i.NOTEQUAL);
              break;
            default:
              i.depthFunc(i.LEQUAL);
          }
          oe = fe;
        }
      },
      setLocked: function(fe) {
        U = fe;
      },
      setClear: function(fe) {
        K !== fe && (i.clearDepth(fe), K = fe);
      },
      reset: function() {
        U = !1, Me = null, oe = null, K = null;
      }
    };
  }
  function a() {
    let U = !1, Me = null, oe = null, K = null, fe = null, Ue = null, at = null, tn = null, Ti = null;
    return {
      setTest: function(wt) {
        U || (wt ? Xe(i.STENCIL_TEST) : ct(i.STENCIL_TEST));
      },
      setMask: function(wt) {
        Me !== wt && !U && (i.stencilMask(wt), Me = wt);
      },
      setFunc: function(wt, On, Zi) {
        (oe !== wt || K !== On || fe !== Zi) && (i.stencilFunc(wt, On, Zi), oe = wt, K = On, fe = Zi);
      },
      setOp: function(wt, On, Zi) {
        (Ue !== wt || at !== On || tn !== Zi) && (i.stencilOp(wt, On, Zi), Ue = wt, at = On, tn = Zi);
      },
      setLocked: function(wt) {
        U = wt;
      },
      setClear: function(wt) {
        Ti !== wt && (i.clearStencil(wt), Ti = wt);
      },
      reset: function() {
        U = !1, Me = null, oe = null, K = null, fe = null, Ue = null, at = null, tn = null, Ti = null;
      }
    };
  }
  const o = new s(), l = new r(), c = new a(), h = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
  let d = {}, f = {}, m = /* @__PURE__ */ new WeakMap(), g = [], p = null, v = !1, y = null, _ = null, x = null, M = null, S = null, w = null, E = null, b = new Q(0, 0, 0), A = 0, D = !1, B = null, X = null, L = null, F = null, H = null;
  const G = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let te = !1, j = 0;
  const J = i.getParameter(i.VERSION);
  J.indexOf("WebGL") !== -1 ? (j = parseFloat(/^WebGL (\d)/.exec(J)[1]), te = j >= 1) : J.indexOf("OpenGL ES") !== -1 && (j = parseFloat(/^OpenGL ES (\d)/.exec(J)[1]), te = j >= 2);
  let N = null, q = {};
  const ge = i.getParameter(i.SCISSOR_BOX), de = i.getParameter(i.VIEWPORT), be = new tt().fromArray(ge), Fe = new tt().fromArray(de);
  function ze(U, Me, oe, K) {
    const fe = new Uint8Array(4), Ue = i.createTexture();
    i.bindTexture(U, Ue), i.texParameteri(U, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(U, i.TEXTURE_MAG_FILTER, i.NEAREST);
    for (let at = 0; at < oe; at++)
      n && (U === i.TEXTURE_3D || U === i.TEXTURE_2D_ARRAY) ? i.texImage3D(Me, 0, i.RGBA, 1, 1, K, 0, i.RGBA, i.UNSIGNED_BYTE, fe) : i.texImage2D(Me + at, 0, i.RGBA, 1, 1, 0, i.RGBA, i.UNSIGNED_BYTE, fe);
    return Ue;
  }
  const Ne = {};
  Ne[i.TEXTURE_2D] = ze(i.TEXTURE_2D, i.TEXTURE_2D, 1), Ne[i.TEXTURE_CUBE_MAP] = ze(i.TEXTURE_CUBE_MAP, i.TEXTURE_CUBE_MAP_POSITIVE_X, 6), n && (Ne[i.TEXTURE_2D_ARRAY] = ze(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1), Ne[i.TEXTURE_3D] = ze(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1)), o.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), Xe(i.DEPTH_TEST), l.setFunc(nc), Ee(!1), Re(op), Xe(i.CULL_FACE), se(vt);
  function Xe(U) {
    d[U] !== !0 && (i.enable(U), d[U] = !0);
  }
  function ct(U) {
    d[U] !== !1 && (i.disable(U), d[U] = !1);
  }
  function He(U, Me) {
    return f[U] !== Me ? (i.bindFramebuffer(U, Me), f[U] = Me, n && (U === i.DRAW_FRAMEBUFFER && (f[i.FRAMEBUFFER] = Me), U === i.FRAMEBUFFER && (f[i.DRAW_FRAMEBUFFER] = Me)), !0) : !1;
  }
  function I(U, Me) {
    let oe = g, K = !1;
    if (U)
      if (oe = m.get(Me), oe === void 0 && (oe = [], m.set(Me, oe)), U.isWebGLMultipleRenderTargets) {
        const fe = U.texture;
        if (oe.length !== fe.length || oe[0] !== i.COLOR_ATTACHMENT0) {
          for (let Ue = 0, at = fe.length; Ue < at; Ue++)
            oe[Ue] = i.COLOR_ATTACHMENT0 + Ue;
          oe.length = fe.length, K = !0;
        }
      } else
        oe[0] !== i.COLOR_ATTACHMENT0 && (oe[0] = i.COLOR_ATTACHMENT0, K = !0);
    else
      oe[0] !== i.BACK && (oe[0] = i.BACK, K = !0);
    K && (t.isWebGL2 ? i.drawBuffers(oe) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(oe));
  }
  function xe(U) {
    return p !== U ? (i.useProgram(U), p = U, !0) : !1;
  }
  const ee = {
    [mi]: i.FUNC_ADD,
    [Cm]: i.FUNC_SUBTRACT,
    [Rm]: i.FUNC_REVERSE_SUBTRACT
  };
  if (n)
    ee[Au] = i.MIN, ee[Cu] = i.MAX;
  else {
    const U = e.get("EXT_blend_minmax");
    U !== null && (ee[Au] = U.MIN_EXT, ee[Cu] = U.MAX_EXT);
  }
  const ce = {
    [Bo]: i.ZERO,
    [Lc]: i.ONE,
    [id]: i.SRC_COLOR,
    [Sr]: i.SRC_ALPHA,
    [Pm]: i.SRC_ALPHA_SATURATE,
    [Dc]: i.DST_COLOR,
    [Ic]: i.DST_ALPHA,
    [sd]: i.ONE_MINUS_SRC_COLOR,
    [wr]: i.ONE_MINUS_SRC_ALPHA,
    [ad]: i.ONE_MINUS_DST_COLOR,
    [rd]: i.ONE_MINUS_DST_ALPHA,
    [Hy]: i.CONSTANT_COLOR,
    [Gy]: i.ONE_MINUS_CONSTANT_COLOR,
    [Vy]: i.CONSTANT_ALPHA,
    [Wy]: i.ONE_MINUS_CONSTANT_ALPHA
  };
  function se(U, Me, oe, K, fe, Ue, at, tn, Ti, wt) {
    if (U === vt) {
      v === !0 && (ct(i.BLEND), v = !1);
      return;
    }
    if (v === !1 && (Xe(i.BLEND), v = !0), U !== Fo) {
      if (U !== y || wt !== D) {
        if ((_ !== mi || S !== mi) && (i.blendEquation(i.FUNC_ADD), _ = mi, S = mi), wt)
          switch (U) {
            case Gi:
              i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
              break;
            case Ta:
              i.blendFunc(i.ONE, i.ONE);
              break;
            case Tu:
              i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
              break;
            case Eu:
              i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", U);
              break;
          }
        else
          switch (U) {
            case Gi:
              i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
              break;
            case Ta:
              i.blendFunc(i.SRC_ALPHA, i.ONE);
              break;
            case Tu:
              i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
              break;
            case Eu:
              i.blendFunc(i.ZERO, i.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", U);
              break;
          }
        x = null, M = null, w = null, E = null, b.set(0, 0, 0), A = 0, y = U, D = wt;
      }
      return;
    }
    fe = fe || Me, Ue = Ue || oe, at = at || K, (Me !== _ || fe !== S) && (i.blendEquationSeparate(ee[Me], ee[fe]), _ = Me, S = fe), (oe !== x || K !== M || Ue !== w || at !== E) && (i.blendFuncSeparate(ce[oe], ce[K], ce[Ue], ce[at]), x = oe, M = K, w = Ue, E = at), (tn.equals(b) === !1 || Ti !== A) && (i.blendColor(tn.r, tn.g, tn.b, Ti), b.copy(tn), A = Ti), y = U, D = !1;
  }
  function De(U, Me) {
    U.side === $t ? ct(i.CULL_FACE) : Xe(i.CULL_FACE);
    let oe = U.side === Wn;
    Me && (oe = !oe), Ee(oe), U.blending === Gi && U.transparent === !1 ? se(vt) : se(U.blending, U.blendEquation, U.blendSrc, U.blendDst, U.blendEquationAlpha, U.blendSrcAlpha, U.blendDstAlpha, U.blendColor, U.blendAlpha, U.premultipliedAlpha), l.setFunc(U.depthFunc), l.setTest(U.depthTest), l.setMask(U.depthWrite), o.setMask(U.colorWrite);
    const K = U.stencilWrite;
    c.setTest(K), K && (c.setMask(U.stencilWriteMask), c.setFunc(U.stencilFunc, U.stencilRef, U.stencilFuncMask), c.setOp(U.stencilFail, U.stencilZFail, U.stencilZPass)), nt(U.polygonOffset, U.polygonOffsetFactor, U.polygonOffsetUnits), U.alphaToCoverage === !0 ? Xe(i.SAMPLE_ALPHA_TO_COVERAGE) : ct(i.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Ee(U) {
    B !== U && (U ? i.frontFace(i.CW) : i.frontFace(i.CCW), B = U);
  }
  function Re(U) {
    U !== By ? (Xe(i.CULL_FACE), U !== X && (U === op ? i.cullFace(i.BACK) : U === ky ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : ct(i.CULL_FACE), X = U;
  }
  function Ge(U) {
    U !== L && (te && i.lineWidth(U), L = U);
  }
  function nt(U, Me, oe) {
    U ? (Xe(i.POLYGON_OFFSET_FILL), (F !== Me || H !== oe) && (i.polygonOffset(Me, oe), F = Me, H = oe)) : ct(i.POLYGON_OFFSET_FILL);
  }
  function Ct(U) {
    U ? Xe(i.SCISSOR_TEST) : ct(i.SCISSOR_TEST);
  }
  function P(U) {
    U === void 0 && (U = i.TEXTURE0 + G - 1), N !== U && (i.activeTexture(U), N = U);
  }
  function C(U, Me, oe) {
    oe === void 0 && (N === null ? oe = i.TEXTURE0 + G - 1 : oe = N);
    let K = q[oe];
    K === void 0 && (K = { type: void 0, texture: void 0 }, q[oe] = K), (K.type !== U || K.texture !== Me) && (N !== oe && (i.activeTexture(oe), N = oe), i.bindTexture(U, Me || Ne[U]), K.type = U, K.texture = Me);
  }
  function W() {
    const U = q[N];
    U !== void 0 && U.type !== void 0 && (i.bindTexture(U.type, null), U.type = void 0, U.texture = void 0);
  }
  function he() {
    try {
      i.compressedTexImage2D.apply(i, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function ae() {
    try {
      i.compressedTexImage3D.apply(i, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function ue() {
    try {
      i.texSubImage2D.apply(i, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function Pe() {
    try {
      i.texSubImage3D.apply(i, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function pe() {
    try {
      i.compressedTexSubImage2D.apply(i, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function we() {
    try {
      i.compressedTexSubImage3D.apply(i, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function O() {
    try {
      i.texStorage2D.apply(i, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function me() {
    try {
      i.texStorage3D.apply(i, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function ie() {
    try {
      i.texImage2D.apply(i, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function Ve() {
    try {
      i.texImage3D.apply(i, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function Ie(U) {
    be.equals(U) === !1 && (i.scissor(U.x, U.y, U.z, U.w), be.copy(U));
  }
  function ke(U) {
    Fe.equals(U) === !1 && (i.viewport(U.x, U.y, U.z, U.w), Fe.copy(U));
  }
  function Le(U, Me) {
    let oe = u.get(Me);
    oe === void 0 && (oe = /* @__PURE__ */ new WeakMap(), u.set(Me, oe));
    let K = oe.get(U);
    K === void 0 && (K = i.getUniformBlockIndex(Me, U.name), oe.set(U, K));
  }
  function Ce(U, Me) {
    const K = u.get(Me).get(U);
    h.get(Me) !== K && (i.uniformBlockBinding(Me, K, U.__bindingPointIndex), h.set(Me, K));
  }
  function rt() {
    i.disable(i.BLEND), i.disable(i.CULL_FACE), i.disable(i.DEPTH_TEST), i.disable(i.POLYGON_OFFSET_FILL), i.disable(i.SCISSOR_TEST), i.disable(i.STENCIL_TEST), i.disable(i.SAMPLE_ALPHA_TO_COVERAGE), i.blendEquation(i.FUNC_ADD), i.blendFunc(i.ONE, i.ZERO), i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO), i.blendColor(0, 0, 0, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(i.LESS), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(i.ALWAYS, 0, 4294967295), i.stencilOp(i.KEEP, i.KEEP, i.KEEP), i.clearStencil(0), i.cullFace(i.BACK), i.frontFace(i.CCW), i.polygonOffset(0, 0), i.activeTexture(i.TEXTURE0), i.bindFramebuffer(i.FRAMEBUFFER, null), n === !0 && (i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), i.bindFramebuffer(i.READ_FRAMEBUFFER, null)), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), d = {}, N = null, q = {}, f = {}, m = /* @__PURE__ */ new WeakMap(), g = [], p = null, v = !1, y = null, _ = null, x = null, M = null, S = null, w = null, E = null, b = new Q(0, 0, 0), A = 0, D = !1, B = null, X = null, L = null, F = null, H = null, be.set(0, 0, i.canvas.width, i.canvas.height), Fe.set(0, 0, i.canvas.width, i.canvas.height), o.reset(), l.reset(), c.reset();
  }
  return {
    buffers: {
      color: o,
      depth: l,
      stencil: c
    },
    enable: Xe,
    disable: ct,
    bindFramebuffer: He,
    drawBuffers: I,
    useProgram: xe,
    setBlending: se,
    setMaterial: De,
    setFlipSided: Ee,
    setCullFace: Re,
    setLineWidth: Ge,
    setPolygonOffset: nt,
    setScissorTest: Ct,
    activeTexture: P,
    bindTexture: C,
    unbindTexture: W,
    compressedTexImage2D: he,
    compressedTexImage3D: ae,
    texImage2D: ie,
    texImage3D: Ve,
    updateUBOMapping: Le,
    uniformBlockBinding: Ce,
    texStorage2D: O,
    texStorage3D: me,
    texSubImage2D: ue,
    texSubImage3D: Pe,
    compressedTexSubImage2D: pe,
    compressedTexSubImage3D: we,
    scissor: Ie,
    viewport: ke,
    reset: rt
  };
}
function CC(i, e, t, n, s, r, a) {
  const o = s.isWebGL2, l = s.maxTextures, c = s.maxCubemapSize, h = s.maxTextureSize, u = s.maxSamples, d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, f = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), m = /* @__PURE__ */ new WeakMap();
  let g;
  const p = /* @__PURE__ */ new WeakMap();
  let v = !1;
  try {
    v = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function y(P, C) {
    return v ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(P, C)
    ) : uc("canvas");
  }
  function _(P, C, W, he) {
    let ae = 1;
    if ((P.width > he || P.height > he) && (ae = he / Math.max(P.width, P.height)), ae < 1 || C === !0)
      if (typeof HTMLImageElement < "u" && P instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && P instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && P instanceof ImageBitmap) {
        const ue = C ? Lu : Math.floor, Pe = ue(ae * P.width), pe = ue(ae * P.height);
        g === void 0 && (g = y(Pe, pe));
        const we = W ? y(Pe, pe) : g;
        return we.width = Pe, we.height = pe, we.getContext("2d").drawImage(P, 0, 0, Pe, pe), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + P.width + "x" + P.height + ") to (" + Pe + "x" + pe + ")."), we;
      } else
        return "data" in P && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + P.width + "x" + P.height + ")."), P;
    return P;
  }
  function x(P) {
    return Up(P.width) && Up(P.height);
  }
  function M(P) {
    return o ? !1 : P.wrapS !== Kt || P.wrapT !== Kt || P.minFilter !== lt && P.minFilter !== Nt;
  }
  function S(P, C) {
    return P.generateMipmaps && C && P.minFilter !== lt && P.minFilter !== Nt;
  }
  function w(P) {
    i.generateMipmap(P);
  }
  function E(P, C, W, he, ae = !1) {
    if (o === !1) return C;
    if (P !== null) {
      if (i[P] !== void 0) return i[P];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + P + "'");
    }
    let ue = C;
    if (C === i.RED && (W === i.FLOAT && (ue = i.R32F), W === i.HALF_FLOAT && (ue = i.R16F), W === i.UNSIGNED_BYTE && (ue = i.R8)), C === i.RED_INTEGER && (W === i.UNSIGNED_BYTE && (ue = i.R8UI), W === i.UNSIGNED_SHORT && (ue = i.R16UI), W === i.UNSIGNED_INT && (ue = i.R32UI), W === i.BYTE && (ue = i.R8I), W === i.SHORT && (ue = i.R16I), W === i.INT && (ue = i.R32I)), C === i.RG && (W === i.FLOAT && (ue = i.RG32F), W === i.HALF_FLOAT && (ue = i.RG16F), W === i.UNSIGNED_BYTE && (ue = i.RG8)), C === i.RGBA) {
      const Pe = ae ? ac : gt.getTransfer(he);
      W === i.FLOAT && (ue = i.RGBA32F), W === i.HALF_FLOAT && (ue = i.RGBA16F), W === i.UNSIGNED_BYTE && (ue = Pe === Mt ? i.SRGB8_ALPHA8 : i.RGBA8), W === i.UNSIGNED_SHORT_4_4_4_4 && (ue = i.RGBA4), W === i.UNSIGNED_SHORT_5_5_5_1 && (ue = i.RGB5_A1);
    }
    return (ue === i.R16F || ue === i.R32F || ue === i.RG16F || ue === i.RG32F || ue === i.RGBA16F || ue === i.RGBA32F) && e.get("EXT_color_buffer_float"), ue;
  }
  function b(P, C, W) {
    return S(P, W) === !0 || P.isFramebufferTexture && P.minFilter !== lt && P.minFilter !== Nt ? Math.log2(Math.max(C.width, C.height)) + 1 : P.mipmaps !== void 0 && P.mipmaps.length > 0 ? P.mipmaps.length : P.isCompressedTexture && Array.isArray(P.image) ? C.mipmaps.length : 1;
  }
  function A(P) {
    return P === lt || P === sc || P === Eo ? i.NEAREST : i.LINEAR;
  }
  function D(P) {
    const C = P.target;
    C.removeEventListener("dispose", D), X(C), C.isVideoTexture && m.delete(C);
  }
  function B(P) {
    const C = P.target;
    C.removeEventListener("dispose", B), F(C);
  }
  function X(P) {
    const C = n.get(P);
    if (C.__webglInit === void 0) return;
    const W = P.source, he = p.get(W);
    if (he) {
      const ae = he[C.__cacheKey];
      ae.usedTimes--, ae.usedTimes === 0 && L(P), Object.keys(he).length === 0 && p.delete(W);
    }
    n.remove(P);
  }
  function L(P) {
    const C = n.get(P);
    i.deleteTexture(C.__webglTexture);
    const W = P.source, he = p.get(W);
    delete he[C.__cacheKey], a.memory.textures--;
  }
  function F(P) {
    const C = P.texture, W = n.get(P), he = n.get(C);
    if (he.__webglTexture !== void 0 && (i.deleteTexture(he.__webglTexture), a.memory.textures--), P.depthTexture && P.depthTexture.dispose(), P.isWebGLCubeRenderTarget)
      for (let ae = 0; ae < 6; ae++) {
        if (Array.isArray(W.__webglFramebuffer[ae]))
          for (let ue = 0; ue < W.__webglFramebuffer[ae].length; ue++) i.deleteFramebuffer(W.__webglFramebuffer[ae][ue]);
        else
          i.deleteFramebuffer(W.__webglFramebuffer[ae]);
        W.__webglDepthbuffer && i.deleteRenderbuffer(W.__webglDepthbuffer[ae]);
      }
    else {
      if (Array.isArray(W.__webglFramebuffer))
        for (let ae = 0; ae < W.__webglFramebuffer.length; ae++) i.deleteFramebuffer(W.__webglFramebuffer[ae]);
      else
        i.deleteFramebuffer(W.__webglFramebuffer);
      if (W.__webglDepthbuffer && i.deleteRenderbuffer(W.__webglDepthbuffer), W.__webglMultisampledFramebuffer && i.deleteFramebuffer(W.__webglMultisampledFramebuffer), W.__webglColorRenderbuffer)
        for (let ae = 0; ae < W.__webglColorRenderbuffer.length; ae++)
          W.__webglColorRenderbuffer[ae] && i.deleteRenderbuffer(W.__webglColorRenderbuffer[ae]);
      W.__webglDepthRenderbuffer && i.deleteRenderbuffer(W.__webglDepthRenderbuffer);
    }
    if (P.isWebGLMultipleRenderTargets)
      for (let ae = 0, ue = C.length; ae < ue; ae++) {
        const Pe = n.get(C[ae]);
        Pe.__webglTexture && (i.deleteTexture(Pe.__webglTexture), a.memory.textures--), n.remove(C[ae]);
      }
    n.remove(C), n.remove(P);
  }
  let H = 0;
  function G() {
    H = 0;
  }
  function te() {
    const P = H;
    return P >= l && console.warn("THREE.WebGLTextures: Trying to use " + P + " texture units while this GPU supports only " + l), H += 1, P;
  }
  function j(P) {
    const C = [];
    return C.push(P.wrapS), C.push(P.wrapT), C.push(P.wrapR || 0), C.push(P.magFilter), C.push(P.minFilter), C.push(P.anisotropy), C.push(P.internalFormat), C.push(P.format), C.push(P.type), C.push(P.generateMipmaps), C.push(P.premultiplyAlpha), C.push(P.flipY), C.push(P.unpackAlignment), C.push(P.colorSpace), C.join();
  }
  function J(P, C) {
    const W = n.get(P);
    if (P.isVideoTexture && nt(P), P.isRenderTargetTexture === !1 && P.version > 0 && W.__version !== P.version) {
      const he = P.image;
      if (he === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (he.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        Xe(W, P, C);
        return;
      }
    }
    t.bindTexture(i.TEXTURE_2D, W.__webglTexture, i.TEXTURE0 + C);
  }
  function N(P, C) {
    const W = n.get(P);
    if (P.version > 0 && W.__version !== P.version) {
      Xe(W, P, C);
      return;
    }
    t.bindTexture(i.TEXTURE_2D_ARRAY, W.__webglTexture, i.TEXTURE0 + C);
  }
  function q(P, C) {
    const W = n.get(P);
    if (P.version > 0 && W.__version !== P.version) {
      Xe(W, P, C);
      return;
    }
    t.bindTexture(i.TEXTURE_3D, W.__webglTexture, i.TEXTURE0 + C);
  }
  function ge(P, C) {
    const W = n.get(P);
    if (P.version > 0 && W.__version !== P.version) {
      ct(W, P, C);
      return;
    }
    t.bindTexture(i.TEXTURE_CUBE_MAP, W.__webglTexture, i.TEXTURE0 + C);
  }
  const de = {
    [Tn]: i.REPEAT,
    [Kt]: i.CLAMP_TO_EDGE,
    [Er]: i.MIRRORED_REPEAT
  }, be = {
    [lt]: i.NEAREST,
    [sc]: i.NEAREST_MIPMAP_NEAREST,
    [Eo]: i.NEAREST_MIPMAP_LINEAR,
    [Nt]: i.LINEAR,
    [dd]: i.LINEAR_MIPMAP_NEAREST,
    [ys]: i.LINEAR_MIPMAP_LINEAR
  }, Fe = {
    [mx]: i.NEVER,
    [bx]: i.ALWAYS,
    [gx]: i.LESS,
    [_x]: i.LEQUAL,
    [vx]: i.EQUAL,
    [Mx]: i.GEQUAL,
    [yx]: i.GREATER,
    [xx]: i.NOTEQUAL
  };
  function ze(P, C, W) {
    if (W ? (i.texParameteri(P, i.TEXTURE_WRAP_S, de[C.wrapS]), i.texParameteri(P, i.TEXTURE_WRAP_T, de[C.wrapT]), (P === i.TEXTURE_3D || P === i.TEXTURE_2D_ARRAY) && i.texParameteri(P, i.TEXTURE_WRAP_R, de[C.wrapR]), i.texParameteri(P, i.TEXTURE_MAG_FILTER, be[C.magFilter]), i.texParameteri(P, i.TEXTURE_MIN_FILTER, be[C.minFilter])) : (i.texParameteri(P, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(P, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), (P === i.TEXTURE_3D || P === i.TEXTURE_2D_ARRAY) && i.texParameteri(P, i.TEXTURE_WRAP_R, i.CLAMP_TO_EDGE), (C.wrapS !== Kt || C.wrapT !== Kt) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), i.texParameteri(P, i.TEXTURE_MAG_FILTER, A(C.magFilter)), i.texParameteri(P, i.TEXTURE_MIN_FILTER, A(C.minFilter)), C.minFilter !== lt && C.minFilter !== Nt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), C.compareFunction && (i.texParameteri(P, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE), i.texParameteri(P, i.TEXTURE_COMPARE_FUNC, Fe[C.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      const he = e.get("EXT_texture_filter_anisotropic");
      if (C.magFilter === lt || C.minFilter !== Eo && C.minFilter !== ys || C.type === hs && e.has("OES_texture_float_linear") === !1 || o === !1 && C.type === zt && e.has("OES_texture_half_float_linear") === !1) return;
      (C.anisotropy > 1 || n.get(C).__currentAnisotropy) && (i.texParameterf(P, he.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(C.anisotropy, s.getMaxAnisotropy())), n.get(C).__currentAnisotropy = C.anisotropy);
    }
  }
  function Ne(P, C) {
    let W = !1;
    P.__webglInit === void 0 && (P.__webglInit = !0, C.addEventListener("dispose", D));
    const he = C.source;
    let ae = p.get(he);
    ae === void 0 && (ae = {}, p.set(he, ae));
    const ue = j(C);
    if (ue !== P.__cacheKey) {
      ae[ue] === void 0 && (ae[ue] = {
        texture: i.createTexture(),
        usedTimes: 0
      }, a.memory.textures++, W = !0), ae[ue].usedTimes++;
      const Pe = ae[P.__cacheKey];
      Pe !== void 0 && (ae[P.__cacheKey].usedTimes--, Pe.usedTimes === 0 && L(C)), P.__cacheKey = ue, P.__webglTexture = ae[ue].texture;
    }
    return W;
  }
  function Xe(P, C, W) {
    let he = i.TEXTURE_2D;
    (C.isDataArrayTexture || C.isCompressedArrayTexture) && (he = i.TEXTURE_2D_ARRAY), C.isData3DTexture && (he = i.TEXTURE_3D);
    const ae = Ne(P, C), ue = C.source;
    t.bindTexture(he, P.__webglTexture, i.TEXTURE0 + W);
    const Pe = n.get(ue);
    if (ue.version !== Pe.__version || ae === !0) {
      t.activeTexture(i.TEXTURE0 + W);
      const pe = gt.getPrimaries(gt.workingColorSpace), we = C.colorSpace === vi ? null : gt.getPrimaries(C.colorSpace), O = C.colorSpace === vi || pe === we ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, C.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, C.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, C.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, O);
      const me = M(C) && x(C.image) === !1;
      let ie = _(C.image, me, !1, h);
      ie = Ct(C, ie);
      const Ve = x(ie) || o, Ie = r.convert(C.format, C.colorSpace);
      let ke = r.convert(C.type), Le = E(C.internalFormat, Ie, ke, C.colorSpace, C.isVideoTexture);
      ze(he, C, Ve);
      let Ce;
      const rt = C.mipmaps, U = o && C.isVideoTexture !== !0, Me = Pe.__version === void 0 || ae === !0, oe = b(C, ie, Ve);
      if (C.isDepthTexture)
        Le = i.DEPTH_COMPONENT, o ? C.type === hs ? Le = i.DEPTH_COMPONENT32F : C.type === Fs ? Le = i.DEPTH_COMPONENT24 : C.type === zs ? Le = i.DEPTH24_STENCIL8 : Le = i.DEPTH_COMPONENT16 : C.type === hs && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), C.format === gr && Le === i.DEPTH_COMPONENT && C.type !== Nc && C.type !== Fs && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), C.type = Fs, ke = r.convert(C.type)), C.format === Ar && Le === i.DEPTH_COMPONENT && (Le = i.DEPTH_STENCIL, C.type !== zs && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), C.type = zs, ke = r.convert(C.type))), Me && (U ? t.texStorage2D(i.TEXTURE_2D, 1, Le, ie.width, ie.height) : t.texImage2D(i.TEXTURE_2D, 0, Le, ie.width, ie.height, 0, Ie, ke, null));
      else if (C.isDataTexture)
        if (rt.length > 0 && Ve) {
          U && Me && t.texStorage2D(i.TEXTURE_2D, oe, Le, rt[0].width, rt[0].height);
          for (let K = 0, fe = rt.length; K < fe; K++)
            Ce = rt[K], U ? t.texSubImage2D(i.TEXTURE_2D, K, 0, 0, Ce.width, Ce.height, Ie, ke, Ce.data) : t.texImage2D(i.TEXTURE_2D, K, Le, Ce.width, Ce.height, 0, Ie, ke, Ce.data);
          C.generateMipmaps = !1;
        } else
          U ? (Me && t.texStorage2D(i.TEXTURE_2D, oe, Le, ie.width, ie.height), t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, ie.width, ie.height, Ie, ke, ie.data)) : t.texImage2D(i.TEXTURE_2D, 0, Le, ie.width, ie.height, 0, Ie, ke, ie.data);
      else if (C.isCompressedTexture)
        if (C.isCompressedArrayTexture) {
          U && Me && t.texStorage3D(i.TEXTURE_2D_ARRAY, oe, Le, rt[0].width, rt[0].height, ie.depth);
          for (let K = 0, fe = rt.length; K < fe; K++)
            Ce = rt[K], C.format !== gi ? Ie !== null ? U ? t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, K, 0, 0, 0, Ce.width, Ce.height, ie.depth, Ie, Ce.data, 0, 0) : t.compressedTexImage3D(i.TEXTURE_2D_ARRAY, K, Le, Ce.width, Ce.height, ie.depth, 0, Ce.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : U ? t.texSubImage3D(i.TEXTURE_2D_ARRAY, K, 0, 0, 0, Ce.width, Ce.height, ie.depth, Ie, ke, Ce.data) : t.texImage3D(i.TEXTURE_2D_ARRAY, K, Le, Ce.width, Ce.height, ie.depth, 0, Ie, ke, Ce.data);
        } else {
          U && Me && t.texStorage2D(i.TEXTURE_2D, oe, Le, rt[0].width, rt[0].height);
          for (let K = 0, fe = rt.length; K < fe; K++)
            Ce = rt[K], C.format !== gi ? Ie !== null ? U ? t.compressedTexSubImage2D(i.TEXTURE_2D, K, 0, 0, Ce.width, Ce.height, Ie, Ce.data) : t.compressedTexImage2D(i.TEXTURE_2D, K, Le, Ce.width, Ce.height, 0, Ce.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : U ? t.texSubImage2D(i.TEXTURE_2D, K, 0, 0, Ce.width, Ce.height, Ie, ke, Ce.data) : t.texImage2D(i.TEXTURE_2D, K, Le, Ce.width, Ce.height, 0, Ie, ke, Ce.data);
        }
      else if (C.isDataArrayTexture)
        U ? (Me && t.texStorage3D(i.TEXTURE_2D_ARRAY, oe, Le, ie.width, ie.height, ie.depth), t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ie.width, ie.height, ie.depth, Ie, ke, ie.data)) : t.texImage3D(i.TEXTURE_2D_ARRAY, 0, Le, ie.width, ie.height, ie.depth, 0, Ie, ke, ie.data);
      else if (C.isData3DTexture)
        U ? (Me && t.texStorage3D(i.TEXTURE_3D, oe, Le, ie.width, ie.height, ie.depth), t.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, ie.width, ie.height, ie.depth, Ie, ke, ie.data)) : t.texImage3D(i.TEXTURE_3D, 0, Le, ie.width, ie.height, ie.depth, 0, Ie, ke, ie.data);
      else if (C.isFramebufferTexture) {
        if (Me)
          if (U)
            t.texStorage2D(i.TEXTURE_2D, oe, Le, ie.width, ie.height);
          else {
            let K = ie.width, fe = ie.height;
            for (let Ue = 0; Ue < oe; Ue++)
              t.texImage2D(i.TEXTURE_2D, Ue, Le, K, fe, 0, Ie, ke, null), K >>= 1, fe >>= 1;
          }
      } else if (rt.length > 0 && Ve) {
        U && Me && t.texStorage2D(i.TEXTURE_2D, oe, Le, rt[0].width, rt[0].height);
        for (let K = 0, fe = rt.length; K < fe; K++)
          Ce = rt[K], U ? t.texSubImage2D(i.TEXTURE_2D, K, 0, 0, Ie, ke, Ce) : t.texImage2D(i.TEXTURE_2D, K, Le, Ie, ke, Ce);
        C.generateMipmaps = !1;
      } else
        U ? (Me && t.texStorage2D(i.TEXTURE_2D, oe, Le, ie.width, ie.height), t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, Ie, ke, ie)) : t.texImage2D(i.TEXTURE_2D, 0, Le, Ie, ke, ie);
      S(C, Ve) && w(he), Pe.__version = ue.version, C.onUpdate && C.onUpdate(C);
    }
    P.__version = C.version;
  }
  function ct(P, C, W) {
    if (C.image.length !== 6) return;
    const he = Ne(P, C), ae = C.source;
    t.bindTexture(i.TEXTURE_CUBE_MAP, P.__webglTexture, i.TEXTURE0 + W);
    const ue = n.get(ae);
    if (ae.version !== ue.__version || he === !0) {
      t.activeTexture(i.TEXTURE0 + W);
      const Pe = gt.getPrimaries(gt.workingColorSpace), pe = C.colorSpace === vi ? null : gt.getPrimaries(C.colorSpace), we = C.colorSpace === vi || Pe === pe ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, C.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, C.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, C.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, we);
      const O = C.isCompressedTexture || C.image[0].isCompressedTexture, me = C.image[0] && C.image[0].isDataTexture, ie = [];
      for (let K = 0; K < 6; K++)
        !O && !me ? ie[K] = _(C.image[K], !1, !0, c) : ie[K] = me ? C.image[K].image : C.image[K], ie[K] = Ct(C, ie[K]);
      const Ve = ie[0], Ie = x(Ve) || o, ke = r.convert(C.format, C.colorSpace), Le = r.convert(C.type), Ce = E(C.internalFormat, ke, Le, C.colorSpace), rt = o && C.isVideoTexture !== !0, U = ue.__version === void 0 || he === !0;
      let Me = b(C, Ve, Ie);
      ze(i.TEXTURE_CUBE_MAP, C, Ie);
      let oe;
      if (O) {
        rt && U && t.texStorage2D(i.TEXTURE_CUBE_MAP, Me, Ce, Ve.width, Ve.height);
        for (let K = 0; K < 6; K++) {
          oe = ie[K].mipmaps;
          for (let fe = 0; fe < oe.length; fe++) {
            const Ue = oe[fe];
            C.format !== gi ? ke !== null ? rt ? t.compressedTexSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + K, fe, 0, 0, Ue.width, Ue.height, ke, Ue.data) : t.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + K, fe, Ce, Ue.width, Ue.height, 0, Ue.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : rt ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + K, fe, 0, 0, Ue.width, Ue.height, ke, Le, Ue.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + K, fe, Ce, Ue.width, Ue.height, 0, ke, Le, Ue.data);
          }
        }
      } else {
        oe = C.mipmaps, rt && U && (oe.length > 0 && Me++, t.texStorage2D(i.TEXTURE_CUBE_MAP, Me, Ce, ie[0].width, ie[0].height));
        for (let K = 0; K < 6; K++)
          if (me) {
            rt ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, 0, 0, ie[K].width, ie[K].height, ke, Le, ie[K].data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, Ce, ie[K].width, ie[K].height, 0, ke, Le, ie[K].data);
            for (let fe = 0; fe < oe.length; fe++) {
              const at = oe[fe].image[K].image;
              rt ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + K, fe + 1, 0, 0, at.width, at.height, ke, Le, at.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + K, fe + 1, Ce, at.width, at.height, 0, ke, Le, at.data);
            }
          } else {
            rt ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, 0, 0, ke, Le, ie[K]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, Ce, ke, Le, ie[K]);
            for (let fe = 0; fe < oe.length; fe++) {
              const Ue = oe[fe];
              rt ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + K, fe + 1, 0, 0, ke, Le, Ue.image[K]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + K, fe + 1, Ce, ke, Le, Ue.image[K]);
            }
          }
      }
      S(C, Ie) && w(i.TEXTURE_CUBE_MAP), ue.__version = ae.version, C.onUpdate && C.onUpdate(C);
    }
    P.__version = C.version;
  }
  function He(P, C, W, he, ae, ue) {
    const Pe = r.convert(W.format, W.colorSpace), pe = r.convert(W.type), we = E(W.internalFormat, Pe, pe, W.colorSpace);
    if (!n.get(C).__hasExternalTextures) {
      const me = Math.max(1, C.width >> ue), ie = Math.max(1, C.height >> ue);
      ae === i.TEXTURE_3D || ae === i.TEXTURE_2D_ARRAY ? t.texImage3D(ae, ue, we, me, ie, C.depth, 0, Pe, pe, null) : t.texImage2D(ae, ue, we, me, ie, 0, Pe, pe, null);
    }
    t.bindFramebuffer(i.FRAMEBUFFER, P), Ge(C) ? d.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, he, ae, n.get(W).__webglTexture, 0, Re(C)) : (ae === i.TEXTURE_2D || ae >= i.TEXTURE_CUBE_MAP_POSITIVE_X && ae <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z) && i.framebufferTexture2D(i.FRAMEBUFFER, he, ae, n.get(W).__webglTexture, ue), t.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  function I(P, C, W) {
    if (i.bindRenderbuffer(i.RENDERBUFFER, P), C.depthBuffer && !C.stencilBuffer) {
      let he = o === !0 ? i.DEPTH_COMPONENT24 : i.DEPTH_COMPONENT16;
      if (W || Ge(C)) {
        const ae = C.depthTexture;
        ae && ae.isDepthTexture && (ae.type === hs ? he = i.DEPTH_COMPONENT32F : ae.type === Fs && (he = i.DEPTH_COMPONENT24));
        const ue = Re(C);
        Ge(C) ? d.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, ue, he, C.width, C.height) : i.renderbufferStorageMultisample(i.RENDERBUFFER, ue, he, C.width, C.height);
      } else
        i.renderbufferStorage(i.RENDERBUFFER, he, C.width, C.height);
      i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, P);
    } else if (C.depthBuffer && C.stencilBuffer) {
      const he = Re(C);
      W && Ge(C) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, he, i.DEPTH24_STENCIL8, C.width, C.height) : Ge(C) ? d.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, he, i.DEPTH24_STENCIL8, C.width, C.height) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, C.width, C.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, P);
    } else {
      const he = C.isWebGLMultipleRenderTargets === !0 ? C.texture : [C.texture];
      for (let ae = 0; ae < he.length; ae++) {
        const ue = he[ae], Pe = r.convert(ue.format, ue.colorSpace), pe = r.convert(ue.type), we = E(ue.internalFormat, Pe, pe, ue.colorSpace), O = Re(C);
        W && Ge(C) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, O, we, C.width, C.height) : Ge(C) ? d.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, O, we, C.width, C.height) : i.renderbufferStorage(i.RENDERBUFFER, we, C.width, C.height);
      }
    }
    i.bindRenderbuffer(i.RENDERBUFFER, null);
  }
  function xe(P, C) {
    if (C && C.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(i.FRAMEBUFFER, P), !(C.depthTexture && C.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(C.depthTexture).__webglTexture || C.depthTexture.image.width !== C.width || C.depthTexture.image.height !== C.height) && (C.depthTexture.image.width = C.width, C.depthTexture.image.height = C.height, C.depthTexture.needsUpdate = !0), J(C.depthTexture, 0);
    const he = n.get(C.depthTexture).__webglTexture, ae = Re(C);
    if (C.depthTexture.format === gr)
      Ge(C) ? d.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, he, 0, ae) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, he, 0);
    else if (C.depthTexture.format === Ar)
      Ge(C) ? d.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, he, 0, ae) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, he, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function ee(P) {
    const C = n.get(P), W = P.isWebGLCubeRenderTarget === !0;
    if (P.depthTexture && !C.__autoAllocateDepthBuffer) {
      if (W) throw new Error("target.depthTexture not supported in Cube render targets");
      xe(C.__webglFramebuffer, P);
    } else if (W) {
      C.__webglDepthbuffer = [];
      for (let he = 0; he < 6; he++)
        t.bindFramebuffer(i.FRAMEBUFFER, C.__webglFramebuffer[he]), C.__webglDepthbuffer[he] = i.createRenderbuffer(), I(C.__webglDepthbuffer[he], P, !1);
    } else
      t.bindFramebuffer(i.FRAMEBUFFER, C.__webglFramebuffer), C.__webglDepthbuffer = i.createRenderbuffer(), I(C.__webglDepthbuffer, P, !1);
    t.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  function ce(P, C, W) {
    const he = n.get(P);
    C !== void 0 && He(he.__webglFramebuffer, P, P.texture, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, 0), W !== void 0 && ee(P);
  }
  function se(P) {
    const C = P.texture, W = n.get(P), he = n.get(C);
    P.addEventListener("dispose", B), P.isWebGLMultipleRenderTargets !== !0 && (he.__webglTexture === void 0 && (he.__webglTexture = i.createTexture()), he.__version = C.version, a.memory.textures++);
    const ae = P.isWebGLCubeRenderTarget === !0, ue = P.isWebGLMultipleRenderTargets === !0, Pe = x(P) || o;
    if (ae) {
      W.__webglFramebuffer = [];
      for (let pe = 0; pe < 6; pe++)
        if (o && C.mipmaps && C.mipmaps.length > 0) {
          W.__webglFramebuffer[pe] = [];
          for (let we = 0; we < C.mipmaps.length; we++)
            W.__webglFramebuffer[pe][we] = i.createFramebuffer();
        } else
          W.__webglFramebuffer[pe] = i.createFramebuffer();
    } else {
      if (o && C.mipmaps && C.mipmaps.length > 0) {
        W.__webglFramebuffer = [];
        for (let pe = 0; pe < C.mipmaps.length; pe++)
          W.__webglFramebuffer[pe] = i.createFramebuffer();
      } else
        W.__webglFramebuffer = i.createFramebuffer();
      if (ue)
        if (s.drawBuffers) {
          const pe = P.texture;
          for (let we = 0, O = pe.length; we < O; we++) {
            const me = n.get(pe[we]);
            me.__webglTexture === void 0 && (me.__webglTexture = i.createTexture(), a.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (o && P.samples > 0 && Ge(P) === !1) {
        const pe = ue ? C : [C];
        W.__webglMultisampledFramebuffer = i.createFramebuffer(), W.__webglColorRenderbuffer = [], t.bindFramebuffer(i.FRAMEBUFFER, W.__webglMultisampledFramebuffer);
        for (let we = 0; we < pe.length; we++) {
          const O = pe[we];
          W.__webglColorRenderbuffer[we] = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, W.__webglColorRenderbuffer[we]);
          const me = r.convert(O.format, O.colorSpace), ie = r.convert(O.type), Ve = E(O.internalFormat, me, ie, O.colorSpace, P.isXRRenderTarget === !0), Ie = Re(P);
          i.renderbufferStorageMultisample(i.RENDERBUFFER, Ie, Ve, P.width, P.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + we, i.RENDERBUFFER, W.__webglColorRenderbuffer[we]);
        }
        i.bindRenderbuffer(i.RENDERBUFFER, null), P.depthBuffer && (W.__webglDepthRenderbuffer = i.createRenderbuffer(), I(W.__webglDepthRenderbuffer, P, !0)), t.bindFramebuffer(i.FRAMEBUFFER, null);
      }
    }
    if (ae) {
      t.bindTexture(i.TEXTURE_CUBE_MAP, he.__webglTexture), ze(i.TEXTURE_CUBE_MAP, C, Pe);
      for (let pe = 0; pe < 6; pe++)
        if (o && C.mipmaps && C.mipmaps.length > 0)
          for (let we = 0; we < C.mipmaps.length; we++)
            He(W.__webglFramebuffer[pe][we], P, C, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + pe, we);
        else
          He(W.__webglFramebuffer[pe], P, C, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + pe, 0);
      S(C, Pe) && w(i.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (ue) {
      const pe = P.texture;
      for (let we = 0, O = pe.length; we < O; we++) {
        const me = pe[we], ie = n.get(me);
        t.bindTexture(i.TEXTURE_2D, ie.__webglTexture), ze(i.TEXTURE_2D, me, Pe), He(W.__webglFramebuffer, P, me, i.COLOR_ATTACHMENT0 + we, i.TEXTURE_2D, 0), S(me, Pe) && w(i.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let pe = i.TEXTURE_2D;
      if ((P.isWebGL3DRenderTarget || P.isWebGLArrayRenderTarget) && (o ? pe = P.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(pe, he.__webglTexture), ze(pe, C, Pe), o && C.mipmaps && C.mipmaps.length > 0)
        for (let we = 0; we < C.mipmaps.length; we++)
          He(W.__webglFramebuffer[we], P, C, i.COLOR_ATTACHMENT0, pe, we);
      else
        He(W.__webglFramebuffer, P, C, i.COLOR_ATTACHMENT0, pe, 0);
      S(C, Pe) && w(pe), t.unbindTexture();
    }
    P.depthBuffer && ee(P);
  }
  function De(P) {
    const C = x(P) || o, W = P.isWebGLMultipleRenderTargets === !0 ? P.texture : [P.texture];
    for (let he = 0, ae = W.length; he < ae; he++) {
      const ue = W[he];
      if (S(ue, C)) {
        const Pe = P.isWebGLCubeRenderTarget ? i.TEXTURE_CUBE_MAP : i.TEXTURE_2D, pe = n.get(ue).__webglTexture;
        t.bindTexture(Pe, pe), w(Pe), t.unbindTexture();
      }
    }
  }
  function Ee(P) {
    if (o && P.samples > 0 && Ge(P) === !1) {
      const C = P.isWebGLMultipleRenderTargets ? P.texture : [P.texture], W = P.width, he = P.height;
      let ae = i.COLOR_BUFFER_BIT;
      const ue = [], Pe = P.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, pe = n.get(P), we = P.isWebGLMultipleRenderTargets === !0;
      if (we)
        for (let O = 0; O < C.length; O++)
          t.bindFramebuffer(i.FRAMEBUFFER, pe.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + O, i.RENDERBUFFER, null), t.bindFramebuffer(i.FRAMEBUFFER, pe.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + O, i.TEXTURE_2D, null, 0);
      t.bindFramebuffer(i.READ_FRAMEBUFFER, pe.__webglMultisampledFramebuffer), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, pe.__webglFramebuffer);
      for (let O = 0; O < C.length; O++) {
        ue.push(i.COLOR_ATTACHMENT0 + O), P.depthBuffer && ue.push(Pe);
        const me = pe.__ignoreDepthValues !== void 0 ? pe.__ignoreDepthValues : !1;
        if (me === !1 && (P.depthBuffer && (ae |= i.DEPTH_BUFFER_BIT), P.stencilBuffer && (ae |= i.STENCIL_BUFFER_BIT)), we && i.framebufferRenderbuffer(i.READ_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, pe.__webglColorRenderbuffer[O]), me === !0 && (i.invalidateFramebuffer(i.READ_FRAMEBUFFER, [Pe]), i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [Pe])), we) {
          const ie = n.get(C[O]).__webglTexture;
          i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, ie, 0);
        }
        i.blitFramebuffer(0, 0, W, he, 0, 0, W, he, ae, i.NEAREST), f && i.invalidateFramebuffer(i.READ_FRAMEBUFFER, ue);
      }
      if (t.bindFramebuffer(i.READ_FRAMEBUFFER, null), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), we)
        for (let O = 0; O < C.length; O++) {
          t.bindFramebuffer(i.FRAMEBUFFER, pe.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + O, i.RENDERBUFFER, pe.__webglColorRenderbuffer[O]);
          const me = n.get(C[O]).__webglTexture;
          t.bindFramebuffer(i.FRAMEBUFFER, pe.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + O, i.TEXTURE_2D, me, 0);
        }
      t.bindFramebuffer(i.DRAW_FRAMEBUFFER, pe.__webglMultisampledFramebuffer);
    }
  }
  function Re(P) {
    return Math.min(u, P.samples);
  }
  function Ge(P) {
    const C = n.get(P);
    return o && P.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && C.__useRenderToTexture !== !1;
  }
  function nt(P) {
    const C = a.render.frame;
    m.get(P) !== C && (m.set(P, C), P.update());
  }
  function Ct(P, C) {
    const W = P.colorSpace, he = P.format, ae = P.type;
    return P.isCompressedTexture === !0 || P.isVideoTexture === !0 || P.format === Pu || W !== en && W !== vi && (gt.getTransfer(W) === Mt ? o === !1 ? e.has("EXT_sRGB") === !0 && he === gi ? (P.format = Pu, P.minFilter = Nt, P.generateMipmaps = !1) : C = Wm.sRGBToLinear(C) : (he !== gi || ae !== ks) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", W)), C;
  }
  this.allocateTextureUnit = te, this.resetTextureUnits = G, this.setTexture2D = J, this.setTexture2DArray = N, this.setTexture3D = q, this.setTextureCube = ge, this.rebindTextures = ce, this.setupRenderTarget = se, this.updateRenderTargetMipmap = De, this.updateMultisampleRenderTarget = Ee, this.setupDepthRenderbuffer = ee, this.setupFrameBufferTexture = He, this.useMultisampledRTT = Ge;
}
function Ux(i, e, t) {
  const n = t.isWebGL2;
  function s(r, a = vi) {
    let o;
    const l = gt.getTransfer(a);
    if (r === ks) return i.UNSIGNED_BYTE;
    if (r === Im) return i.UNSIGNED_SHORT_4_4_4_4;
    if (r === Dm) return i.UNSIGNED_SHORT_5_5_5_1;
    if (r === nx) return i.BYTE;
    if (r === ix) return i.SHORT;
    if (r === Nc) return i.UNSIGNED_SHORT;
    if (r === Lm) return i.INT;
    if (r === Fs) return i.UNSIGNED_INT;
    if (r === hs) return i.FLOAT;
    if (r === zt)
      return n ? i.HALF_FLOAT : (o = e.get("OES_texture_half_float"), o !== null ? o.HALF_FLOAT_OES : null);
    if (r === sx) return i.ALPHA;
    if (r === gi) return i.RGBA;
    if (r === rx) return i.LUMINANCE;
    if (r === ax) return i.LUMINANCE_ALPHA;
    if (r === gr) return i.DEPTH_COMPONENT;
    if (r === Ar) return i.DEPTH_STENCIL;
    if (r === Pu)
      return o = e.get("EXT_sRGB"), o !== null ? o.SRGB_ALPHA_EXT : null;
    if (r === ox) return i.RED;
    if (r === Om) return i.RED_INTEGER;
    if (r === lx) return i.RG;
    if (r === Nm) return i.RG_INTEGER;
    if (r === Um) return i.RGBA_INTEGER;
    if (r === hu || r === uu || r === du || r === fu)
      if (l === Mt)
        if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
          if (r === hu) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === uu) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === du) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === fu) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null) {
        if (r === hu) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === uu) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === du) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === fu) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (r === cp || r === hp || r === up || r === dp)
      if (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
        if (r === cp) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === hp) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === up) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === dp) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (r === cx)
      return o = e.get("WEBGL_compressed_texture_etc1"), o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (r === fp || r === pp)
      if (o = e.get("WEBGL_compressed_texture_etc"), o !== null) {
        if (r === fp) return l === Mt ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (r === pp) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (r === mp || r === gp || r === vp || r === _p || r === yp || r === xp || r === Mp || r === bp || r === Sp || r === wp || r === Tp || r === Ep || r === Ap || r === Cp)
      if (o = e.get("WEBGL_compressed_texture_astc"), o !== null) {
        if (r === mp) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === gp) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === vp) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === _p) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === yp) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === xp) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === Mp) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === bp) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === Sp) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === wp) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === Tp) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === Ep) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === Ap) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === Cp) return l === Mt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (r === pu || r === Rp || r === Pp)
      if (o = e.get("EXT_texture_compression_bptc"), o !== null) {
        if (r === pu) return l === Mt ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (r === Rp) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (r === Pp) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (r === hx || r === Lp || r === Ip || r === Dp)
      if (o = e.get("EXT_texture_compression_rgtc"), o !== null) {
        if (r === pu) return o.COMPRESSED_RED_RGTC1_EXT;
        if (r === Lp) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (r === Ip) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (r === Dp) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return r === zs ? n ? i.UNSIGNED_INT_24_8 : (o = e.get("WEBGL_depth_texture"), o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null) : i[r] !== void 0 ? i[r] : null;
  }
  return { convert: s };
}
class Fx extends Zt {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class Gn extends Ze {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const RC = { type: "move" };
class yf {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Gn(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Gn(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new T(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new T()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Gn(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new T(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new T()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const n of e.hand.values())
          this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, n) {
    let s = null, r = null, a = null;
    const o = this._targetRay, l = this._grip, c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        a = !0;
        for (const g of e.hand.values()) {
          const p = t.getJointPose(g, n), v = this._getHandJoint(c, g);
          p !== null && (v.matrix.fromArray(p.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.matrixWorldNeedsUpdate = !0, v.jointRadius = p.radius), v.visible = p !== null;
        }
        const h = c.joints["index-finger-tip"], u = c.joints["thumb-tip"], d = h.position.distanceTo(u.position), f = 0.02, m = 5e-3;
        c.inputState.pinching && d > f + m ? (c.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !c.inputState.pinching && d <= f - m && (c.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
      o !== null && (s = t.getPose(e.targetRaySpace, n), s === null && r !== null && (s = r), s !== null && (o.matrix.fromArray(s.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(s.linearVelocity)) : o.hasLinearVelocity = !1, s.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(s.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(RC)));
    }
    return o !== null && (o.visible = s !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = a !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new Gn();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class bd extends At {
  constructor(e, t, n, s, r, a, o, l, c, h) {
    if (h = h !== void 0 ? h : gr, h !== gr && h !== Ar)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && h === gr && (n = Fs), n === void 0 && h === Ar && (n = zs), super(null, s, r, a, o, l, h, n, c), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = o !== void 0 ? o : lt, this.minFilter = l !== void 0 ? l : lt, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
class PC extends bs {
  constructor(e, t) {
    super();
    const n = this;
    let s = null, r = 1, a = null, o = "local-floor", l = 1, c = null, h = null, u = null, d = null, f = null, m = null;
    const g = t.getContextAttributes();
    let p = null, v = null;
    const y = [], _ = [], x = new Zt();
    x.layers.enable(1), x.viewport = new tt();
    const M = new Zt();
    M.layers.enable(2), M.viewport = new tt();
    const S = [x, M], w = new Fx();
    w.layers.enable(1), w.layers.enable(2);
    let E = null, b = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(N) {
      let q = y[N];
      return q === void 0 && (q = new yf(), y[N] = q), q.getTargetRaySpace();
    }, this.getControllerGrip = function(N) {
      let q = y[N];
      return q === void 0 && (q = new yf(), y[N] = q), q.getGripSpace();
    }, this.getHand = function(N) {
      let q = y[N];
      return q === void 0 && (q = new yf(), y[N] = q), q.getHandSpace();
    };
    function A(N) {
      const q = _.indexOf(N.inputSource);
      if (q === -1)
        return;
      const ge = y[q];
      ge !== void 0 && (ge.update(N.inputSource, N.frame, c || a), ge.dispatchEvent({ type: N.type, data: N.inputSource }));
    }
    function D() {
      s.removeEventListener("select", A), s.removeEventListener("selectstart", A), s.removeEventListener("selectend", A), s.removeEventListener("squeeze", A), s.removeEventListener("squeezestart", A), s.removeEventListener("squeezeend", A), s.removeEventListener("end", D), s.removeEventListener("inputsourceschange", B);
      for (let N = 0; N < y.length; N++) {
        const q = _[N];
        q !== null && (_[N] = null, y[N].disconnect(q));
      }
      E = null, b = null, e.setRenderTarget(p), f = null, d = null, u = null, s = null, v = null, J.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(N) {
      r = N, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(N) {
      o = N, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return c || a;
    }, this.setReferenceSpace = function(N) {
      c = N;
    }, this.getBaseLayer = function() {
      return d !== null ? d : f;
    }, this.getBinding = function() {
      return u;
    }, this.getFrame = function() {
      return m;
    }, this.getSession = function() {
      return s;
    }, this.setSession = async function(N) {
      if (s = N, s !== null) {
        if (p = e.getRenderTarget(), s.addEventListener("select", A), s.addEventListener("selectstart", A), s.addEventListener("selectend", A), s.addEventListener("squeeze", A), s.addEventListener("squeezestart", A), s.addEventListener("squeezeend", A), s.addEventListener("end", D), s.addEventListener("inputsourceschange", B), g.xrCompatible !== !0 && await t.makeXRCompatible(), s.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const q = {
            antialias: s.renderState.layers === void 0 ? g.antialias : !0,
            alpha: !0,
            depth: g.depth,
            stencil: g.stencil,
            framebufferScaleFactor: r
          };
          f = new XRWebGLLayer(s, t, q), s.updateRenderState({ baseLayer: f }), v = new xt(
            f.framebufferWidth,
            f.framebufferHeight,
            {
              format: gi,
              type: ks,
              colorSpace: e.outputColorSpace,
              stencilBuffer: g.stencil
            }
          );
        } else {
          let q = null, ge = null, de = null;
          g.depth && (de = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, q = g.stencil ? Ar : gr, ge = g.stencil ? zs : Fs);
          const be = {
            colorFormat: t.RGBA8,
            depthFormat: de,
            scaleFactor: r
          };
          u = new XRWebGLBinding(s, t), d = u.createProjectionLayer(be), s.updateRenderState({ layers: [d] }), v = new xt(
            d.textureWidth,
            d.textureHeight,
            {
              format: gi,
              type: ks,
              depthTexture: new bd(d.textureWidth, d.textureHeight, ge, void 0, void 0, void 0, void 0, void 0, void 0, q),
              stencilBuffer: g.stencil,
              colorSpace: e.outputColorSpace,
              samples: g.antialias ? 4 : 0
            }
          );
          const Fe = e.properties.get(v);
          Fe.__ignoreDepthValues = d.ignoreDepthValues;
        }
        v.isXRRenderTarget = !0, this.setFoveation(l), c = null, a = await s.requestReferenceSpace(o), J.setContext(s), J.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (s !== null)
        return s.environmentBlendMode;
    };
    function B(N) {
      for (let q = 0; q < N.removed.length; q++) {
        const ge = N.removed[q], de = _.indexOf(ge);
        de >= 0 && (_[de] = null, y[de].disconnect(ge));
      }
      for (let q = 0; q < N.added.length; q++) {
        const ge = N.added[q];
        let de = _.indexOf(ge);
        if (de === -1) {
          for (let Fe = 0; Fe < y.length; Fe++)
            if (Fe >= _.length) {
              _.push(ge), de = Fe;
              break;
            } else if (_[Fe] === null) {
              _[Fe] = ge, de = Fe;
              break;
            }
          if (de === -1) break;
        }
        const be = y[de];
        be && be.connect(ge);
      }
    }
    const X = new T(), L = new T();
    function F(N, q, ge) {
      X.setFromMatrixPosition(q.matrixWorld), L.setFromMatrixPosition(ge.matrixWorld);
      const de = X.distanceTo(L), be = q.projectionMatrix.elements, Fe = ge.projectionMatrix.elements, ze = be[14] / (be[10] - 1), Ne = be[14] / (be[10] + 1), Xe = (be[9] + 1) / be[5], ct = (be[9] - 1) / be[5], He = (be[8] - 1) / be[0], I = (Fe[8] + 1) / Fe[0], xe = ze * He, ee = ze * I, ce = de / (-He + I), se = ce * -He;
      q.matrixWorld.decompose(N.position, N.quaternion, N.scale), N.translateX(se), N.translateZ(ce), N.matrixWorld.compose(N.position, N.quaternion, N.scale), N.matrixWorldInverse.copy(N.matrixWorld).invert();
      const De = ze + ce, Ee = Ne + ce, Re = xe - se, Ge = ee + (de - se), nt = Xe * Ne / Ee * De, Ct = ct * Ne / Ee * De;
      N.projectionMatrix.makePerspective(Re, Ge, nt, Ct, De, Ee), N.projectionMatrixInverse.copy(N.projectionMatrix).invert();
    }
    function H(N, q) {
      q === null ? N.matrixWorld.copy(N.matrix) : N.matrixWorld.multiplyMatrices(q.matrixWorld, N.matrix), N.matrixWorldInverse.copy(N.matrixWorld).invert();
    }
    this.updateCamera = function(N) {
      if (s === null) return;
      w.near = M.near = x.near = N.near, w.far = M.far = x.far = N.far, (E !== w.near || b !== w.far) && (s.updateRenderState({
        depthNear: w.near,
        depthFar: w.far
      }), E = w.near, b = w.far);
      const q = N.parent, ge = w.cameras;
      H(w, q);
      for (let de = 0; de < ge.length; de++)
        H(ge[de], q);
      ge.length === 2 ? F(w, x, M) : w.projectionMatrix.copy(x.projectionMatrix), G(N, w, q);
    };
    function G(N, q, ge) {
      ge === null ? N.matrix.copy(q.matrixWorld) : (N.matrix.copy(ge.matrixWorld), N.matrix.invert(), N.matrix.multiply(q.matrixWorld)), N.matrix.decompose(N.position, N.quaternion, N.scale), N.updateMatrixWorld(!0), N.projectionMatrix.copy(q.projectionMatrix), N.projectionMatrixInverse.copy(q.projectionMatrixInverse), N.isPerspectiveCamera && (N.fov = Ho * 2 * Math.atan(1 / N.projectionMatrix.elements[5]), N.zoom = 1);
    }
    this.getCamera = function() {
      return w;
    }, this.getFoveation = function() {
      if (!(d === null && f === null))
        return l;
    }, this.setFoveation = function(N) {
      l = N, d !== null && (d.fixedFoveation = N), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = N);
    };
    let te = null;
    function j(N, q) {
      if (h = q.getViewerPose(c || a), m = q, h !== null) {
        const ge = h.views;
        f !== null && (e.setRenderTargetFramebuffer(v, f.framebuffer), e.setRenderTarget(v));
        let de = !1;
        ge.length !== w.cameras.length && (w.cameras.length = 0, de = !0);
        for (let be = 0; be < ge.length; be++) {
          const Fe = ge[be];
          let ze = null;
          if (f !== null)
            ze = f.getViewport(Fe);
          else {
            const Xe = u.getViewSubImage(d, Fe);
            ze = Xe.viewport, be === 0 && (e.setRenderTargetTextures(
              v,
              Xe.colorTexture,
              d.ignoreDepthValues ? void 0 : Xe.depthStencilTexture
            ), e.setRenderTarget(v));
          }
          let Ne = S[be];
          Ne === void 0 && (Ne = new Zt(), Ne.layers.enable(be), Ne.viewport = new tt(), S[be] = Ne), Ne.matrix.fromArray(Fe.transform.matrix), Ne.matrix.decompose(Ne.position, Ne.quaternion, Ne.scale), Ne.projectionMatrix.fromArray(Fe.projectionMatrix), Ne.projectionMatrixInverse.copy(Ne.projectionMatrix).invert(), Ne.viewport.set(ze.x, ze.y, ze.width, ze.height), be === 0 && (w.matrix.copy(Ne.matrix), w.matrix.decompose(w.position, w.quaternion, w.scale)), de === !0 && w.cameras.push(Ne);
        }
      }
      for (let ge = 0; ge < y.length; ge++) {
        const de = _[ge], be = y[ge];
        de !== null && be !== void 0 && be.update(de, q, c || a);
      }
      te && te(N, q), q.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: q }), m = null;
    }
    const J = new Lx();
    J.setAnimationLoop(j), this.setAnimationLoop = function(N) {
      te = N;
    }, this.dispose = function() {
    };
  }
}
function LC(i, e) {
  function t(p, v) {
    p.matrixAutoUpdate === !0 && p.updateMatrix(), v.value.copy(p.matrix);
  }
  function n(p, v) {
    v.color.getRGB(p.fogColor.value, Cx(i)), v.isFog ? (p.fogNear.value = v.near, p.fogFar.value = v.far) : v.isFogExp2 && (p.fogDensity.value = v.density);
  }
  function s(p, v, y, _, x) {
    v.isMeshBasicMaterial || v.isMeshLambertMaterial ? r(p, v) : v.isMeshToonMaterial ? (r(p, v), u(p, v)) : v.isMeshPhongMaterial ? (r(p, v), h(p, v)) : v.isMeshStandardMaterial ? (r(p, v), d(p, v), v.isMeshPhysicalMaterial && f(p, v, x)) : v.isMeshMatcapMaterial ? (r(p, v), m(p, v)) : v.isMeshDepthMaterial ? r(p, v) : v.isMeshDistanceMaterial ? (r(p, v), g(p, v)) : v.isMeshNormalMaterial ? r(p, v) : v.isLineBasicMaterial ? (a(p, v), v.isLineDashedMaterial && o(p, v)) : v.isPointsMaterial ? l(p, v, y, _) : v.isSpriteMaterial ? c(p, v) : v.isShadowMaterial ? (p.color.value.copy(v.color), p.opacity.value = v.opacity) : v.isShaderMaterial && (v.uniformsNeedUpdate = !1);
  }
  function r(p, v) {
    p.opacity.value = v.opacity, v.color && p.diffuse.value.copy(v.color), v.emissive && p.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity), v.map && (p.map.value = v.map, t(v.map, p.mapTransform)), v.alphaMap && (p.alphaMap.value = v.alphaMap, t(v.alphaMap, p.alphaMapTransform)), v.bumpMap && (p.bumpMap.value = v.bumpMap, t(v.bumpMap, p.bumpMapTransform), p.bumpScale.value = v.bumpScale, v.side === Wn && (p.bumpScale.value *= -1)), v.normalMap && (p.normalMap.value = v.normalMap, t(v.normalMap, p.normalMapTransform), p.normalScale.value.copy(v.normalScale), v.side === Wn && p.normalScale.value.negate()), v.displacementMap && (p.displacementMap.value = v.displacementMap, t(v.displacementMap, p.displacementMapTransform), p.displacementScale.value = v.displacementScale, p.displacementBias.value = v.displacementBias), v.emissiveMap && (p.emissiveMap.value = v.emissiveMap, t(v.emissiveMap, p.emissiveMapTransform)), v.specularMap && (p.specularMap.value = v.specularMap, t(v.specularMap, p.specularMapTransform)), v.alphaTest > 0 && (p.alphaTest.value = v.alphaTest);
    const y = e.get(v).envMap;
    if (y && (p.envMap.value = y, p.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1, p.reflectivity.value = v.reflectivity, p.ior.value = v.ior, p.refractionRatio.value = v.refractionRatio), v.lightMap) {
      p.lightMap.value = v.lightMap;
      const _ = i._useLegacyLights === !0 ? Math.PI : 1;
      p.lightMapIntensity.value = v.lightMapIntensity * _, t(v.lightMap, p.lightMapTransform);
    }
    v.aoMap && (p.aoMap.value = v.aoMap, p.aoMapIntensity.value = v.aoMapIntensity, t(v.aoMap, p.aoMapTransform));
  }
  function a(p, v) {
    p.diffuse.value.copy(v.color), p.opacity.value = v.opacity, v.map && (p.map.value = v.map, t(v.map, p.mapTransform));
  }
  function o(p, v) {
    p.dashSize.value = v.dashSize, p.totalSize.value = v.dashSize + v.gapSize, p.scale.value = v.scale;
  }
  function l(p, v, y, _) {
    p.diffuse.value.copy(v.color), p.opacity.value = v.opacity, p.size.value = v.size * y, p.scale.value = _ * 0.5, v.map && (p.map.value = v.map, t(v.map, p.uvTransform)), v.alphaMap && (p.alphaMap.value = v.alphaMap, t(v.alphaMap, p.alphaMapTransform)), v.alphaTest > 0 && (p.alphaTest.value = v.alphaTest);
  }
  function c(p, v) {
    p.diffuse.value.copy(v.color), p.opacity.value = v.opacity, p.rotation.value = v.rotation, v.map && (p.map.value = v.map, t(v.map, p.mapTransform)), v.alphaMap && (p.alphaMap.value = v.alphaMap, t(v.alphaMap, p.alphaMapTransform)), v.alphaTest > 0 && (p.alphaTest.value = v.alphaTest);
  }
  function h(p, v) {
    p.specular.value.copy(v.specular), p.shininess.value = Math.max(v.shininess, 1e-4);
  }
  function u(p, v) {
    v.gradientMap && (p.gradientMap.value = v.gradientMap);
  }
  function d(p, v) {
    p.metalness.value = v.metalness, v.metalnessMap && (p.metalnessMap.value = v.metalnessMap, t(v.metalnessMap, p.metalnessMapTransform)), p.roughness.value = v.roughness, v.roughnessMap && (p.roughnessMap.value = v.roughnessMap, t(v.roughnessMap, p.roughnessMapTransform)), e.get(v).envMap && (p.envMapIntensity.value = v.envMapIntensity);
  }
  function f(p, v, y) {
    p.ior.value = v.ior, v.sheen > 0 && (p.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen), p.sheenRoughness.value = v.sheenRoughness, v.sheenColorMap && (p.sheenColorMap.value = v.sheenColorMap, t(v.sheenColorMap, p.sheenColorMapTransform)), v.sheenRoughnessMap && (p.sheenRoughnessMap.value = v.sheenRoughnessMap, t(v.sheenRoughnessMap, p.sheenRoughnessMapTransform))), v.clearcoat > 0 && (p.clearcoat.value = v.clearcoat, p.clearcoatRoughness.value = v.clearcoatRoughness, v.clearcoatMap && (p.clearcoatMap.value = v.clearcoatMap, t(v.clearcoatMap, p.clearcoatMapTransform)), v.clearcoatRoughnessMap && (p.clearcoatRoughnessMap.value = v.clearcoatRoughnessMap, t(v.clearcoatRoughnessMap, p.clearcoatRoughnessMapTransform)), v.clearcoatNormalMap && (p.clearcoatNormalMap.value = v.clearcoatNormalMap, t(v.clearcoatNormalMap, p.clearcoatNormalMapTransform), p.clearcoatNormalScale.value.copy(v.clearcoatNormalScale), v.side === Wn && p.clearcoatNormalScale.value.negate())), v.iridescence > 0 && (p.iridescence.value = v.iridescence, p.iridescenceIOR.value = v.iridescenceIOR, p.iridescenceThicknessMinimum.value = v.iridescenceThicknessRange[0], p.iridescenceThicknessMaximum.value = v.iridescenceThicknessRange[1], v.iridescenceMap && (p.iridescenceMap.value = v.iridescenceMap, t(v.iridescenceMap, p.iridescenceMapTransform)), v.iridescenceThicknessMap && (p.iridescenceThicknessMap.value = v.iridescenceThicknessMap, t(v.iridescenceThicknessMap, p.iridescenceThicknessMapTransform))), v.transmission > 0 && (p.transmission.value = v.transmission, p.transmissionSamplerMap.value = y.texture, p.transmissionSamplerSize.value.set(y.width, y.height), v.transmissionMap && (p.transmissionMap.value = v.transmissionMap, t(v.transmissionMap, p.transmissionMapTransform)), p.thickness.value = v.thickness, v.thicknessMap && (p.thicknessMap.value = v.thicknessMap, t(v.thicknessMap, p.thicknessMapTransform)), p.attenuationDistance.value = v.attenuationDistance, p.attenuationColor.value.copy(v.attenuationColor)), v.anisotropy > 0 && (p.anisotropyVector.value.set(v.anisotropy * Math.cos(v.anisotropyRotation), v.anisotropy * Math.sin(v.anisotropyRotation)), v.anisotropyMap && (p.anisotropyMap.value = v.anisotropyMap, t(v.anisotropyMap, p.anisotropyMapTransform))), p.specularIntensity.value = v.specularIntensity, p.specularColor.value.copy(v.specularColor), v.specularColorMap && (p.specularColorMap.value = v.specularColorMap, t(v.specularColorMap, p.specularColorMapTransform)), v.specularIntensityMap && (p.specularIntensityMap.value = v.specularIntensityMap, t(v.specularIntensityMap, p.specularIntensityMapTransform));
  }
  function m(p, v) {
    v.matcap && (p.matcap.value = v.matcap);
  }
  function g(p, v) {
    const y = e.get(v).light;
    p.referencePosition.value.setFromMatrixPosition(y.matrixWorld), p.nearDistance.value = y.shadow.camera.near, p.farDistance.value = y.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: s
  };
}
function IC(i, e, t, n) {
  let s = {}, r = {}, a = [];
  const o = t.isWebGL2 ? i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(y, _) {
    const x = _.program;
    n.uniformBlockBinding(y, x);
  }
  function c(y, _) {
    let x = s[y.id];
    x === void 0 && (m(y), x = h(y), s[y.id] = x, y.addEventListener("dispose", p));
    const M = _.program;
    n.updateUBOMapping(y, M);
    const S = e.render.frame;
    r[y.id] !== S && (d(y), r[y.id] = S);
  }
  function h(y) {
    const _ = u();
    y.__bindingPointIndex = _;
    const x = i.createBuffer(), M = y.__size, S = y.usage;
    return i.bindBuffer(i.UNIFORM_BUFFER, x), i.bufferData(i.UNIFORM_BUFFER, M, S), i.bindBuffer(i.UNIFORM_BUFFER, null), i.bindBufferBase(i.UNIFORM_BUFFER, _, x), x;
  }
  function u() {
    for (let y = 0; y < o; y++)
      if (a.indexOf(y) === -1)
        return a.push(y), y;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function d(y) {
    const _ = s[y.id], x = y.uniforms, M = y.__cache;
    i.bindBuffer(i.UNIFORM_BUFFER, _);
    for (let S = 0, w = x.length; S < w; S++) {
      const E = x[S];
      if (f(E, S, M) === !0) {
        const b = E.__offset, A = Array.isArray(E.value) ? E.value : [E.value];
        let D = 0;
        for (let B = 0; B < A.length; B++) {
          const X = A[B], L = g(X);
          typeof X == "number" ? (E.__data[0] = X, i.bufferSubData(i.UNIFORM_BUFFER, b + D, E.__data)) : X.isMatrix3 ? (E.__data[0] = X.elements[0], E.__data[1] = X.elements[1], E.__data[2] = X.elements[2], E.__data[3] = X.elements[0], E.__data[4] = X.elements[3], E.__data[5] = X.elements[4], E.__data[6] = X.elements[5], E.__data[7] = X.elements[0], E.__data[8] = X.elements[6], E.__data[9] = X.elements[7], E.__data[10] = X.elements[8], E.__data[11] = X.elements[0]) : (X.toArray(E.__data, D), D += L.storage / Float32Array.BYTES_PER_ELEMENT);
        }
        i.bufferSubData(i.UNIFORM_BUFFER, b, E.__data);
      }
    }
    i.bindBuffer(i.UNIFORM_BUFFER, null);
  }
  function f(y, _, x) {
    const M = y.value;
    if (x[_] === void 0) {
      if (typeof M == "number")
        x[_] = M;
      else {
        const S = Array.isArray(M) ? M : [M], w = [];
        for (let E = 0; E < S.length; E++)
          w.push(S[E].clone());
        x[_] = w;
      }
      return !0;
    } else if (typeof M == "number") {
      if (x[_] !== M)
        return x[_] = M, !0;
    } else {
      const S = Array.isArray(x[_]) ? x[_] : [x[_]], w = Array.isArray(M) ? M : [M];
      for (let E = 0; E < S.length; E++) {
        const b = S[E];
        if (b.equals(w[E]) === !1)
          return b.copy(w[E]), !0;
      }
    }
    return !1;
  }
  function m(y) {
    const _ = y.uniforms;
    let x = 0;
    const M = 16;
    let S = 0;
    for (let w = 0, E = _.length; w < E; w++) {
      const b = _[w], A = {
        boundary: 0,
        // bytes
        storage: 0
        // bytes
      }, D = Array.isArray(b.value) ? b.value : [b.value];
      for (let B = 0, X = D.length; B < X; B++) {
        const L = D[B], F = g(L);
        A.boundary += F.boundary, A.storage += F.storage;
      }
      if (b.__data = new Float32Array(A.storage / Float32Array.BYTES_PER_ELEMENT), b.__offset = x, w > 0) {
        S = x % M;
        const B = M - S;
        S !== 0 && B - A.boundary < 0 && (x += M - S, b.__offset = x);
      }
      x += A.storage;
    }
    return S = x % M, S > 0 && (x += M - S), y.__size = x, y.__cache = {}, this;
  }
  function g(y) {
    const _ = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof y == "number" ? (_.boundary = 4, _.storage = 4) : y.isVector2 ? (_.boundary = 8, _.storage = 8) : y.isVector3 || y.isColor ? (_.boundary = 16, _.storage = 12) : y.isVector4 ? (_.boundary = 16, _.storage = 16) : y.isMatrix3 ? (_.boundary = 48, _.storage = 48) : y.isMatrix4 ? (_.boundary = 64, _.storage = 64) : y.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", y), _;
  }
  function p(y) {
    const _ = y.target;
    _.removeEventListener("dispose", p);
    const x = a.indexOf(_.__bindingPointIndex);
    a.splice(x, 1), i.deleteBuffer(s[_.id]), delete s[_.id], delete r[_.id];
  }
  function v() {
    for (const y in s)
      i.deleteBuffer(s[y]);
    a = [], s = {}, r = {};
  }
  return {
    bind: l,
    update: c,
    dispose: v
  };
}
class Zm {
  constructor(e = {}) {
    const {
      canvas: t = Tx(),
      context: n = null,
      depth: s = !0,
      stencil: r = !0,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: u = !1
    } = e;
    this.isWebGLRenderer = !0;
    let d;
    n !== null ? d = n.getContextAttributes().alpha : d = a;
    const f = new Uint32Array(4), m = new Int32Array(4);
    let g = null, p = null;
    const v = [], y = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = ft, this._useLegacyLights = !1, this.toneMapping = ps, this.toneMappingExposure = 1;
    const _ = this;
    let x = !1, M = 0, S = 0, w = null, E = -1, b = null;
    const A = new tt(), D = new tt();
    let B = null;
    const X = new Q(0);
    let L = 0, F = t.width, H = t.height, G = 1, te = null, j = null;
    const J = new tt(0, 0, F, H), N = new tt(0, 0, F, H);
    let q = !1;
    const ge = new yd();
    let de = !1, be = !1, Fe = null;
    const ze = new _e(), Ne = new k(), Xe = new T(), ct = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function He() {
      return w === null ? G : 1;
    }
    let I = n;
    function xe(R, z) {
      for (let Y = 0; Y < R.length; Y++) {
        const Z = R[Y], $ = t.getContext(Z, z);
        if ($ !== null) return $;
      }
      return null;
    }
    try {
      const R = {
        alpha: !0,
        depth: s,
        stencil: r,
        antialias: o,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: h,
        failIfMajorPerformanceCaveat: u
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${td}`), t.addEventListener("webglcontextlost", rt, !1), t.addEventListener("webglcontextrestored", U, !1), t.addEventListener("webglcontextcreationerror", Me, !1), I === null) {
        const z = ["webgl2", "webgl", "experimental-webgl"];
        if (_.isWebGL1Renderer === !0 && z.shift(), I = xe(z, R), I === null)
          throw xe(z) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" && I instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), I.getShaderPrecisionFormat === void 0 && (I.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (R) {
      throw console.error("THREE.WebGLRenderer: " + R.message), R;
    }
    let ee, ce, se, De, Ee, Re, Ge, nt, Ct, P, C, W, he, ae, ue, Pe, pe, we, O, me, ie, Ve, Ie, ke;
    function Le() {
      ee = new YE(I), ce = new HE(I, ee, e), ee.init(ce), Ve = new Ux(I, ee, ce), se = new AC(I, ee, ce), De = new $E(I), Ee = new mC(), Re = new CC(I, ee, se, Ee, ce, Ve, De), Ge = new VE(_), nt = new qE(_), Ct = new aw(I, ce), Ie = new kE(I, ee, Ct, ce), P = new jE(I, Ct, De, Ie), C = new eA(I, P, Ct, De), O = new JE(I, ce, Re), Pe = new GE(Ee), W = new pC(_, Ge, nt, ee, ce, Ie, Pe), he = new LC(_, Ee), ae = new vC(), ue = new SC(ee, ce), we = new BE(_, Ge, nt, se, C, d, l), pe = new EC(_, C, ce), ke = new IC(I, De, ce, se), me = new zE(I, ee, De, ce), ie = new ZE(I, ee, De, ce), De.programs = W.programs, _.capabilities = ce, _.extensions = ee, _.properties = Ee, _.renderLists = ae, _.shadowMap = pe, _.state = se, _.info = De;
    }
    Le();
    const Ce = new PC(_, I);
    this.xr = Ce, this.getContext = function() {
      return I;
    }, this.getContextAttributes = function() {
      return I.getContextAttributes();
    }, this.forceContextLoss = function() {
      const R = ee.get("WEBGL_lose_context");
      R && R.loseContext();
    }, this.forceContextRestore = function() {
      const R = ee.get("WEBGL_lose_context");
      R && R.restoreContext();
    }, this.getPixelRatio = function() {
      return G;
    }, this.setPixelRatio = function(R) {
      R !== void 0 && (G = R, this.setSize(F, H, !1));
    }, this.getSize = function(R) {
      return R.set(F, H);
    }, this.setSize = function(R, z, Y = !0) {
      if (Ce.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      F = R, H = z, t.width = Math.floor(R * G), t.height = Math.floor(z * G), Y === !0 && (t.style.width = R + "px", t.style.height = z + "px"), this.setViewport(0, 0, R, z);
    }, this.getDrawingBufferSize = function(R) {
      return R.set(F * G, H * G).floor();
    }, this.setDrawingBufferSize = function(R, z, Y) {
      F = R, H = z, G = Y, t.width = Math.floor(R * Y), t.height = Math.floor(z * Y), this.setViewport(0, 0, R, z);
    }, this.getCurrentViewport = function(R) {
      return R.copy(A);
    }, this.getViewport = function(R) {
      return R.copy(J);
    }, this.setViewport = function(R, z, Y, Z) {
      R.isVector4 ? J.set(R.x, R.y, R.z, R.w) : J.set(R, z, Y, Z), se.viewport(A.copy(J).multiplyScalar(G).floor());
    }, this.getScissor = function(R) {
      return R.copy(N);
    }, this.setScissor = function(R, z, Y, Z) {
      R.isVector4 ? N.set(R.x, R.y, R.z, R.w) : N.set(R, z, Y, Z), se.scissor(D.copy(N).multiplyScalar(G).floor());
    }, this.getScissorTest = function() {
      return q;
    }, this.setScissorTest = function(R) {
      se.setScissorTest(q = R);
    }, this.setOpaqueSort = function(R) {
      te = R;
    }, this.setTransparentSort = function(R) {
      j = R;
    }, this.getClearColor = function(R) {
      return R.copy(we.getClearColor());
    }, this.setClearColor = function() {
      we.setClearColor.apply(we, arguments);
    }, this.getClearAlpha = function() {
      return we.getClearAlpha();
    }, this.setClearAlpha = function() {
      we.setClearAlpha.apply(we, arguments);
    }, this.clear = function(R = !0, z = !0, Y = !0) {
      let Z = 0;
      if (R) {
        let $ = !1;
        if (w !== null) {
          const Ae = w.texture.format;
          $ = Ae === Um || Ae === Nm || Ae === Om;
        }
        if ($) {
          const Ae = w.texture.type, Oe = Ae === ks || Ae === Fs || Ae === Nc || Ae === zs || Ae === Im || Ae === Dm, We = we.getClearColor(), qe = we.getClearAlpha(), et = We.r, je = We.g, $e = We.b;
          Oe ? (f[0] = et, f[1] = je, f[2] = $e, f[3] = qe, I.clearBufferuiv(I.COLOR, 0, f)) : (m[0] = et, m[1] = je, m[2] = $e, m[3] = qe, I.clearBufferiv(I.COLOR, 0, m));
        } else
          Z |= I.COLOR_BUFFER_BIT;
      }
      z && (Z |= I.DEPTH_BUFFER_BIT), Y && (Z |= I.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), I.clear(Z);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", rt, !1), t.removeEventListener("webglcontextrestored", U, !1), t.removeEventListener("webglcontextcreationerror", Me, !1), ae.dispose(), ue.dispose(), Ee.dispose(), Ge.dispose(), nt.dispose(), C.dispose(), Ie.dispose(), ke.dispose(), W.dispose(), Ce.dispose(), Ce.removeEventListener("sessionstart", Ti), Ce.removeEventListener("sessionend", wt), Fe && (Fe.dispose(), Fe = null), On.stop();
    };
    function rt(R) {
      R.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0;
    }
    function U() {
      console.log("THREE.WebGLRenderer: Context Restored."), x = !1;
      const R = De.autoReset, z = pe.enabled, Y = pe.autoUpdate, Z = pe.needsUpdate, $ = pe.type;
      Le(), De.autoReset = R, pe.enabled = z, pe.autoUpdate = Y, pe.needsUpdate = Z, pe.type = $;
    }
    function Me(R) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", R.statusMessage);
    }
    function oe(R) {
      const z = R.target;
      z.removeEventListener("dispose", oe), K(z);
    }
    function K(R) {
      fe(R), Ee.remove(R);
    }
    function fe(R) {
      const z = Ee.get(R).programs;
      z !== void 0 && (z.forEach(function(Y) {
        W.releaseProgram(Y);
      }), R.isShaderMaterial && W.releaseShaderCache(R));
    }
    this.renderBufferDirect = function(R, z, Y, Z, $, Ae) {
      z === null && (z = ct);
      const Oe = $.isMesh && $.matrixWorld.determinant() < 0, We = O1(R, z, Y, Z, $);
      se.setMaterial(Z, Oe);
      let qe = Y.index, et = 1;
      if (Z.wireframe === !0) {
        if (qe = P.getWireframeAttribute(Y), qe === void 0) return;
        et = 2;
      }
      const je = Y.drawRange, $e = Y.attributes.position;
      let Wt = je.start * et, ci = (je.start + je.count) * et;
      Ae !== null && (Wt = Math.max(Wt, Ae.start * et), ci = Math.min(ci, (Ae.start + Ae.count) * et)), qe !== null ? (Wt = Math.max(Wt, 0), ci = Math.min(ci, qe.count)) : $e != null && (Wt = Math.max(Wt, 0), ci = Math.min(ci, $e.count));
      const dn = ci - Wt;
      if (dn < 0 || dn === 1 / 0) return;
      Ie.setup($, Z, We, Y, qe);
      let Es, Bt = me;
      if (qe !== null && (Es = Ct.get(qe), Bt = ie, Bt.setIndex(Es)), $.isMesh)
        Z.wireframe === !0 ? (se.setLineWidth(Z.wireframeLinewidth * He()), Bt.setMode(I.LINES)) : Bt.setMode(I.TRIANGLES);
      else if ($.isLine) {
        let ot = Z.linewidth;
        ot === void 0 && (ot = 1), se.setLineWidth(ot * He()), $.isLineSegments ? Bt.setMode(I.LINES) : $.isLineLoop ? Bt.setMode(I.LINE_LOOP) : Bt.setMode(I.LINE_STRIP);
      } else $.isPoints ? Bt.setMode(I.POINTS) : $.isSprite && Bt.setMode(I.TRIANGLES);
      if ($.isInstancedMesh)
        Bt.renderInstances(Wt, dn, $.count);
      else if (Y.isInstancedBufferGeometry) {
        const ot = Y._maxInstanceCount !== void 0 ? Y._maxInstanceCount : 1 / 0, qd = Math.min(Y.instanceCount, ot);
        Bt.renderInstances(Wt, dn, qd);
      } else
        Bt.render(Wt, dn);
    };
    function Ue(R, z, Y) {
      R.transparent === !0 && R.side === $t && R.forceSinglePass === !1 ? (R.side = Wn, R.needsUpdate = !0, ih(R, z, Y), R.side = Wi, R.needsUpdate = !0, ih(R, z, Y), R.side = $t) : ih(R, z, Y);
    }
    this.compile = function(R, z, Y = null) {
      Y === null && (Y = R), p = ue.get(Y), p.init(), y.push(p), Y.traverseVisible(function($) {
        $.isLight && $.layers.test(z.layers) && (p.pushLight($), $.castShadow && p.pushShadow($));
      }), R !== Y && R.traverseVisible(function($) {
        $.isLight && $.layers.test(z.layers) && (p.pushLight($), $.castShadow && p.pushShadow($));
      }), p.setupLights(_._useLegacyLights);
      const Z = /* @__PURE__ */ new Set();
      return R.traverse(function($) {
        const Ae = $.material;
        if (Ae)
          if (Array.isArray(Ae))
            for (let Oe = 0; Oe < Ae.length; Oe++) {
              const We = Ae[Oe];
              Ue(We, Y, $), Z.add(We);
            }
          else
            Ue(Ae, Y, $), Z.add(Ae);
      }), y.pop(), p = null, Z;
    }, this.compileAsync = function(R, z, Y = null) {
      const Z = this.compile(R, z, Y);
      return new Promise(($) => {
        function Ae() {
          if (Z.forEach(function(Oe) {
            Ee.get(Oe).currentProgram.isReady() && Z.delete(Oe);
          }), Z.size === 0) {
            $(R);
            return;
          }
          setTimeout(Ae, 10);
        }
        ee.get("KHR_parallel_shader_compile") !== null ? Ae() : setTimeout(Ae, 10);
      });
    };
    let at = null;
    function tn(R) {
      at && at(R);
    }
    function Ti() {
      On.stop();
    }
    function wt() {
      On.start();
    }
    const On = new Lx();
    On.setAnimationLoop(tn), typeof self < "u" && On.setContext(self), this.setAnimationLoop = function(R) {
      at = R, Ce.setAnimationLoop(R), R === null ? On.stop() : On.start();
    }, Ce.addEventListener("sessionstart", Ti), Ce.addEventListener("sessionend", wt), this.render = function(R, z) {
      if (z !== void 0 && z.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (x === !0) return;
      R.matrixWorldAutoUpdate === !0 && R.updateMatrixWorld(), z.parent === null && z.matrixWorldAutoUpdate === !0 && z.updateMatrixWorld(), Ce.enabled === !0 && Ce.isPresenting === !0 && (Ce.cameraAutoUpdate === !0 && Ce.updateCamera(z), z = Ce.getCamera()), R.isScene === !0 && R.onBeforeRender(_, R, z, w), p = ue.get(R, y.length), p.init(), y.push(p), ze.multiplyMatrices(z.projectionMatrix, z.matrixWorldInverse), ge.setFromProjectionMatrix(ze), be = this.localClippingEnabled, de = Pe.init(this.clippingPlanes, be), g = ae.get(R, v.length), g.init(), v.push(g), Zi(R, z, 0, _.sortObjects), g.finish(), _.sortObjects === !0 && g.sort(te, j), this.info.render.frame++, de === !0 && Pe.beginShadows();
      const Y = p.state.shadowsArray;
      if (pe.render(Y, R, z), de === !0 && Pe.endShadows(), this.info.autoReset === !0 && this.info.reset(), we.render(g, R), p.setupLights(_._useLegacyLights), z.isArrayCamera) {
        const Z = z.cameras;
        for (let $ = 0, Ae = Z.length; $ < Ae; $++) {
          const Oe = Z[$];
          d0(g, R, Oe, Oe.viewport);
        }
      } else
        d0(g, R, z);
      w !== null && (Re.updateMultisampleRenderTarget(w), Re.updateRenderTargetMipmap(w)), R.isScene === !0 && R.onAfterRender(_, R, z), Ie.resetDefaultState(), E = -1, b = null, y.pop(), y.length > 0 ? p = y[y.length - 1] : p = null, v.pop(), v.length > 0 ? g = v[v.length - 1] : g = null;
    };
    function Zi(R, z, Y, Z) {
      if (R.visible === !1) return;
      if (R.layers.test(z.layers)) {
        if (R.isGroup)
          Y = R.renderOrder;
        else if (R.isLOD)
          R.autoUpdate === !0 && R.update(z);
        else if (R.isLight)
          p.pushLight(R), R.castShadow && p.pushShadow(R);
        else if (R.isSprite) {
          if (!R.frustumCulled || ge.intersectsSprite(R)) {
            Z && Xe.setFromMatrixPosition(R.matrixWorld).applyMatrix4(ze);
            const Oe = C.update(R), We = R.material;
            We.visible && g.push(R, Oe, We, Y, Xe.z, null);
          }
        } else if ((R.isMesh || R.isLine || R.isPoints) && (!R.frustumCulled || ge.intersectsObject(R))) {
          const Oe = C.update(R), We = R.material;
          if (Z && (R.boundingSphere !== void 0 ? (R.boundingSphere === null && R.computeBoundingSphere(), Xe.copy(R.boundingSphere.center)) : (Oe.boundingSphere === null && Oe.computeBoundingSphere(), Xe.copy(Oe.boundingSphere.center)), Xe.applyMatrix4(R.matrixWorld).applyMatrix4(ze)), Array.isArray(We)) {
            const qe = Oe.groups;
            for (let et = 0, je = qe.length; et < je; et++) {
              const $e = qe[et], Wt = We[$e.materialIndex];
              Wt && Wt.visible && g.push(R, Oe, Wt, Y, Xe.z, $e);
            }
          } else We.visible && g.push(R, Oe, We, Y, Xe.z, null);
        }
      }
      const Ae = R.children;
      for (let Oe = 0, We = Ae.length; Oe < We; Oe++)
        Zi(Ae[Oe], z, Y, Z);
    }
    function d0(R, z, Y, Z) {
      const $ = R.opaque, Ae = R.transmissive, Oe = R.transparent;
      p.setupLightsView(Y), de === !0 && Pe.setGlobalState(_.clippingPlanes, Y), Ae.length > 0 && D1($, Ae, z, Y), Z && se.viewport(A.copy(Z)), $.length > 0 && nh($, z, Y), Ae.length > 0 && nh(Ae, z, Y), Oe.length > 0 && nh(Oe, z, Y), se.buffers.depth.setTest(!0), se.buffers.depth.setMask(!0), se.buffers.color.setMask(!0), se.setPolygonOffset(!1);
    }
    function D1(R, z, Y, Z) {
      if ((Y.isScene === !0 ? Y.overrideMaterial : null) !== null)
        return;
      const Ae = ce.isWebGL2;
      Fe === null && (Fe = new xt(1, 1, {
        generateMipmaps: !0,
        type: ee.has("EXT_color_buffer_half_float") ? zt : ks,
        minFilter: ys,
        samples: Ae ? 4 : 0
      })), _.getDrawingBufferSize(Ne), Ae ? Fe.setSize(Ne.x, Ne.y) : Fe.setSize(Lu(Ne.x), Lu(Ne.y));
      const Oe = _.getRenderTarget();
      _.setRenderTarget(Fe), _.getClearColor(X), L = _.getClearAlpha(), L < 1 && _.setClearColor(16777215, 0.5), _.clear();
      const We = _.toneMapping;
      _.toneMapping = ps, nh(R, Y, Z), Re.updateMultisampleRenderTarget(Fe), Re.updateRenderTargetMipmap(Fe);
      let qe = !1;
      for (let et = 0, je = z.length; et < je; et++) {
        const $e = z[et], Wt = $e.object, ci = $e.geometry, dn = $e.material, Es = $e.group;
        if (dn.side === $t && Wt.layers.test(Z.layers)) {
          const Bt = dn.side;
          dn.side = Wn, dn.needsUpdate = !0, f0(Wt, Y, Z, ci, dn, Es), dn.side = Bt, dn.needsUpdate = !0, qe = !0;
        }
      }
      qe === !0 && (Re.updateMultisampleRenderTarget(Fe), Re.updateRenderTargetMipmap(Fe)), _.setRenderTarget(Oe), _.setClearColor(X, L), _.toneMapping = We;
    }
    function nh(R, z, Y) {
      const Z = z.isScene === !0 ? z.overrideMaterial : null;
      for (let $ = 0, Ae = R.length; $ < Ae; $++) {
        const Oe = R[$], We = Oe.object, qe = Oe.geometry, et = Z === null ? Oe.material : Z, je = Oe.group;
        We.layers.test(Y.layers) && f0(We, z, Y, qe, et, je);
      }
    }
    function f0(R, z, Y, Z, $, Ae) {
      R.onBeforeRender(_, z, Y, Z, $, Ae), R.modelViewMatrix.multiplyMatrices(Y.matrixWorldInverse, R.matrixWorld), R.normalMatrix.getNormalMatrix(R.modelViewMatrix), $.onBeforeRender(_, z, Y, Z, R, Ae), $.transparent === !0 && $.side === $t && $.forceSinglePass === !1 ? ($.side = Wn, $.needsUpdate = !0, _.renderBufferDirect(Y, z, Z, $, R, Ae), $.side = Wi, $.needsUpdate = !0, _.renderBufferDirect(Y, z, Z, $, R, Ae), $.side = $t) : _.renderBufferDirect(Y, z, Z, $, R, Ae), R.onAfterRender(_, z, Y, Z, $, Ae);
    }
    function ih(R, z, Y) {
      z.isScene !== !0 && (z = ct);
      const Z = Ee.get(R), $ = p.state.lights, Ae = p.state.shadowsArray, Oe = $.state.version, We = W.getParameters(R, $.state, Ae, z, Y), qe = W.getProgramCacheKey(We);
      let et = Z.programs;
      Z.environment = R.isMeshStandardMaterial ? z.environment : null, Z.fog = z.fog, Z.envMap = (R.isMeshStandardMaterial ? nt : Ge).get(R.envMap || Z.environment), et === void 0 && (R.addEventListener("dispose", oe), et = /* @__PURE__ */ new Map(), Z.programs = et);
      let je = et.get(qe);
      if (je !== void 0) {
        if (Z.currentProgram === je && Z.lightsStateVersion === Oe)
          return m0(R, We), je;
      } else
        We.uniforms = W.getUniforms(R), R.onBuild(Y, We, _), R.onBeforeCompile(We, _), je = W.acquireProgram(We, qe), et.set(qe, je), Z.uniforms = We.uniforms;
      const $e = Z.uniforms;
      return (!R.isShaderMaterial && !R.isRawShaderMaterial || R.clipping === !0) && ($e.clippingPlanes = Pe.uniform), m0(R, We), Z.needsLights = U1(R), Z.lightsStateVersion = Oe, Z.needsLights && ($e.ambientLightColor.value = $.state.ambient, $e.lightProbe.value = $.state.probe, $e.directionalLights.value = $.state.directional, $e.directionalLightShadows.value = $.state.directionalShadow, $e.spotLights.value = $.state.spot, $e.spotLightShadows.value = $.state.spotShadow, $e.rectAreaLights.value = $.state.rectArea, $e.ltc_1.value = $.state.rectAreaLTC1, $e.ltc_2.value = $.state.rectAreaLTC2, $e.pointLights.value = $.state.point, $e.pointLightShadows.value = $.state.pointShadow, $e.hemisphereLights.value = $.state.hemi, $e.directionalShadowMap.value = $.state.directionalShadowMap, $e.directionalShadowMatrix.value = $.state.directionalShadowMatrix, $e.spotShadowMap.value = $.state.spotShadowMap, $e.spotLightMatrix.value = $.state.spotLightMatrix, $e.spotLightMap.value = $.state.spotLightMap, $e.pointShadowMap.value = $.state.pointShadowMap, $e.pointShadowMatrix.value = $.state.pointShadowMatrix), Z.currentProgram = je, Z.uniformsList = null, je;
    }
    function p0(R) {
      if (R.uniformsList === null) {
        const z = R.currentProgram.getUniforms();
        R.uniformsList = gu.seqWithValue(z.seq, R.uniforms);
      }
      return R.uniformsList;
    }
    function m0(R, z) {
      const Y = Ee.get(R);
      Y.outputColorSpace = z.outputColorSpace, Y.instancing = z.instancing, Y.instancingColor = z.instancingColor, Y.skinning = z.skinning, Y.morphTargets = z.morphTargets, Y.morphNormals = z.morphNormals, Y.morphColors = z.morphColors, Y.morphTargetsCount = z.morphTargetsCount, Y.numClippingPlanes = z.numClippingPlanes, Y.numIntersection = z.numClipIntersection, Y.vertexAlphas = z.vertexAlphas, Y.vertexTangents = z.vertexTangents, Y.toneMapping = z.toneMapping;
    }
    function O1(R, z, Y, Z, $) {
      z.isScene !== !0 && (z = ct), Re.resetTextureUnits();
      const Ae = z.fog, Oe = Z.isMeshStandardMaterial ? z.environment : null, We = w === null ? _.outputColorSpace : w.isXRRenderTarget === !0 ? w.texture.colorSpace : en, qe = (Z.isMeshStandardMaterial ? nt : Ge).get(Z.envMap || Oe), et = Z.vertexColors === !0 && !!Y.attributes.color && Y.attributes.color.itemSize === 4, je = !!Y.attributes.tangent && (!!Z.normalMap || Z.anisotropy > 0), $e = !!Y.morphAttributes.position, Wt = !!Y.morphAttributes.normal, ci = !!Y.morphAttributes.color;
      let dn = ps;
      Z.toneMapped && (w === null || w.isXRRenderTarget === !0) && (dn = _.toneMapping);
      const Es = Y.morphAttributes.position || Y.morphAttributes.normal || Y.morphAttributes.color, Bt = Es !== void 0 ? Es.length : 0, ot = Ee.get(Z), qd = p.state.lights;
      if (de === !0 && (be === !0 || R !== b)) {
        const hi = R === b && Z.id === E;
        Pe.setState(Z, R, hi);
      }
      let nn = !1;
      Z.version === ot.__version ? (ot.needsLights && ot.lightsStateVersion !== qd.state.version || ot.outputColorSpace !== We || $.isInstancedMesh && ot.instancing === !1 || !$.isInstancedMesh && ot.instancing === !0 || $.isSkinnedMesh && ot.skinning === !1 || !$.isSkinnedMesh && ot.skinning === !0 || $.isInstancedMesh && ot.instancingColor === !0 && $.instanceColor === null || $.isInstancedMesh && ot.instancingColor === !1 && $.instanceColor !== null || ot.envMap !== qe || Z.fog === !0 && ot.fog !== Ae || ot.numClippingPlanes !== void 0 && (ot.numClippingPlanes !== Pe.numPlanes || ot.numIntersection !== Pe.numIntersection) || ot.vertexAlphas !== et || ot.vertexTangents !== je || ot.morphTargets !== $e || ot.morphNormals !== Wt || ot.morphColors !== ci || ot.toneMapping !== dn || ce.isWebGL2 === !0 && ot.morphTargetsCount !== Bt) && (nn = !0) : (nn = !0, ot.__version = Z.version);
      let Xr = ot.currentProgram;
      nn === !0 && (Xr = ih(Z, z, $));
      let g0 = !1, ul = !1, Yd = !1;
      const Nn = Xr.getUniforms(), qr = ot.uniforms;
      if (se.useProgram(Xr.program) && (g0 = !0, ul = !0, Yd = !0), Z.id !== E && (E = Z.id, ul = !0), g0 || b !== R) {
        Nn.setValue(I, "projectionMatrix", R.projectionMatrix), Nn.setValue(I, "viewMatrix", R.matrixWorldInverse);
        const hi = Nn.map.cameraPosition;
        hi !== void 0 && hi.setValue(I, Xe.setFromMatrixPosition(R.matrixWorld)), ce.logarithmicDepthBuffer && Nn.setValue(
          I,
          "logDepthBufFC",
          2 / (Math.log(R.far + 1) / Math.LN2)
        ), (Z.isMeshPhongMaterial || Z.isMeshToonMaterial || Z.isMeshLambertMaterial || Z.isMeshBasicMaterial || Z.isMeshStandardMaterial || Z.isShaderMaterial) && Nn.setValue(I, "isOrthographic", R.isOrthographicCamera === !0), b !== R && (b = R, ul = !0, Yd = !0);
      }
      if ($.isSkinnedMesh) {
        Nn.setOptional(I, $, "bindMatrix"), Nn.setOptional(I, $, "bindMatrixInverse");
        const hi = $.skeleton;
        hi && (ce.floatVertexTextures ? (hi.boneTexture === null && hi.computeBoneTexture(), Nn.setValue(I, "boneTexture", hi.boneTexture, Re), Nn.setValue(I, "boneTextureSize", hi.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      const jd = Y.morphAttributes;
      if ((jd.position !== void 0 || jd.normal !== void 0 || jd.color !== void 0 && ce.isWebGL2 === !0) && O.update($, Y, Xr), (ul || ot.receiveShadow !== $.receiveShadow) && (ot.receiveShadow = $.receiveShadow, Nn.setValue(I, "receiveShadow", $.receiveShadow)), Z.isMeshGouraudMaterial && Z.envMap !== null && (qr.envMap.value = qe, qr.flipEnvMap.value = qe.isCubeTexture && qe.isRenderTargetTexture === !1 ? -1 : 1), ul && (Nn.setValue(I, "toneMappingExposure", _.toneMappingExposure), ot.needsLights && N1(qr, Yd), Ae && Z.fog === !0 && he.refreshFogUniforms(qr, Ae), he.refreshMaterialUniforms(qr, Z, G, H, Fe), gu.upload(I, p0(ot), qr, Re)), Z.isShaderMaterial && Z.uniformsNeedUpdate === !0 && (gu.upload(I, p0(ot), qr, Re), Z.uniformsNeedUpdate = !1), Z.isSpriteMaterial && Nn.setValue(I, "center", $.center), Nn.setValue(I, "modelViewMatrix", $.modelViewMatrix), Nn.setValue(I, "normalMatrix", $.normalMatrix), Nn.setValue(I, "modelMatrix", $.matrixWorld), Z.isShaderMaterial || Z.isRawShaderMaterial) {
        const hi = Z.uniformsGroups;
        for (let Zd = 0, F1 = hi.length; Zd < F1; Zd++)
          if (ce.isWebGL2) {
            const v0 = hi[Zd];
            ke.update(v0, Xr), ke.bind(v0, Xr);
          } else
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return Xr;
    }
    function N1(R, z) {
      R.ambientLightColor.needsUpdate = z, R.lightProbe.needsUpdate = z, R.directionalLights.needsUpdate = z, R.directionalLightShadows.needsUpdate = z, R.pointLights.needsUpdate = z, R.pointLightShadows.needsUpdate = z, R.spotLights.needsUpdate = z, R.spotLightShadows.needsUpdate = z, R.rectAreaLights.needsUpdate = z, R.hemisphereLights.needsUpdate = z;
    }
    function U1(R) {
      return R.isMeshLambertMaterial || R.isMeshToonMaterial || R.isMeshPhongMaterial || R.isMeshStandardMaterial || R.isShadowMaterial || R.isShaderMaterial && R.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return M;
    }, this.getActiveMipmapLevel = function() {
      return S;
    }, this.getRenderTarget = function() {
      return w;
    }, this.setRenderTargetTextures = function(R, z, Y) {
      Ee.get(R.texture).__webglTexture = z, Ee.get(R.depthTexture).__webglTexture = Y;
      const Z = Ee.get(R);
      Z.__hasExternalTextures = !0, Z.__hasExternalTextures && (Z.__autoAllocateDepthBuffer = Y === void 0, Z.__autoAllocateDepthBuffer || ee.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Z.__useRenderToTexture = !1));
    }, this.setRenderTargetFramebuffer = function(R, z) {
      const Y = Ee.get(R);
      Y.__webglFramebuffer = z, Y.__useDefaultFramebuffer = z === void 0;
    }, this.setRenderTarget = function(R, z = 0, Y = 0) {
      w = R, M = z, S = Y;
      let Z = !0, $ = null, Ae = !1, Oe = !1;
      if (R) {
        const qe = Ee.get(R);
        qe.__useDefaultFramebuffer !== void 0 ? (se.bindFramebuffer(I.FRAMEBUFFER, null), Z = !1) : qe.__webglFramebuffer === void 0 ? Re.setupRenderTarget(R) : qe.__hasExternalTextures && Re.rebindTextures(R, Ee.get(R.texture).__webglTexture, Ee.get(R.depthTexture).__webglTexture);
        const et = R.texture;
        (et.isData3DTexture || et.isDataArrayTexture || et.isCompressedArrayTexture) && (Oe = !0);
        const je = Ee.get(R).__webglFramebuffer;
        R.isWebGLCubeRenderTarget ? (Array.isArray(je[z]) ? $ = je[z][Y] : $ = je[z], Ae = !0) : ce.isWebGL2 && R.samples > 0 && Re.useMultisampledRTT(R) === !1 ? $ = Ee.get(R).__webglMultisampledFramebuffer : Array.isArray(je) ? $ = je[Y] : $ = je, A.copy(R.viewport), D.copy(R.scissor), B = R.scissorTest;
      } else
        A.copy(J).multiplyScalar(G).floor(), D.copy(N).multiplyScalar(G).floor(), B = q;
      if (se.bindFramebuffer(I.FRAMEBUFFER, $) && ce.drawBuffers && Z && se.drawBuffers(R, $), se.viewport(A), se.scissor(D), se.setScissorTest(B), Ae) {
        const qe = Ee.get(R.texture);
        I.framebufferTexture2D(I.FRAMEBUFFER, I.COLOR_ATTACHMENT0, I.TEXTURE_CUBE_MAP_POSITIVE_X + z, qe.__webglTexture, Y);
      } else if (Oe) {
        const qe = Ee.get(R.texture), et = z || 0;
        I.framebufferTextureLayer(I.FRAMEBUFFER, I.COLOR_ATTACHMENT0, qe.__webglTexture, Y || 0, et);
      }
      E = -1;
    }, this.readRenderTargetPixels = function(R, z, Y, Z, $, Ae, Oe) {
      if (!(R && R.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let We = Ee.get(R).__webglFramebuffer;
      if (R.isWebGLCubeRenderTarget && Oe !== void 0 && (We = We[Oe]), We) {
        se.bindFramebuffer(I.FRAMEBUFFER, We);
        try {
          const qe = R.texture, et = qe.format, je = qe.type;
          if (et !== gi && Ve.convert(et) !== I.getParameter(I.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const $e = je === zt && (ee.has("EXT_color_buffer_half_float") || ce.isWebGL2 && ee.has("EXT_color_buffer_float"));
          if (je !== ks && Ve.convert(je) !== I.getParameter(I.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
          !(je === hs && (ce.isWebGL2 || ee.has("OES_texture_float") || ee.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !$e) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          z >= 0 && z <= R.width - Z && Y >= 0 && Y <= R.height - $ && I.readPixels(z, Y, Z, $, Ve.convert(et), Ve.convert(je), Ae);
        } finally {
          const qe = w !== null ? Ee.get(w).__webglFramebuffer : null;
          se.bindFramebuffer(I.FRAMEBUFFER, qe);
        }
      }
    }, this.copyFramebufferToTexture = function(R, z, Y = 0) {
      const Z = Math.pow(2, -Y), $ = Math.floor(z.image.width * Z), Ae = Math.floor(z.image.height * Z);
      Re.setTexture2D(z, 0), I.copyTexSubImage2D(I.TEXTURE_2D, Y, 0, 0, R.x, R.y, $, Ae), se.unbindTexture();
    }, this.copyTextureToTexture = function(R, z, Y, Z = 0) {
      const $ = z.image.width, Ae = z.image.height, Oe = Ve.convert(Y.format), We = Ve.convert(Y.type);
      Re.setTexture2D(Y, 0), I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL, Y.flipY), I.pixelStorei(I.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Y.premultiplyAlpha), I.pixelStorei(I.UNPACK_ALIGNMENT, Y.unpackAlignment), z.isDataTexture ? I.texSubImage2D(I.TEXTURE_2D, Z, R.x, R.y, $, Ae, Oe, We, z.image.data) : z.isCompressedTexture ? I.compressedTexSubImage2D(I.TEXTURE_2D, Z, R.x, R.y, z.mipmaps[0].width, z.mipmaps[0].height, Oe, z.mipmaps[0].data) : I.texSubImage2D(I.TEXTURE_2D, Z, R.x, R.y, Oe, We, z.image), Z === 0 && Y.generateMipmaps && I.generateMipmap(I.TEXTURE_2D), se.unbindTexture();
    }, this.copyTextureToTexture3D = function(R, z, Y, Z, $ = 0) {
      if (_.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const Ae = R.max.x - R.min.x + 1, Oe = R.max.y - R.min.y + 1, We = R.max.z - R.min.z + 1, qe = Ve.convert(Z.format), et = Ve.convert(Z.type);
      let je;
      if (Z.isData3DTexture)
        Re.setTexture3D(Z, 0), je = I.TEXTURE_3D;
      else if (Z.isDataArrayTexture)
        Re.setTexture2DArray(Z, 0), je = I.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL, Z.flipY), I.pixelStorei(I.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Z.premultiplyAlpha), I.pixelStorei(I.UNPACK_ALIGNMENT, Z.unpackAlignment);
      const $e = I.getParameter(I.UNPACK_ROW_LENGTH), Wt = I.getParameter(I.UNPACK_IMAGE_HEIGHT), ci = I.getParameter(I.UNPACK_SKIP_PIXELS), dn = I.getParameter(I.UNPACK_SKIP_ROWS), Es = I.getParameter(I.UNPACK_SKIP_IMAGES), Bt = Y.isCompressedTexture ? Y.mipmaps[0] : Y.image;
      I.pixelStorei(I.UNPACK_ROW_LENGTH, Bt.width), I.pixelStorei(I.UNPACK_IMAGE_HEIGHT, Bt.height), I.pixelStorei(I.UNPACK_SKIP_PIXELS, R.min.x), I.pixelStorei(I.UNPACK_SKIP_ROWS, R.min.y), I.pixelStorei(I.UNPACK_SKIP_IMAGES, R.min.z), Y.isDataTexture || Y.isData3DTexture ? I.texSubImage3D(je, $, z.x, z.y, z.z, Ae, Oe, We, qe, et, Bt.data) : Y.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), I.compressedTexSubImage3D(je, $, z.x, z.y, z.z, Ae, Oe, We, qe, Bt.data)) : I.texSubImage3D(je, $, z.x, z.y, z.z, Ae, Oe, We, qe, et, Bt), I.pixelStorei(I.UNPACK_ROW_LENGTH, $e), I.pixelStorei(I.UNPACK_IMAGE_HEIGHT, Wt), I.pixelStorei(I.UNPACK_SKIP_PIXELS, ci), I.pixelStorei(I.UNPACK_SKIP_ROWS, dn), I.pixelStorei(I.UNPACK_SKIP_IMAGES, Es), $ === 0 && Z.generateMipmaps && I.generateMipmap(je), se.unbindTexture();
    }, this.initTexture = function(R) {
      R.isCubeTexture ? Re.setTextureCube(R, 0) : R.isData3DTexture ? Re.setTexture3D(R, 0) : R.isDataArrayTexture || R.isCompressedArrayTexture ? Re.setTexture2DArray(R, 0) : Re.setTexture2D(R, 0), se.unbindTexture();
    }, this.resetState = function() {
      M = 0, S = 0, w = null, se.reset(), Ie.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return us;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = e === pd ? "display-p3" : "srgb", t.unpackColorSpace = gt.workingColorSpace === Uc ? "display-p3" : "srgb";
  }
  get physicallyCorrectLights() {
    return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights;
  }
  set physicallyCorrectLights(e) {
    console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !e;
  }
  get outputEncoding() {
    return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === ft ? vr : Hm;
  }
  set outputEncoding(e) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === vr ? ft : en;
  }
  get useLegacyLights() {
    return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
  }
  set useLegacyLights(e) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e;
  }
}
class Bx extends Zm {
}
Bx.prototype.isWebGL1Renderer = !0;
class il {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new Q(e), this.density = t;
  }
  clone() {
    return new il(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class sl {
  constructor(e, t = 1, n = 1e3) {
    this.isFog = !0, this.name = "", this.color = new Q(e), this.near = t, this.far = n;
  }
  clone() {
    return new sl(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class $m extends Ze {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t;
  }
}
class Bc {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = cc, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = xi();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.stride, n *= t.stride;
    for (let s = 0, r = this.stride; s < r; s++)
      this.array[e + s] = t.array[n + s];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = xi()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = xi()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Un = /* @__PURE__ */ new T();
class ei {
  constructor(e, t, n, s = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = s;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      Un.fromBufferAttribute(this, t), Un.applyMatrix4(e), this.setXYZ(t, Un.x, Un.y, Un.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Un.fromBufferAttribute(this, t), Un.applyNormalMatrix(e), this.setXYZ(t, Un.x, Un.y, Un.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Un.fromBufferAttribute(this, t), Un.transformDirection(e), this.setXYZ(t, Un.x, Un.y, Un.z);
    return this;
  }
  setX(e, t) {
    return this.normalized && (t = Je(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = Je(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = Je(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = Je(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = $n(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = $n(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = $n(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = $n(t, this.array)), t;
  }
  setXY(e, t, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Je(t, this.array), n = Je(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Je(t, this.array), n = Je(n, this.array), s = Je(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this;
  }
  setXYZW(e, t, n, s, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Je(t, this.array), n = Je(n, this.array), s = Je(s, this.array), r = Je(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this.data.array[e + 3] = r, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[s + r]);
      }
      return new dt(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new ei(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[s + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class Km extends Qt {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Q(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let io;
const gl = /* @__PURE__ */ new T(), so = /* @__PURE__ */ new T(), ro = /* @__PURE__ */ new T(), ao = /* @__PURE__ */ new k(), vl = /* @__PURE__ */ new k(), kx = /* @__PURE__ */ new _e(), Eh = /* @__PURE__ */ new T(), _l = /* @__PURE__ */ new T(), Ah = /* @__PURE__ */ new T(), nv = /* @__PURE__ */ new k(), xf = /* @__PURE__ */ new k(), iv = /* @__PURE__ */ new k();
class zx extends Ze {
  constructor(e = new Km()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", io === void 0) {
      io = new Be();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), n = new Bc(t, 5);
      io.setIndex([0, 1, 2, 0, 2, 3]), io.setAttribute("position", new ei(n, 3, 0, !1)), io.setAttribute("uv", new ei(n, 2, 3, !1));
    }
    this.geometry = io, this.material = e, this.center = new k(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), so.setFromMatrixScale(this.matrixWorld), kx.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), ro.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && so.multiplyScalar(-ro.z);
    const n = this.material.rotation;
    let s, r;
    n !== 0 && (r = Math.cos(n), s = Math.sin(n));
    const a = this.center;
    Ch(Eh.set(-0.5, -0.5, 0), ro, a, so, s, r), Ch(_l.set(0.5, -0.5, 0), ro, a, so, s, r), Ch(Ah.set(0.5, 0.5, 0), ro, a, so, s, r), nv.set(0, 0), xf.set(1, 0), iv.set(1, 1);
    let o = e.ray.intersectTriangle(Eh, _l, Ah, !1, gl);
    if (o === null && (Ch(_l.set(-0.5, 0.5, 0), ro, a, so, s, r), xf.set(0, 1), o = e.ray.intersectTriangle(Eh, Ah, _l, !1, gl), o === null))
      return;
    const l = e.ray.origin.distanceTo(gl);
    l < e.near || l > e.far || t.push({
      distance: l,
      point: gl.clone(),
      uv: Zn.getInterpolation(gl, Eh, _l, Ah, nv, xf, iv, new k()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function Ch(i, e, t, n, s, r) {
  ao.subVectors(i, t).addScalar(0.5).multiply(n), s !== void 0 ? (vl.x = r * ao.x - s * ao.y, vl.y = s * ao.x + r * ao.y) : vl.copy(ao), i.copy(e), i.x += vl.x, i.y += vl.y, i.applyMatrix4(kx);
}
const Rh = /* @__PURE__ */ new T(), sv = /* @__PURE__ */ new T();
class Hx extends Ze {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, s = t.length; n < s; n++) {
      const r = t[n];
      this.addLevel(r.object.clone(), r.distance, r.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const s = this.levels;
    let r;
    for (r = 0; r < s.length && !(t < s[r].distance); r++)
      ;
    return s.splice(r, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, s;
      for (n = 1, s = t.length; n < s; n++) {
        let r = t[n].distance;
        if (t[n].object.visible && (r -= r * t[n].hysteresis), e < r)
          break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Rh.setFromMatrixPosition(this.matrixWorld);
      const s = e.ray.origin.distanceTo(Rh);
      this.getObjectForDistance(s).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Rh.setFromMatrixPosition(e.matrixWorld), sv.setFromMatrixPosition(this.matrixWorld);
      const n = Rh.distanceTo(sv) / e.zoom;
      t[0].object.visible = !0;
      let s, r;
      for (s = 1, r = t.length; s < r; s++) {
        let a = t[s].distance;
        if (t[s].object.visible && (a -= a * t[s].hysteresis), n >= a)
          t[s - 1].object.visible = !1, t[s].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = s - 1; s < r; s++)
        t[s].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const n = this.levels;
    for (let s = 0, r = n.length; s < r; s++) {
      const a = n[s];
      t.object.levels.push({
        object: a.object.uuid,
        distance: a.distance,
        hysteresis: a.hysteresis
      });
    }
    return t;
  }
}
const rv = /* @__PURE__ */ new T(), av = /* @__PURE__ */ new tt(), ov = /* @__PURE__ */ new tt(), DC = /* @__PURE__ */ new T(), lv = /* @__PURE__ */ new _e(), Ph = /* @__PURE__ */ new T(), Mf = /* @__PURE__ */ new oi(), cv = /* @__PURE__ */ new _e(), bf = /* @__PURE__ */ new Oa();
class Sd extends le {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = lp, this.bindMatrix = new _e(), this.bindMatrixInverse = new _e(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new ln()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Ph), this.boundingBox.expandByPoint(Ph);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new oi()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Ph), this.boundingSphere.expandByPoint(Ph);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const n = this.material, s = this.matrixWorld;
    n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Mf.copy(this.boundingSphere), Mf.applyMatrix4(s), e.ray.intersectsSphere(Mf) !== !1 && (cv.copy(s).invert(), bf.copy(e.ray).applyMatrix4(cv), !(this.boundingBox !== null && bf.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, bf)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new tt(), t = this.geometry.attributes.skinWeight;
    for (let n = 0, s = t.count; n < s; n++) {
      e.fromBufferAttribute(t, n);
      const r = 1 / e.manhattanLength();
      r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === lp ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === tx ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton, s = this.geometry;
    av.fromBufferAttribute(s.attributes.skinIndex, e), ov.fromBufferAttribute(s.attributes.skinWeight, e), rv.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const a = ov.getComponent(r);
      if (a !== 0) {
        const o = av.getComponent(r);
        lv.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), t.addScaledVector(DC.copy(rv).applyMatrix4(lv), a);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t);
  }
}
class Vo extends Ze {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class Co extends At {
  constructor(e = null, t = 1, n = 1, s, r, a, o, l, c = lt, h = lt, u, d) {
    super(null, a, o, l, c, h, s, r, u, d), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const hv = /* @__PURE__ */ new _e(), OC = /* @__PURE__ */ new _e();
class rl {
  constructor(e = [], t = []) {
    this.uuid = xi(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, s = this.bones.length; n < s; n++)
        this.boneInverses.push(new _e());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new _e();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, n = this.boneMatrices, s = this.boneTexture;
    for (let r = 0, a = e.length; r < a; r++) {
      const o = e[r] ? e[r].matrixWorld : OC;
      hv.multiplyMatrices(o, t[r]), hv.toArray(n, r * 16);
    }
    s !== null && (s.needsUpdate = !0);
  }
  clone() {
    return new rl(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Sx(e), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new Co(t, e, e, gi, hs);
    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this;
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const s = this.bones[t];
      if (s.name === e)
        return s;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, s = e.bones.length; n < s; n++) {
      const r = e.bones[n];
      let a = t[r];
      a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), a = new Vo()), this.bones.push(a), this.boneInverses.push(new _e().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, n = this.boneInverses;
    for (let s = 0, r = t.length; s < r; s++) {
      const a = t[s];
      e.bones.push(a.uuid);
      const o = n[s];
      e.boneInverses.push(o.toArray());
    }
    return e;
  }
}
class Aa extends dt {
  constructor(e, t, n, s = 1) {
    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const oo = /* @__PURE__ */ new _e(), uv = /* @__PURE__ */ new _e(), Lh = [], dv = /* @__PURE__ */ new ln(), NC = /* @__PURE__ */ new _e(), yl = /* @__PURE__ */ new le(), xl = /* @__PURE__ */ new oi();
class Qm extends le {
  constructor(e, t, n) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Aa(new Float32Array(n * 16), 16), this.instanceColor = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
    for (let s = 0; s < n; s++)
      this.setMatrixAt(s, NC);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new ln()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, oo), dv.copy(e.boundingBox).applyMatrix4(oo), this.boundingBox.union(dv);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new oi()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, oo), xl.copy(e.boundingSphere).applyMatrix4(oo), this.boundingSphere.union(xl);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const n = this.matrixWorld, s = this.count;
    if (yl.geometry = this.geometry, yl.material = this.material, yl.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), xl.copy(this.boundingSphere), xl.applyMatrix4(n), e.ray.intersectsSphere(xl) !== !1))
      for (let r = 0; r < s; r++) {
        this.getMatrixAt(r, oo), uv.multiplyMatrices(n, oo), yl.matrixWorld = uv, yl.raycast(e, Lh);
        for (let a = 0, o = Lh.length; a < o; a++) {
          const l = Lh[a];
          l.instanceId = r, l.object = this, t.push(l);
        }
        Lh.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new Aa(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Jt extends Qt {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Q(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const fv = /* @__PURE__ */ new T(), pv = /* @__PURE__ */ new T(), mv = /* @__PURE__ */ new _e(), Sf = /* @__PURE__ */ new Oa(), Ih = /* @__PURE__ */ new oi();
class pn extends Ze {
  constructor(e = new Be(), t = new Jt()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [0];
      for (let s = 1, r = t.count; s < r; s++)
        fv.fromBufferAttribute(t, s - 1), pv.fromBufferAttribute(t, s), n[s] = n[s - 1], n[s] += fv.distanceTo(pv);
      e.setAttribute("lineDistance", new ye(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const n = this.geometry, s = this.matrixWorld, r = e.params.Line.threshold, a = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Ih.copy(n.boundingSphere), Ih.applyMatrix4(s), Ih.radius += r, e.ray.intersectsSphere(Ih) === !1) return;
    mv.copy(s).invert(), Sf.copy(e.ray).applyMatrix4(mv);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = new T(), h = new T(), u = new T(), d = new T(), f = this.isLineSegments ? 2 : 1, m = n.index, p = n.attributes.position;
    if (m !== null) {
      const v = Math.max(0, a.start), y = Math.min(m.count, a.start + a.count);
      for (let _ = v, x = y - 1; _ < x; _ += f) {
        const M = m.getX(_), S = m.getX(_ + 1);
        if (c.fromBufferAttribute(p, M), h.fromBufferAttribute(p, S), Sf.distanceSqToSegment(c, h, d, u) > l) continue;
        d.applyMatrix4(this.matrixWorld);
        const E = e.ray.origin.distanceTo(d);
        E < e.near || E > e.far || t.push({
          distance: E,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: u.clone().applyMatrix4(this.matrixWorld),
          index: _,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const v = Math.max(0, a.start), y = Math.min(p.count, a.start + a.count);
      for (let _ = v, x = y - 1; _ < x; _ += f) {
        if (c.fromBufferAttribute(p, _), h.fromBufferAttribute(p, _ + 1), Sf.distanceSqToSegment(c, h, d, u) > l) continue;
        d.applyMatrix4(this.matrixWorld);
        const S = e.ray.origin.distanceTo(d);
        S < e.near || S > e.far || t.push({
          distance: S,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: u.clone().applyMatrix4(this.matrixWorld),
          index: _,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const s = t[n[0]];
      if (s !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = s.length; r < a; r++) {
          const o = s[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
}
const gv = /* @__PURE__ */ new T(), vv = /* @__PURE__ */ new T();
class bi extends pn {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [];
      for (let s = 0, r = t.count; s < r; s += 2)
        gv.fromBufferAttribute(t, s), vv.fromBufferAttribute(t, s + 1), n[s] = s === 0 ? 0 : n[s - 1], n[s + 1] = n[s] + gv.distanceTo(vv);
      e.setAttribute("lineDistance", new ye(n, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class Jm extends pn {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class hr extends Qt {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Q(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const _v = /* @__PURE__ */ new _e(), kp = /* @__PURE__ */ new Oa(), Dh = /* @__PURE__ */ new oi(), Oh = /* @__PURE__ */ new T();
class ya extends Ze {
  constructor(e = new Be(), t = new hr()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const n = this.geometry, s = this.matrixWorld, r = e.params.Points.threshold, a = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Dh.copy(n.boundingSphere), Dh.applyMatrix4(s), Dh.radius += r, e.ray.intersectsSphere(Dh) === !1) return;
    _v.copy(s).invert(), kp.copy(e.ray).applyMatrix4(_v);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = n.index, u = n.attributes.position;
    if (c !== null) {
      const d = Math.max(0, a.start), f = Math.min(c.count, a.start + a.count);
      for (let m = d, g = f; m < g; m++) {
        const p = c.getX(m);
        Oh.fromBufferAttribute(u, p), yv(Oh, p, l, s, e, t, this);
      }
    } else {
      const d = Math.max(0, a.start), f = Math.min(u.count, a.start + a.count);
      for (let m = d, g = f; m < g; m++)
        Oh.fromBufferAttribute(u, m), yv(Oh, m, l, s, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const s = t[n[0]];
      if (s !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = s.length; r < a; r++) {
          const o = s[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
}
function yv(i, e, t, n, s, r, a) {
  const o = kp.distanceSqToPoint(i);
  if (o < t) {
    const l = new T();
    kp.closestPointToPoint(i, l), l.applyMatrix4(n);
    const c = s.ray.origin.distanceTo(l);
    if (c < s.near || c > s.far) return;
    r.push({
      distance: c,
      distanceToRay: Math.sqrt(o),
      point: l,
      index: e,
      face: null,
      object: a
    });
  }
}
class Gx extends At {
  constructor(e, t, n, s, r, a, o, l, c) {
    super(e, t, n, s, r, a, o, l, c), this.isVideoTexture = !0, this.minFilter = a !== void 0 ? a : Nt, this.magFilter = r !== void 0 ? r : Nt, this.generateMipmaps = !1;
    const h = this;
    function u() {
      h.needsUpdate = !0, e.requestVideoFrameCallback(u);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(u);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class UC extends At {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = lt, this.minFilter = lt, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class wd extends At {
  constructor(e, t, n, s, r, a, o, l, c, h, u, d) {
    super(null, a, o, l, c, h, s, r, u, d), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class FC extends wd {
  constructor(e, t, n, s, r, a) {
    super(e, t, n, r, a), this.isCompressedArrayTexture = !0, this.image.depth = s, this.wrapR = Kt;
  }
}
class BC extends wd {
  constructor(e, t, n) {
    super(void 0, e[0].width, e[0].height, t, n, Gs), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class kC extends At {
  constructor(e, t, n, s, r, a, o, l, c) {
    super(e, t, n, s, r, a, o, l, c), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class Oi {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPointAt(n / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n, s = this.getPoint(0), r = 0;
    t.push(0);
    for (let a = 1; a <= e; a++)
      n = this.getPoint(a / e), r += n.distanceTo(s), t.push(r), s = n;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let s = 0;
    const r = n.length;
    let a;
    t ? a = t : a = e * n[r - 1];
    let o = 0, l = r - 1, c;
    for (; o <= l; )
      if (s = Math.floor(o + (l - o) / 2), c = n[s] - a, c < 0)
        o = s + 1;
      else if (c > 0)
        l = s - 1;
      else {
        l = s;
        break;
      }
    if (s = l, n[s] === a)
      return s / (r - 1);
    const h = n[s], d = n[s + 1] - h, f = (a - h) / d;
    return (s + f) / (r - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let s = e - 1e-4, r = e + 1e-4;
    s < 0 && (s = 0), r > 1 && (r = 1);
    const a = this.getPoint(s), o = this.getPoint(r), l = t || (a.isVector2 ? new k() : new T());
    return l.copy(o).sub(a).normalize(), l;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new T(), s = [], r = [], a = [], o = new T(), l = new _e();
    for (let f = 0; f <= e; f++) {
      const m = f / e;
      s[f] = this.getTangentAt(m, new T());
    }
    r[0] = new T(), a[0] = new T();
    let c = Number.MAX_VALUE;
    const h = Math.abs(s[0].x), u = Math.abs(s[0].y), d = Math.abs(s[0].z);
    h <= c && (c = h, n.set(1, 0, 0)), u <= c && (c = u, n.set(0, 1, 0)), d <= c && n.set(0, 0, 1), o.crossVectors(s[0], n).normalize(), r[0].crossVectors(s[0], o), a[0].crossVectors(s[0], r[0]);
    for (let f = 1; f <= e; f++) {
      if (r[f] = r[f - 1].clone(), a[f] = a[f - 1].clone(), o.crossVectors(s[f - 1], s[f]), o.length() > Number.EPSILON) {
        o.normalize();
        const m = Math.acos(Ht(s[f - 1].dot(s[f]), -1, 1));
        r[f].applyMatrix4(l.makeRotationAxis(o, m));
      }
      a[f].crossVectors(s[f], r[f]);
    }
    if (t === !0) {
      let f = Math.acos(Ht(r[0].dot(r[e]), -1, 1));
      f /= e, s[0].dot(o.crossVectors(r[0], r[e])) > 0 && (f = -f);
      for (let m = 1; m <= e; m++)
        r[m].applyMatrix4(l.makeRotationAxis(s[m], f * m)), a[m].crossVectors(s[m], r[m]);
    }
    return {
      tangents: s,
      normals: r,
      binormals: a
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Td extends Oi {
  constructor(e = 0, t = 0, n = 1, s = 1, r = 0, a = Math.PI * 2, o = !1, l = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = s, this.aStartAngle = r, this.aEndAngle = a, this.aClockwise = o, this.aRotation = l;
  }
  getPoint(e, t) {
    const n = t || new k(), s = Math.PI * 2;
    let r = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(r) < Number.EPSILON;
    for (; r < 0; ) r += s;
    for (; r > s; ) r -= s;
    r < Number.EPSILON && (a ? r = 0 : r = s), this.aClockwise === !0 && !a && (r === s ? r = -s : r = r - s);
    const o = this.aStartAngle + e * r;
    let l = this.aX + this.xRadius * Math.cos(o), c = this.aY + this.yRadius * Math.sin(o);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation), u = Math.sin(this.aRotation), d = l - this.aX, f = c - this.aY;
      l = d * h - f * u + this.aX, c = d * u + f * h + this.aY;
    }
    return n.set(l, c);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class Vx extends Td {
  constructor(e, t, n, s, r, a) {
    super(e, t, n, n, s, r, a), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function eg() {
  let i = 0, e = 0, t = 0, n = 0;
  function s(r, a, o, l) {
    i = r, e = o, t = -3 * r + 3 * a - 2 * o - l, n = 2 * r - 2 * a + o + l;
  }
  return {
    initCatmullRom: function(r, a, o, l, c) {
      s(a, o, c * (o - r), c * (l - a));
    },
    initNonuniformCatmullRom: function(r, a, o, l, c, h, u) {
      let d = (a - r) / c - (o - r) / (c + h) + (o - a) / h, f = (o - a) / h - (l - a) / (h + u) + (l - o) / u;
      d *= h, f *= h, s(a, o, d, f);
    },
    calc: function(r) {
      const a = r * r, o = a * r;
      return i + e * r + t * a + n * o;
    }
  };
}
const Nh = /* @__PURE__ */ new T(), wf = /* @__PURE__ */ new eg(), Tf = /* @__PURE__ */ new eg(), Ef = /* @__PURE__ */ new eg();
class Ed extends Oi {
  constructor(e = [], t = !1, n = "centripetal", s = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = s;
  }
  getPoint(e, t = new T()) {
    const n = t, s = this.points, r = s.length, a = (r - (this.closed ? 0 : 1)) * e;
    let o = Math.floor(a), l = a - o;
    this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / r) + 1) * r : l === 0 && o === r - 1 && (o = r - 2, l = 1);
    let c, h;
    this.closed || o > 0 ? c = s[(o - 1) % r] : (Nh.subVectors(s[0], s[1]).add(s[0]), c = Nh);
    const u = s[o % r], d = s[(o + 1) % r];
    if (this.closed || o + 2 < r ? h = s[(o + 2) % r] : (Nh.subVectors(s[r - 1], s[r - 2]).add(s[r - 1]), h = Nh), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let m = Math.pow(c.distanceToSquared(u), f), g = Math.pow(u.distanceToSquared(d), f), p = Math.pow(d.distanceToSquared(h), f);
      g < 1e-4 && (g = 1), m < 1e-4 && (m = g), p < 1e-4 && (p = g), wf.initNonuniformCatmullRom(c.x, u.x, d.x, h.x, m, g, p), Tf.initNonuniformCatmullRom(c.y, u.y, d.y, h.y, m, g, p), Ef.initNonuniformCatmullRom(c.z, u.z, d.z, h.z, m, g, p);
    } else this.curveType === "catmullrom" && (wf.initCatmullRom(c.x, u.x, d.x, h.x, this.tension), Tf.initCatmullRom(c.y, u.y, d.y, h.y, this.tension), Ef.initCatmullRom(c.z, u.z, d.z, h.z, this.tension));
    return n.set(
      wf.calc(l),
      Tf.calc(l),
      Ef.calc(l)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const s = e.points[t];
      this.points.push(s.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const s = this.points[t];
      e.points.push(s.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const s = e.points[t];
      this.points.push(new T().fromArray(s));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function xv(i, e, t, n, s) {
  const r = (n - e) * 0.5, a = (s - t) * 0.5, o = i * i, l = i * o;
  return (2 * t - 2 * n + r + a) * l + (-3 * t + 3 * n - 2 * r - a) * o + r * i + t;
}
function zC(i, e) {
  const t = 1 - i;
  return t * t * e;
}
function HC(i, e) {
  return 2 * (1 - i) * i * e;
}
function GC(i, e) {
  return i * i * e;
}
function Hl(i, e, t, n) {
  return zC(i, e) + HC(i, t) + GC(i, n);
}
function VC(i, e) {
  const t = 1 - i;
  return t * t * t * e;
}
function WC(i, e) {
  const t = 1 - i;
  return 3 * t * t * i * e;
}
function XC(i, e) {
  return 3 * (1 - i) * i * i * e;
}
function qC(i, e) {
  return i * i * i * e;
}
function Gl(i, e, t, n, s) {
  return VC(i, e) + WC(i, t) + XC(i, n) + qC(i, s);
}
class tg extends Oi {
  constructor(e = new k(), t = new k(), n = new k(), s = new k()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = s;
  }
  getPoint(e, t = new k()) {
    const n = t, s = this.v0, r = this.v1, a = this.v2, o = this.v3;
    return n.set(
      Gl(e, s.x, r.x, a.x, o.x),
      Gl(e, s.y, r.y, a.y, o.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Wx extends Oi {
  constructor(e = new T(), t = new T(), n = new T(), s = new T()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = s;
  }
  getPoint(e, t = new T()) {
    const n = t, s = this.v0, r = this.v1, a = this.v2, o = this.v3;
    return n.set(
      Gl(e, s.x, r.x, a.x, o.x),
      Gl(e, s.y, r.y, a.y, o.y),
      Gl(e, s.z, r.z, a.z, o.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class ng extends Oi {
  constructor(e = new k(), t = new k()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new k()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new k()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Xx extends Oi {
  constructor(e = new T(), t = new T()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new T()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new T()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class ig extends Oi {
  constructor(e = new k(), t = new k(), n = new k()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new k()) {
    const n = t, s = this.v0, r = this.v1, a = this.v2;
    return n.set(
      Hl(e, s.x, r.x, a.x),
      Hl(e, s.y, r.y, a.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class sg extends Oi {
  constructor(e = new T(), t = new T(), n = new T()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new T()) {
    const n = t, s = this.v0, r = this.v1, a = this.v2;
    return n.set(
      Hl(e, s.x, r.x, a.x),
      Hl(e, s.y, r.y, a.y),
      Hl(e, s.z, r.z, a.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class rg extends Oi {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new k()) {
    const n = t, s = this.points, r = (s.length - 1) * e, a = Math.floor(r), o = r - a, l = s[a === 0 ? a : a - 1], c = s[a], h = s[a > s.length - 2 ? s.length - 1 : a + 1], u = s[a > s.length - 3 ? s.length - 1 : a + 2];
    return n.set(
      xv(o, l.x, c.x, h.x, u.x),
      xv(o, l.y, c.y, h.y, u.y)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const s = e.points[t];
      this.points.push(s.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const s = this.points[t];
      e.points.push(s.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const s = e.points[t];
      this.points.push(new k().fromArray(s));
    }
    return this;
  }
}
var Iu = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: Vx,
  CatmullRomCurve3: Ed,
  CubicBezierCurve: tg,
  CubicBezierCurve3: Wx,
  EllipseCurve: Td,
  LineCurve: ng,
  LineCurve3: Xx,
  QuadraticBezierCurve: ig,
  QuadraticBezierCurve3: sg,
  SplineCurve: rg
});
class qx extends Oi {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Iu[n](t, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const n = e * this.getLength(), s = this.getCurveLengths();
    let r = 0;
    for (; r < s.length; ) {
      if (s[r] >= n) {
        const a = s[r] - n, o = this.curves[r], l = o.getLength(), c = l === 0 ? 0 : 1 - a / l;
        return o.getPointAt(c, t);
      }
      r++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, s = this.curves.length; n < s; n++)
      t += this.curves[n].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let s = 0, r = this.curves; s < r.length; s++) {
      const a = r[s], o = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, l = a.getPoints(o);
      for (let c = 0; c < l.length; c++) {
        const h = l[c];
        n && n.equals(h) || (t.push(h), n = h);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const s = e.curves[t];
      this.curves.push(s.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const s = this.curves[t];
      e.curves.push(s.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const s = e.curves[t];
      this.curves.push(new Iu[s.type]().fromJSON(s));
    }
    return this;
  }
}
class Wo extends qx {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new k(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new ng(this.currentPoint.clone(), new k(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, s) {
    const r = new ig(
      this.currentPoint.clone(),
      new k(e, t),
      new k(n, s)
    );
    return this.curves.push(r), this.currentPoint.set(n, s), this;
  }
  bezierCurveTo(e, t, n, s, r, a) {
    const o = new tg(
      this.currentPoint.clone(),
      new k(e, t),
      new k(n, s),
      new k(r, a)
    );
    return this.curves.push(o), this.currentPoint.set(r, a), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), n = new rg(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, s, r, a) {
    const o = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(
      e + o,
      t + l,
      n,
      s,
      r,
      a
    ), this;
  }
  absarc(e, t, n, s, r, a) {
    return this.absellipse(e, t, n, n, s, r, a), this;
  }
  ellipse(e, t, n, s, r, a, o, l) {
    const c = this.currentPoint.x, h = this.currentPoint.y;
    return this.absellipse(e + c, t + h, n, s, r, a, o, l), this;
  }
  absellipse(e, t, n, s, r, a, o, l) {
    const c = new Td(e, t, n, s, r, a, o, l);
    if (this.curves.length > 0) {
      const u = c.getPoint(0);
      u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
    }
    this.curves.push(c);
    const h = c.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class kc extends Be {
  constructor(e = [new k(0, -0.5), new k(0.5, 0), new k(0, 0.5)], t = 12, n = 0, s = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: n,
      phiLength: s
    }, t = Math.floor(t), s = Ht(s, 0, Math.PI * 2);
    const r = [], a = [], o = [], l = [], c = [], h = 1 / t, u = new T(), d = new k(), f = new T(), m = new T(), g = new T();
    let p = 0, v = 0;
    for (let y = 0; y <= e.length - 1; y++)
      switch (y) {
        case 0:
          p = e[y + 1].x - e[y].x, v = e[y + 1].y - e[y].y, f.x = v * 1, f.y = -p, f.z = v * 0, g.copy(f), f.normalize(), l.push(f.x, f.y, f.z);
          break;
        case e.length - 1:
          l.push(g.x, g.y, g.z);
          break;
        default:
          p = e[y + 1].x - e[y].x, v = e[y + 1].y - e[y].y, f.x = v * 1, f.y = -p, f.z = v * 0, m.copy(f), f.x += g.x, f.y += g.y, f.z += g.z, f.normalize(), l.push(f.x, f.y, f.z), g.copy(m);
      }
    for (let y = 0; y <= t; y++) {
      const _ = n + y * h * s, x = Math.sin(_), M = Math.cos(_);
      for (let S = 0; S <= e.length - 1; S++) {
        u.x = e[S].x * x, u.y = e[S].y, u.z = e[S].x * M, a.push(u.x, u.y, u.z), d.x = y / t, d.y = S / (e.length - 1), o.push(d.x, d.y);
        const w = l[3 * S + 0] * x, E = l[3 * S + 1], b = l[3 * S + 0] * M;
        c.push(w, E, b);
      }
    }
    for (let y = 0; y < t; y++)
      for (let _ = 0; _ < e.length - 1; _++) {
        const x = _ + y * e.length, M = x, S = x + e.length, w = x + e.length + 1, E = x + 1;
        r.push(M, S, E), r.push(w, E, S);
      }
    this.setIndex(r), this.setAttribute("position", new ye(a, 3)), this.setAttribute("uv", new ye(o, 2)), this.setAttribute("normal", new ye(c, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new kc(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class zc extends kc {
  constructor(e = 1, t = 1, n = 4, s = 8) {
    const r = new Wo();
    r.absarc(0, -t / 2, e, Math.PI * 1.5, 0), r.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(r.getPoints(n), s), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: n,
      radialSegments: s
    };
  }
  static fromJSON(e) {
    return new zc(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Hc extends Be {
  constructor(e = 1, t = 32, n = 0, s = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: n,
      thetaLength: s
    }, t = Math.max(3, t);
    const r = [], a = [], o = [], l = [], c = new T(), h = new k();
    a.push(0, 0, 0), o.push(0, 0, 1), l.push(0.5, 0.5);
    for (let u = 0, d = 3; u <= t; u++, d += 3) {
      const f = n + u / t * s;
      c.x = e * Math.cos(f), c.y = e * Math.sin(f), a.push(c.x, c.y, c.z), o.push(0, 0, 1), h.x = (a[d] / e + 1) / 2, h.y = (a[d + 1] / e + 1) / 2, l.push(h.x, h.y);
    }
    for (let u = 1; u <= t; u++)
      r.push(u, u + 1, 0);
    this.setIndex(r), this.setAttribute("position", new ye(a, 3)), this.setAttribute("normal", new ye(o, 3)), this.setAttribute("uv", new ye(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Hc(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class qt extends Be {
  constructor(e = 1, t = 1, n = 1, s = 32, r = 1, a = !1, o = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: n,
      radialSegments: s,
      heightSegments: r,
      openEnded: a,
      thetaStart: o,
      thetaLength: l
    };
    const c = this;
    s = Math.floor(s), r = Math.floor(r);
    const h = [], u = [], d = [], f = [];
    let m = 0;
    const g = [], p = n / 2;
    let v = 0;
    y(), a === !1 && (e > 0 && _(!0), t > 0 && _(!1)), this.setIndex(h), this.setAttribute("position", new ye(u, 3)), this.setAttribute("normal", new ye(d, 3)), this.setAttribute("uv", new ye(f, 2));
    function y() {
      const x = new T(), M = new T();
      let S = 0;
      const w = (t - e) / n;
      for (let E = 0; E <= r; E++) {
        const b = [], A = E / r, D = A * (t - e) + e;
        for (let B = 0; B <= s; B++) {
          const X = B / s, L = X * l + o, F = Math.sin(L), H = Math.cos(L);
          M.x = D * F, M.y = -A * n + p, M.z = D * H, u.push(M.x, M.y, M.z), x.set(F, w, H).normalize(), d.push(x.x, x.y, x.z), f.push(X, 1 - A), b.push(m++);
        }
        g.push(b);
      }
      for (let E = 0; E < s; E++)
        for (let b = 0; b < r; b++) {
          const A = g[b][E], D = g[b + 1][E], B = g[b + 1][E + 1], X = g[b][E + 1];
          h.push(A, D, X), h.push(D, B, X), S += 6;
        }
      c.addGroup(v, S, 0), v += S;
    }
    function _(x) {
      const M = m, S = new k(), w = new T();
      let E = 0;
      const b = x === !0 ? e : t, A = x === !0 ? 1 : -1;
      for (let B = 1; B <= s; B++)
        u.push(0, p * A, 0), d.push(0, A, 0), f.push(0.5, 0.5), m++;
      const D = m;
      for (let B = 0; B <= s; B++) {
        const L = B / s * l + o, F = Math.cos(L), H = Math.sin(L);
        w.x = b * H, w.y = p * A, w.z = b * F, u.push(w.x, w.y, w.z), d.push(0, A, 0), S.x = F * 0.5 + 0.5, S.y = H * 0.5 * A + 0.5, f.push(S.x, S.y), m++;
      }
      for (let B = 0; B < s; B++) {
        const X = M + B, L = D + B;
        x === !0 ? h.push(L, L + 1, X) : h.push(L + 1, L, X), E += 3;
      }
      c.addGroup(v, E, x === !0 ? 1 : 2), v += E;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new qt(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Gc extends qt {
  constructor(e = 1, t = 1, n = 32, s = 1, r = !1, a = 0, o = Math.PI * 2) {
    super(0, e, t, n, s, r, a, o), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: n,
      heightSegments: s,
      openEnded: r,
      thetaStart: a,
      thetaLength: o
    };
  }
  static fromJSON(e) {
    return new Gc(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Br extends Be {
  constructor(e = [], t = [], n = 1, s = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: n,
      detail: s
    };
    const r = [], a = [];
    o(s), c(n), h(), this.setAttribute("position", new ye(r, 3)), this.setAttribute("normal", new ye(r.slice(), 3)), this.setAttribute("uv", new ye(a, 2)), s === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function o(y) {
      const _ = new T(), x = new T(), M = new T();
      for (let S = 0; S < t.length; S += 3)
        f(t[S + 0], _), f(t[S + 1], x), f(t[S + 2], M), l(_, x, M, y);
    }
    function l(y, _, x, M) {
      const S = M + 1, w = [];
      for (let E = 0; E <= S; E++) {
        w[E] = [];
        const b = y.clone().lerp(x, E / S), A = _.clone().lerp(x, E / S), D = S - E;
        for (let B = 0; B <= D; B++)
          B === 0 && E === S ? w[E][B] = b : w[E][B] = b.clone().lerp(A, B / D);
      }
      for (let E = 0; E < S; E++)
        for (let b = 0; b < 2 * (S - E) - 1; b++) {
          const A = Math.floor(b / 2);
          b % 2 === 0 ? (d(w[E][A + 1]), d(w[E + 1][A]), d(w[E][A])) : (d(w[E][A + 1]), d(w[E + 1][A + 1]), d(w[E + 1][A]));
        }
    }
    function c(y) {
      const _ = new T();
      for (let x = 0; x < r.length; x += 3)
        _.x = r[x + 0], _.y = r[x + 1], _.z = r[x + 2], _.normalize().multiplyScalar(y), r[x + 0] = _.x, r[x + 1] = _.y, r[x + 2] = _.z;
    }
    function h() {
      const y = new T();
      for (let _ = 0; _ < r.length; _ += 3) {
        y.x = r[_ + 0], y.y = r[_ + 1], y.z = r[_ + 2];
        const x = p(y) / 2 / Math.PI + 0.5, M = v(y) / Math.PI + 0.5;
        a.push(x, 1 - M);
      }
      m(), u();
    }
    function u() {
      for (let y = 0; y < a.length; y += 6) {
        const _ = a[y + 0], x = a[y + 2], M = a[y + 4], S = Math.max(_, x, M), w = Math.min(_, x, M);
        S > 0.9 && w < 0.1 && (_ < 0.2 && (a[y + 0] += 1), x < 0.2 && (a[y + 2] += 1), M < 0.2 && (a[y + 4] += 1));
      }
    }
    function d(y) {
      r.push(y.x, y.y, y.z);
    }
    function f(y, _) {
      const x = y * 3;
      _.x = e[x + 0], _.y = e[x + 1], _.z = e[x + 2];
    }
    function m() {
      const y = new T(), _ = new T(), x = new T(), M = new T(), S = new k(), w = new k(), E = new k();
      for (let b = 0, A = 0; b < r.length; b += 9, A += 6) {
        y.set(r[b + 0], r[b + 1], r[b + 2]), _.set(r[b + 3], r[b + 4], r[b + 5]), x.set(r[b + 6], r[b + 7], r[b + 8]), S.set(a[A + 0], a[A + 1]), w.set(a[A + 2], a[A + 3]), E.set(a[A + 4], a[A + 5]), M.copy(y).add(_).add(x).divideScalar(3);
        const D = p(M);
        g(S, A + 0, y, D), g(w, A + 2, _, D), g(E, A + 4, x, D);
      }
    }
    function g(y, _, x, M) {
      M < 0 && y.x === 1 && (a[_] = y.x - 1), x.x === 0 && x.z === 0 && (a[_] = M / 2 / Math.PI + 0.5);
    }
    function p(y) {
      return Math.atan2(y.z, -y.x);
    }
    function v(y) {
      return Math.atan2(-y.y, Math.sqrt(y.x * y.x + y.z * y.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Br(e.vertices, e.indices, e.radius, e.details);
  }
}
class Ad extends Br {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, s = 1 / n, r = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -s,
      -n,
      0,
      -s,
      n,
      0,
      s,
      -n,
      0,
      s,
      n,
      // (1/, , 0)
      -s,
      -n,
      0,
      -s,
      n,
      0,
      s,
      -n,
      0,
      s,
      n,
      0,
      // (, 0, 1/)
      -n,
      0,
      -s,
      n,
      0,
      -s,
      -n,
      0,
      s,
      n,
      0,
      s
    ], a = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(r, a, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Ad(e.radius, e.detail);
  }
}
const Uh = /* @__PURE__ */ new T(), Fh = /* @__PURE__ */ new T(), Af = /* @__PURE__ */ new T(), Bh = /* @__PURE__ */ new Zn();
class Yx extends Be {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const s = Math.pow(10, 4), r = Math.cos(_a * t), a = e.getIndex(), o = e.getAttribute("position"), l = a ? a.count : o.count, c = [0, 0, 0], h = ["a", "b", "c"], u = new Array(3), d = {}, f = [];
      for (let m = 0; m < l; m += 3) {
        a ? (c[0] = a.getX(m), c[1] = a.getX(m + 1), c[2] = a.getX(m + 2)) : (c[0] = m, c[1] = m + 1, c[2] = m + 2);
        const { a: g, b: p, c: v } = Bh;
        if (g.fromBufferAttribute(o, c[0]), p.fromBufferAttribute(o, c[1]), v.fromBufferAttribute(o, c[2]), Bh.getNormal(Af), u[0] = `${Math.round(g.x * s)},${Math.round(g.y * s)},${Math.round(g.z * s)}`, u[1] = `${Math.round(p.x * s)},${Math.round(p.y * s)},${Math.round(p.z * s)}`, u[2] = `${Math.round(v.x * s)},${Math.round(v.y * s)},${Math.round(v.z * s)}`, !(u[0] === u[1] || u[1] === u[2] || u[2] === u[0]))
          for (let y = 0; y < 3; y++) {
            const _ = (y + 1) % 3, x = u[y], M = u[_], S = Bh[h[y]], w = Bh[h[_]], E = `${x}_${M}`, b = `${M}_${x}`;
            b in d && d[b] ? (Af.dot(d[b].normal) <= r && (f.push(S.x, S.y, S.z), f.push(w.x, w.y, w.z)), d[b] = null) : E in d || (d[E] = {
              index0: c[y],
              index1: c[_],
              normal: Af.clone()
            });
          }
      }
      for (const m in d)
        if (d[m]) {
          const { index0: g, index1: p } = d[m];
          Uh.fromBufferAttribute(o, g), Fh.fromBufferAttribute(o, p), f.push(Uh.x, Uh.y, Uh.z), f.push(Fh.x, Fh.y, Fh.z);
        }
      this.setAttribute("position", new ye(f, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class _r extends Wo {
  constructor(e) {
    super(e), this.uuid = xi(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, s = this.holes.length; n < s; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const s = e.holes[t];
      this.holes.push(s.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const s = this.holes[t];
      e.holes.push(s.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const s = e.holes[t];
      this.holes.push(new Wo().fromJSON(s));
    }
    return this;
  }
}
const YC = {
  triangulate: function(i, e, t = 2) {
    const n = e && e.length, s = n ? e[0] * t : i.length;
    let r = jx(i, 0, s, t, !0);
    const a = [];
    if (!r || r.next === r.prev) return a;
    let o, l, c, h, u, d, f;
    if (n && (r = QC(i, e, r, t)), i.length > 80 * t) {
      o = c = i[0], l = h = i[1];
      for (let m = t; m < s; m += t)
        u = i[m], d = i[m + 1], u < o && (o = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
      f = Math.max(c - o, h - l), f = f !== 0 ? 32767 / f : 0;
    }
    return dc(r, a, t, o, l, f, 0), a;
  }
};
function jx(i, e, t, n, s) {
  let r, a;
  if (s === c2(i, e, t, n) > 0)
    for (r = e; r < t; r += n) a = Mv(r, i[r], i[r + 1], a);
  else
    for (r = t - n; r >= e; r -= n) a = Mv(r, i[r], i[r + 1], a);
  return a && Cd(a, a.next) && (pc(a), a = a.next), a;
}
function Ca(i, e) {
  if (!i) return i;
  e || (e = i);
  let t = i, n;
  do
    if (n = !1, !t.steiner && (Cd(t, t.next) || Ut(t.prev, t, t.next) === 0)) {
      if (pc(t), t = e = t.prev, t === t.next) break;
      n = !0;
    } else
      t = t.next;
  while (n || t !== e);
  return e;
}
function dc(i, e, t, n, s, r, a) {
  if (!i) return;
  !a && r && i2(i, n, s, r);
  let o = i, l, c;
  for (; i.prev !== i.next; ) {
    if (l = i.prev, c = i.next, r ? ZC(i, n, s, r) : jC(i)) {
      e.push(l.i / t | 0), e.push(i.i / t | 0), e.push(c.i / t | 0), pc(i), i = c.next, o = c.next;
      continue;
    }
    if (i = c, i === o) {
      a ? a === 1 ? (i = $C(Ca(i), e, t), dc(i, e, t, n, s, r, 2)) : a === 2 && KC(i, e, t, n, s, r) : dc(Ca(i), e, t, n, s, r, 1);
      break;
    }
  }
}
function jC(i) {
  const e = i.prev, t = i, n = i.next;
  if (Ut(e, t, n) >= 0) return !1;
  const s = e.x, r = t.x, a = n.x, o = e.y, l = t.y, c = n.y, h = s < r ? s < a ? s : a : r < a ? r : a, u = o < l ? o < c ? o : c : l < c ? l : c, d = s > r ? s > a ? s : a : r > a ? r : a, f = o > l ? o > c ? o : c : l > c ? l : c;
  let m = n.next;
  for (; m !== e; ) {
    if (m.x >= h && m.x <= d && m.y >= u && m.y <= f && _o(s, o, r, l, a, c, m.x, m.y) && Ut(m.prev, m, m.next) >= 0) return !1;
    m = m.next;
  }
  return !0;
}
function ZC(i, e, t, n) {
  const s = i.prev, r = i, a = i.next;
  if (Ut(s, r, a) >= 0) return !1;
  const o = s.x, l = r.x, c = a.x, h = s.y, u = r.y, d = a.y, f = o < l ? o < c ? o : c : l < c ? l : c, m = h < u ? h < d ? h : d : u < d ? u : d, g = o > l ? o > c ? o : c : l > c ? l : c, p = h > u ? h > d ? h : d : u > d ? u : d, v = zp(f, m, e, t, n), y = zp(g, p, e, t, n);
  let _ = i.prevZ, x = i.nextZ;
  for (; _ && _.z >= v && x && x.z <= y; ) {
    if (_.x >= f && _.x <= g && _.y >= m && _.y <= p && _ !== s && _ !== a && _o(o, h, l, u, c, d, _.x, _.y) && Ut(_.prev, _, _.next) >= 0 || (_ = _.prevZ, x.x >= f && x.x <= g && x.y >= m && x.y <= p && x !== s && x !== a && _o(o, h, l, u, c, d, x.x, x.y) && Ut(x.prev, x, x.next) >= 0)) return !1;
    x = x.nextZ;
  }
  for (; _ && _.z >= v; ) {
    if (_.x >= f && _.x <= g && _.y >= m && _.y <= p && _ !== s && _ !== a && _o(o, h, l, u, c, d, _.x, _.y) && Ut(_.prev, _, _.next) >= 0) return !1;
    _ = _.prevZ;
  }
  for (; x && x.z <= y; ) {
    if (x.x >= f && x.x <= g && x.y >= m && x.y <= p && x !== s && x !== a && _o(o, h, l, u, c, d, x.x, x.y) && Ut(x.prev, x, x.next) >= 0) return !1;
    x = x.nextZ;
  }
  return !0;
}
function $C(i, e, t) {
  let n = i;
  do {
    const s = n.prev, r = n.next.next;
    !Cd(s, r) && Zx(s, n, n.next, r) && fc(s, r) && fc(r, s) && (e.push(s.i / t | 0), e.push(n.i / t | 0), e.push(r.i / t | 0), pc(n), pc(n.next), n = i = r), n = n.next;
  } while (n !== i);
  return Ca(n);
}
function KC(i, e, t, n, s, r) {
  let a = i;
  do {
    let o = a.next.next;
    for (; o !== a.prev; ) {
      if (a.i !== o.i && a2(a, o)) {
        let l = $x(a, o);
        a = Ca(a, a.next), l = Ca(l, l.next), dc(a, e, t, n, s, r, 0), dc(l, e, t, n, s, r, 0);
        return;
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== i);
}
function QC(i, e, t, n) {
  const s = [];
  let r, a, o, l, c;
  for (r = 0, a = e.length; r < a; r++)
    o = e[r] * n, l = r < a - 1 ? e[r + 1] * n : i.length, c = jx(i, o, l, n, !1), c === c.next && (c.steiner = !0), s.push(r2(c));
  for (s.sort(JC), r = 0; r < s.length; r++)
    t = e2(s[r], t);
  return t;
}
function JC(i, e) {
  return i.x - e.x;
}
function e2(i, e) {
  const t = t2(i, e);
  if (!t)
    return e;
  const n = $x(t, i);
  return Ca(n, n.next), Ca(t, t.next);
}
function t2(i, e) {
  let t = e, n = -1 / 0, s;
  const r = i.x, a = i.y;
  do {
    if (a <= t.y && a >= t.next.y && t.next.y !== t.y) {
      const d = t.x + (a - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (d <= r && d > n && (n = d, s = t.x < t.next.x ? t : t.next, d === r))
        return s;
    }
    t = t.next;
  } while (t !== e);
  if (!s) return null;
  const o = s, l = s.x, c = s.y;
  let h = 1 / 0, u;
  t = s;
  do
    r >= t.x && t.x >= l && r !== t.x && _o(a < c ? r : n, a, l, c, a < c ? n : r, a, t.x, t.y) && (u = Math.abs(a - t.y) / (r - t.x), fc(t, i) && (u < h || u === h && (t.x > s.x || t.x === s.x && n2(s, t))) && (s = t, h = u)), t = t.next;
  while (t !== o);
  return s;
}
function n2(i, e) {
  return Ut(i.prev, i, e.prev) < 0 && Ut(e.next, i, i.next) < 0;
}
function i2(i, e, t, n) {
  let s = i;
  do
    s.z === 0 && (s.z = zp(s.x, s.y, e, t, n)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next;
  while (s !== i);
  s.prevZ.nextZ = null, s.prevZ = null, s2(s);
}
function s2(i) {
  let e, t, n, s, r, a, o, l, c = 1;
  do {
    for (t = i, i = null, r = null, a = 0; t; ) {
      for (a++, n = t, o = 0, e = 0; e < c && (o++, n = n.nextZ, !!n); e++)
        ;
      for (l = c; o > 0 || l > 0 && n; )
        o !== 0 && (l === 0 || !n || t.z <= n.z) ? (s = t, t = t.nextZ, o--) : (s = n, n = n.nextZ, l--), r ? r.nextZ = s : i = s, s.prevZ = r, r = s;
      t = n;
    }
    r.nextZ = null, c *= 2;
  } while (a > 1);
  return i;
}
function zp(i, e, t, n, s) {
  return i = (i - t) * s | 0, e = (e - n) * s | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, i | e << 1;
}
function r2(i) {
  let e = i, t = i;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== i);
  return t;
}
function _o(i, e, t, n, s, r, a, o) {
  return (s - a) * (e - o) >= (i - a) * (r - o) && (i - a) * (n - o) >= (t - a) * (e - o) && (t - a) * (r - o) >= (s - a) * (n - o);
}
function a2(i, e) {
  return i.next.i !== e.i && i.prev.i !== e.i && !o2(i, e) && // dones't intersect other edges
  (fc(i, e) && fc(e, i) && l2(i, e) && // locally visible
  (Ut(i.prev, i, e.prev) || Ut(i, e.prev, e)) || // does not create opposite-facing sectors
  Cd(i, e) && Ut(i.prev, i, i.next) > 0 && Ut(e.prev, e, e.next) > 0);
}
function Ut(i, e, t) {
  return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y);
}
function Cd(i, e) {
  return i.x === e.x && i.y === e.y;
}
function Zx(i, e, t, n) {
  const s = zh(Ut(i, e, t)), r = zh(Ut(i, e, n)), a = zh(Ut(t, n, i)), o = zh(Ut(t, n, e));
  return !!(s !== r && a !== o || s === 0 && kh(i, t, e) || r === 0 && kh(i, n, e) || a === 0 && kh(t, i, n) || o === 0 && kh(t, e, n));
}
function kh(i, e, t) {
  return e.x <= Math.max(i.x, t.x) && e.x >= Math.min(i.x, t.x) && e.y <= Math.max(i.y, t.y) && e.y >= Math.min(i.y, t.y);
}
function zh(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function o2(i, e) {
  let t = i;
  do {
    if (t.i !== i.i && t.next.i !== i.i && t.i !== e.i && t.next.i !== e.i && Zx(t, t.next, i, e)) return !0;
    t = t.next;
  } while (t !== i);
  return !1;
}
function fc(i, e) {
  return Ut(i.prev, i, i.next) < 0 ? Ut(i, e, i.next) >= 0 && Ut(i, i.prev, e) >= 0 : Ut(i, e, i.prev) < 0 || Ut(i, i.next, e) < 0;
}
function l2(i, e) {
  let t = i, n = !1;
  const s = (i.x + e.x) / 2, r = (i.y + e.y) / 2;
  do
    t.y > r != t.next.y > r && t.next.y !== t.y && s < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
  while (t !== i);
  return n;
}
function $x(i, e) {
  const t = new Hp(i.i, i.x, i.y), n = new Hp(e.i, e.x, e.y), s = i.next, r = e.prev;
  return i.next = e, e.prev = i, t.next = s, s.prev = t, n.next = t, t.prev = n, r.next = n, n.prev = r, n;
}
function Mv(i, e, t, n) {
  const s = new Hp(i, e, t);
  return n ? (s.next = n.next, s.prev = n, n.next.prev = s, n.next = s) : (s.prev = s, s.next = s), s;
}
function pc(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function Hp(i, e, t) {
  this.i = i, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function c2(i, e, t, n) {
  let s = 0;
  for (let r = e, a = t - n; r < t; r += n)
    s += (i[a] - i[r]) * (i[r + 1] + i[a + 1]), a = r;
  return s;
}
class ms {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let s = t - 1, r = 0; r < t; s = r++)
      n += e[s].x * e[r].y - e[r].x * e[s].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return ms.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [], s = [], r = [];
    bv(e), Sv(n, e);
    let a = e.length;
    t.forEach(bv);
    for (let l = 0; l < t.length; l++)
      s.push(a), a += t[l].length, Sv(n, t[l]);
    const o = YC.triangulate(n, s);
    for (let l = 0; l < o.length; l += 3)
      r.push(o.slice(l, l + 3));
    return r;
  }
}
function bv(i) {
  const e = i.length;
  e > 2 && i[e - 1].equals(i[0]) && i.pop();
}
function Sv(i, e) {
  for (let t = 0; t < e.length; t++)
    i.push(e[t].x), i.push(e[t].y);
}
class Ua extends Be {
  constructor(e = new _r([new k(0.5, 0.5), new k(-0.5, 0.5), new k(-0.5, -0.5), new k(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const n = this, s = [], r = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o];
      a(c);
    }
    this.setAttribute("position", new ye(s, 3)), this.setAttribute("uv", new ye(r, 2)), this.computeVertexNormals();
    function a(o) {
      const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, h = t.steps !== void 0 ? t.steps : 1, u = t.depth !== void 0 ? t.depth : 1;
      let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, m = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1, g = t.bevelOffset !== void 0 ? t.bevelOffset : 0, p = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const v = t.extrudePath, y = t.UVGenerator !== void 0 ? t.UVGenerator : h2;
      let _, x = !1, M, S, w, E;
      v && (_ = v.getSpacedPoints(h), x = !0, d = !1, M = v.computeFrenetFrames(h, !1), S = new T(), w = new T(), E = new T()), d || (p = 0, f = 0, m = 0, g = 0);
      const b = o.extractPoints(c);
      let A = b.shape;
      const D = b.holes;
      if (!ms.isClockWise(A)) {
        A = A.reverse();
        for (let I = 0, xe = D.length; I < xe; I++) {
          const ee = D[I];
          ms.isClockWise(ee) && (D[I] = ee.reverse());
        }
      }
      const X = ms.triangulateShape(A, D), L = A;
      for (let I = 0, xe = D.length; I < xe; I++) {
        const ee = D[I];
        A = A.concat(ee);
      }
      function F(I, xe, ee) {
        return xe || console.error("THREE.ExtrudeGeometry: vec does not exist"), I.clone().addScaledVector(xe, ee);
      }
      const H = A.length, G = X.length;
      function te(I, xe, ee) {
        let ce, se, De;
        const Ee = I.x - xe.x, Re = I.y - xe.y, Ge = ee.x - I.x, nt = ee.y - I.y, Ct = Ee * Ee + Re * Re, P = Ee * nt - Re * Ge;
        if (Math.abs(P) > Number.EPSILON) {
          const C = Math.sqrt(Ct), W = Math.sqrt(Ge * Ge + nt * nt), he = xe.x - Re / C, ae = xe.y + Ee / C, ue = ee.x - nt / W, Pe = ee.y + Ge / W, pe = ((ue - he) * nt - (Pe - ae) * Ge) / (Ee * nt - Re * Ge);
          ce = he + Ee * pe - I.x, se = ae + Re * pe - I.y;
          const we = ce * ce + se * se;
          if (we <= 2)
            return new k(ce, se);
          De = Math.sqrt(we / 2);
        } else {
          let C = !1;
          Ee > Number.EPSILON ? Ge > Number.EPSILON && (C = !0) : Ee < -Number.EPSILON ? Ge < -Number.EPSILON && (C = !0) : Math.sign(Re) === Math.sign(nt) && (C = !0), C ? (ce = -Re, se = Ee, De = Math.sqrt(Ct)) : (ce = Ee, se = Re, De = Math.sqrt(Ct / 2));
        }
        return new k(ce / De, se / De);
      }
      const j = [];
      for (let I = 0, xe = L.length, ee = xe - 1, ce = I + 1; I < xe; I++, ee++, ce++)
        ee === xe && (ee = 0), ce === xe && (ce = 0), j[I] = te(L[I], L[ee], L[ce]);
      const J = [];
      let N, q = j.concat();
      for (let I = 0, xe = D.length; I < xe; I++) {
        const ee = D[I];
        N = [];
        for (let ce = 0, se = ee.length, De = se - 1, Ee = ce + 1; ce < se; ce++, De++, Ee++)
          De === se && (De = 0), Ee === se && (Ee = 0), N[ce] = te(ee[ce], ee[De], ee[Ee]);
        J.push(N), q = q.concat(N);
      }
      for (let I = 0; I < p; I++) {
        const xe = I / p, ee = f * Math.cos(xe * Math.PI / 2), ce = m * Math.sin(xe * Math.PI / 2) + g;
        for (let se = 0, De = L.length; se < De; se++) {
          const Ee = F(L[se], j[se], ce);
          ze(Ee.x, Ee.y, -ee);
        }
        for (let se = 0, De = D.length; se < De; se++) {
          const Ee = D[se];
          N = J[se];
          for (let Re = 0, Ge = Ee.length; Re < Ge; Re++) {
            const nt = F(Ee[Re], N[Re], ce);
            ze(nt.x, nt.y, -ee);
          }
        }
      }
      const ge = m + g;
      for (let I = 0; I < H; I++) {
        const xe = d ? F(A[I], q[I], ge) : A[I];
        x ? (w.copy(M.normals[0]).multiplyScalar(xe.x), S.copy(M.binormals[0]).multiplyScalar(xe.y), E.copy(_[0]).add(w).add(S), ze(E.x, E.y, E.z)) : ze(xe.x, xe.y, 0);
      }
      for (let I = 1; I <= h; I++)
        for (let xe = 0; xe < H; xe++) {
          const ee = d ? F(A[xe], q[xe], ge) : A[xe];
          x ? (w.copy(M.normals[I]).multiplyScalar(ee.x), S.copy(M.binormals[I]).multiplyScalar(ee.y), E.copy(_[I]).add(w).add(S), ze(E.x, E.y, E.z)) : ze(ee.x, ee.y, u / h * I);
        }
      for (let I = p - 1; I >= 0; I--) {
        const xe = I / p, ee = f * Math.cos(xe * Math.PI / 2), ce = m * Math.sin(xe * Math.PI / 2) + g;
        for (let se = 0, De = L.length; se < De; se++) {
          const Ee = F(L[se], j[se], ce);
          ze(Ee.x, Ee.y, u + ee);
        }
        for (let se = 0, De = D.length; se < De; se++) {
          const Ee = D[se];
          N = J[se];
          for (let Re = 0, Ge = Ee.length; Re < Ge; Re++) {
            const nt = F(Ee[Re], N[Re], ce);
            x ? ze(nt.x, nt.y + _[h - 1].y, _[h - 1].x + ee) : ze(nt.x, nt.y, u + ee);
          }
        }
      }
      de(), be();
      function de() {
        const I = s.length / 3;
        if (d) {
          let xe = 0, ee = H * xe;
          for (let ce = 0; ce < G; ce++) {
            const se = X[ce];
            Ne(se[2] + ee, se[1] + ee, se[0] + ee);
          }
          xe = h + p * 2, ee = H * xe;
          for (let ce = 0; ce < G; ce++) {
            const se = X[ce];
            Ne(se[0] + ee, se[1] + ee, se[2] + ee);
          }
        } else {
          for (let xe = 0; xe < G; xe++) {
            const ee = X[xe];
            Ne(ee[2], ee[1], ee[0]);
          }
          for (let xe = 0; xe < G; xe++) {
            const ee = X[xe];
            Ne(ee[0] + H * h, ee[1] + H * h, ee[2] + H * h);
          }
        }
        n.addGroup(I, s.length / 3 - I, 0);
      }
      function be() {
        const I = s.length / 3;
        let xe = 0;
        Fe(L, xe), xe += L.length;
        for (let ee = 0, ce = D.length; ee < ce; ee++) {
          const se = D[ee];
          Fe(se, xe), xe += se.length;
        }
        n.addGroup(I, s.length / 3 - I, 1);
      }
      function Fe(I, xe) {
        let ee = I.length;
        for (; --ee >= 0; ) {
          const ce = ee;
          let se = ee - 1;
          se < 0 && (se = I.length - 1);
          for (let De = 0, Ee = h + p * 2; De < Ee; De++) {
            const Re = H * De, Ge = H * (De + 1), nt = xe + ce + Re, Ct = xe + se + Re, P = xe + se + Ge, C = xe + ce + Ge;
            Xe(nt, Ct, P, C);
          }
        }
      }
      function ze(I, xe, ee) {
        l.push(I), l.push(xe), l.push(ee);
      }
      function Ne(I, xe, ee) {
        ct(I), ct(xe), ct(ee);
        const ce = s.length / 3, se = y.generateTopUV(n, s, ce - 3, ce - 2, ce - 1);
        He(se[0]), He(se[1]), He(se[2]);
      }
      function Xe(I, xe, ee, ce) {
        ct(I), ct(xe), ct(ce), ct(xe), ct(ee), ct(ce);
        const se = s.length / 3, De = y.generateSideWallUV(n, s, se - 6, se - 3, se - 2, se - 1);
        He(De[0]), He(De[1]), He(De[3]), He(De[1]), He(De[2]), He(De[3]);
      }
      function ct(I) {
        s.push(l[I * 3 + 0]), s.push(l[I * 3 + 1]), s.push(l[I * 3 + 2]);
      }
      function He(I) {
        r.push(I.x), r.push(I.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
    return u2(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let r = 0, a = e.shapes.length; r < a; r++) {
      const o = t[e.shapes[r]];
      n.push(o);
    }
    const s = e.options.extrudePath;
    return s !== void 0 && (e.options.extrudePath = new Iu[s.type]().fromJSON(s)), new Ua(n, e.options);
  }
}
const h2 = {
  generateTopUV: function(i, e, t, n, s) {
    const r = e[t * 3], a = e[t * 3 + 1], o = e[n * 3], l = e[n * 3 + 1], c = e[s * 3], h = e[s * 3 + 1];
    return [
      new k(r, a),
      new k(o, l),
      new k(c, h)
    ];
  },
  generateSideWallUV: function(i, e, t, n, s, r) {
    const a = e[t * 3], o = e[t * 3 + 1], l = e[t * 3 + 2], c = e[n * 3], h = e[n * 3 + 1], u = e[n * 3 + 2], d = e[s * 3], f = e[s * 3 + 1], m = e[s * 3 + 2], g = e[r * 3], p = e[r * 3 + 1], v = e[r * 3 + 2];
    return Math.abs(o - h) < Math.abs(a - c) ? [
      new k(a, 1 - l),
      new k(c, 1 - u),
      new k(d, 1 - m),
      new k(g, 1 - v)
    ] : [
      new k(o, 1 - l),
      new k(h, 1 - u),
      new k(f, 1 - m),
      new k(p, 1 - v)
    ];
  }
};
function u2(i, e, t) {
  if (t.shapes = [], Array.isArray(i))
    for (let n = 0, s = i.length; n < s; n++) {
      const r = i[n];
      t.shapes.push(r.uuid);
    }
  else
    t.shapes.push(i.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class Rd extends Br {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, s = [
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      0,
      0,
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      n,
      0,
      -1,
      n,
      0,
      1,
      -n,
      0,
      -1,
      -n,
      0,
      1
    ], r = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(s, r, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Rd(e.radius, e.detail);
  }
}
class Bs extends Br {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], s = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(n, s, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Bs(e.radius, e.detail);
  }
}
class Vc extends Be {
  constructor(e = 0.5, t = 1, n = 32, s = 1, r = 0, a = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: n,
      phiSegments: s,
      thetaStart: r,
      thetaLength: a
    }, n = Math.max(3, n), s = Math.max(1, s);
    const o = [], l = [], c = [], h = [];
    let u = e;
    const d = (t - e) / s, f = new T(), m = new k();
    for (let g = 0; g <= s; g++) {
      for (let p = 0; p <= n; p++) {
        const v = r + p / n * a;
        f.x = u * Math.cos(v), f.y = u * Math.sin(v), l.push(f.x, f.y, f.z), c.push(0, 0, 1), m.x = (f.x / t + 1) / 2, m.y = (f.y / t + 1) / 2, h.push(m.x, m.y);
      }
      u += d;
    }
    for (let g = 0; g < s; g++) {
      const p = g * (n + 1);
      for (let v = 0; v < n; v++) {
        const y = v + p, _ = y, x = y + n + 1, M = y + n + 2, S = y + 1;
        o.push(_, x, S), o.push(x, M, S);
      }
    }
    this.setIndex(o), this.setAttribute("position", new ye(l, 3)), this.setAttribute("normal", new ye(c, 3)), this.setAttribute("uv", new ye(h, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Vc(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class Pd extends Be {
  constructor(e = new _r([new k(0, 0.5), new k(-0.5, -0.5), new k(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const n = [], s = [], r = [], a = [];
    let o = 0, l = 0;
    if (Array.isArray(e) === !1)
      c(e);
    else
      for (let h = 0; h < e.length; h++)
        c(e[h]), this.addGroup(o, l, h), o += l, l = 0;
    this.setIndex(n), this.setAttribute("position", new ye(s, 3)), this.setAttribute("normal", new ye(r, 3)), this.setAttribute("uv", new ye(a, 2));
    function c(h) {
      const u = s.length / 3, d = h.extractPoints(t);
      let f = d.shape;
      const m = d.holes;
      ms.isClockWise(f) === !1 && (f = f.reverse());
      for (let p = 0, v = m.length; p < v; p++) {
        const y = m[p];
        ms.isClockWise(y) === !0 && (m[p] = y.reverse());
      }
      const g = ms.triangulateShape(f, m);
      for (let p = 0, v = m.length; p < v; p++) {
        const y = m[p];
        f = f.concat(y);
      }
      for (let p = 0, v = f.length; p < v; p++) {
        const y = f[p];
        s.push(y.x, y.y, 0), r.push(0, 0, 1), a.push(y.x, y.y);
      }
      for (let p = 0, v = g.length; p < v; p++) {
        const y = g[p], _ = y[0] + u, x = y[1] + u, M = y[2] + u;
        n.push(_, x, M), l += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return d2(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let s = 0, r = e.shapes.length; s < r; s++) {
      const a = t[e.shapes[s]];
      n.push(a);
    }
    return new Pd(n, e.curveSegments);
  }
}
function d2(i, e) {
  if (e.shapes = [], Array.isArray(i))
    for (let t = 0, n = i.length; t < n; t++) {
      const s = i[t];
      e.shapes.push(s.uuid);
    }
  else
    e.shapes.push(i.uuid);
  return e;
}
class Fa extends Be {
  constructor(e = 1, t = 32, n = 16, s = 0, r = Math.PI * 2, a = 0, o = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: n,
      phiStart: s,
      phiLength: r,
      thetaStart: a,
      thetaLength: o
    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
    const l = Math.min(a + o, Math.PI);
    let c = 0;
    const h = [], u = new T(), d = new T(), f = [], m = [], g = [], p = [];
    for (let v = 0; v <= n; v++) {
      const y = [], _ = v / n;
      let x = 0;
      v === 0 && a === 0 ? x = 0.5 / t : v === n && l === Math.PI && (x = -0.5 / t);
      for (let M = 0; M <= t; M++) {
        const S = M / t;
        u.x = -e * Math.cos(s + S * r) * Math.sin(a + _ * o), u.y = e * Math.cos(a + _ * o), u.z = e * Math.sin(s + S * r) * Math.sin(a + _ * o), m.push(u.x, u.y, u.z), d.copy(u).normalize(), g.push(d.x, d.y, d.z), p.push(S + x, 1 - _), y.push(c++);
      }
      h.push(y);
    }
    for (let v = 0; v < n; v++)
      for (let y = 0; y < t; y++) {
        const _ = h[v][y + 1], x = h[v][y], M = h[v + 1][y], S = h[v + 1][y + 1];
        (v !== 0 || a > 0) && f.push(_, x, S), (v !== n - 1 || l < Math.PI) && f.push(x, M, S);
      }
    this.setIndex(f), this.setAttribute("position", new ye(m, 3)), this.setAttribute("normal", new ye(g, 3)), this.setAttribute("uv", new ye(p, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Fa(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class Ld extends Br {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], s = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(n, s, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Ld(e.radius, e.detail);
  }
}
class os extends Be {
  constructor(e = 1, t = 0.4, n = 12, s = 48, r = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: n,
      tubularSegments: s,
      arc: r
    }, n = Math.floor(n), s = Math.floor(s);
    const a = [], o = [], l = [], c = [], h = new T(), u = new T(), d = new T();
    for (let f = 0; f <= n; f++)
      for (let m = 0; m <= s; m++) {
        const g = m / s * r, p = f / n * Math.PI * 2;
        u.x = (e + t * Math.cos(p)) * Math.cos(g), u.y = (e + t * Math.cos(p)) * Math.sin(g), u.z = t * Math.sin(p), o.push(u.x, u.y, u.z), h.x = e * Math.cos(g), h.y = e * Math.sin(g), d.subVectors(u, h).normalize(), l.push(d.x, d.y, d.z), c.push(m / s), c.push(f / n);
      }
    for (let f = 1; f <= n; f++)
      for (let m = 1; m <= s; m++) {
        const g = (s + 1) * f + m - 1, p = (s + 1) * (f - 1) + m - 1, v = (s + 1) * (f - 1) + m, y = (s + 1) * f + m;
        a.push(g, p, y), a.push(p, v, y);
      }
    this.setIndex(a), this.setAttribute("position", new ye(o, 3)), this.setAttribute("normal", new ye(l, 3)), this.setAttribute("uv", new ye(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new os(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Id extends Be {
  constructor(e = 1, t = 0.4, n = 64, s = 8, r = 2, a = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: n,
      radialSegments: s,
      p: r,
      q: a
    }, n = Math.floor(n), s = Math.floor(s);
    const o = [], l = [], c = [], h = [], u = new T(), d = new T(), f = new T(), m = new T(), g = new T(), p = new T(), v = new T();
    for (let _ = 0; _ <= n; ++_) {
      const x = _ / n * r * Math.PI * 2;
      y(x, r, a, e, f), y(x + 0.01, r, a, e, m), p.subVectors(m, f), v.addVectors(m, f), g.crossVectors(p, v), v.crossVectors(g, p), g.normalize(), v.normalize();
      for (let M = 0; M <= s; ++M) {
        const S = M / s * Math.PI * 2, w = -t * Math.cos(S), E = t * Math.sin(S);
        u.x = f.x + (w * v.x + E * g.x), u.y = f.y + (w * v.y + E * g.y), u.z = f.z + (w * v.z + E * g.z), l.push(u.x, u.y, u.z), d.subVectors(u, f).normalize(), c.push(d.x, d.y, d.z), h.push(_ / n), h.push(M / s);
      }
    }
    for (let _ = 1; _ <= n; _++)
      for (let x = 1; x <= s; x++) {
        const M = (s + 1) * (_ - 1) + (x - 1), S = (s + 1) * _ + (x - 1), w = (s + 1) * _ + x, E = (s + 1) * (_ - 1) + x;
        o.push(M, S, E), o.push(S, w, E);
      }
    this.setIndex(o), this.setAttribute("position", new ye(l, 3)), this.setAttribute("normal", new ye(c, 3)), this.setAttribute("uv", new ye(h, 2));
    function y(_, x, M, S, w) {
      const E = Math.cos(_), b = Math.sin(_), A = M / x * _, D = Math.cos(A);
      w.x = S * (2 + D) * 0.5 * E, w.y = S * (2 + D) * b * 0.5, w.z = S * Math.sin(A) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Id(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class Vs extends Be {
  constructor(e = new sg(new T(-1, -1, 0), new T(-1, 1, 0), new T(1, 1, 0)), t = 64, n = 1, s = 8, r = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: n,
      radialSegments: s,
      closed: r
    };
    const a = e.computeFrenetFrames(t, r);
    this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
    const o = new T(), l = new T(), c = new k();
    let h = new T();
    const u = [], d = [], f = [], m = [];
    g(), this.setIndex(m), this.setAttribute("position", new ye(u, 3)), this.setAttribute("normal", new ye(d, 3)), this.setAttribute("uv", new ye(f, 2));
    function g() {
      for (let _ = 0; _ < t; _++)
        p(_);
      p(r === !1 ? t : 0), y(), v();
    }
    function p(_) {
      h = e.getPointAt(_ / t, h);
      const x = a.normals[_], M = a.binormals[_];
      for (let S = 0; S <= s; S++) {
        const w = S / s * Math.PI * 2, E = Math.sin(w), b = -Math.cos(w);
        l.x = b * x.x + E * M.x, l.y = b * x.y + E * M.y, l.z = b * x.z + E * M.z, l.normalize(), d.push(l.x, l.y, l.z), o.x = h.x + n * l.x, o.y = h.y + n * l.y, o.z = h.z + n * l.z, u.push(o.x, o.y, o.z);
      }
    }
    function v() {
      for (let _ = 1; _ <= t; _++)
        for (let x = 1; x <= s; x++) {
          const M = (s + 1) * (_ - 1) + (x - 1), S = (s + 1) * _ + (x - 1), w = (s + 1) * _ + x, E = (s + 1) * (_ - 1) + x;
          m.push(M, S, E), m.push(S, w, E);
        }
    }
    function y() {
      for (let _ = 0; _ <= t; _++)
        for (let x = 0; x <= s; x++)
          c.x = _ / t, c.y = x / s, f.push(c.x, c.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new Vs(
      new Iu[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class ag extends Be {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], n = /* @__PURE__ */ new Set(), s = new T(), r = new T();
      if (e.index !== null) {
        const a = e.attributes.position, o = e.index;
        let l = e.groups;
        l.length === 0 && (l = [{ start: 0, count: o.count, materialIndex: 0 }]);
        for (let c = 0, h = l.length; c < h; ++c) {
          const u = l[c], d = u.start, f = u.count;
          for (let m = d, g = d + f; m < g; m += 3)
            for (let p = 0; p < 3; p++) {
              const v = o.getX(m + p), y = o.getX(m + (p + 1) % 3);
              s.fromBufferAttribute(a, v), r.fromBufferAttribute(a, y), wv(s, r, n) === !0 && (t.push(s.x, s.y, s.z), t.push(r.x, r.y, r.z));
            }
        }
      } else {
        const a = e.attributes.position;
        for (let o = 0, l = a.count / 3; o < l; o++)
          for (let c = 0; c < 3; c++) {
            const h = 3 * o + c, u = 3 * o + (c + 1) % 3;
            s.fromBufferAttribute(a, h), r.fromBufferAttribute(a, u), wv(s, r, n) === !0 && (t.push(s.x, s.y, s.z), t.push(r.x, r.y, r.z));
          }
      }
      this.setAttribute("position", new ye(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function wv(i, e, t) {
  const n = `${i.x},${i.y},${i.z}-${e.x},${e.y},${e.z}`, s = `${e.x},${e.y},${e.z}-${i.x},${i.y},${i.z}`;
  return t.has(n) === !0 || t.has(s) === !0 ? !1 : (t.add(n), t.add(s), !0);
}
var Tv = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: Pt,
  CapsuleGeometry: zc,
  CircleGeometry: Hc,
  ConeGeometry: Gc,
  CylinderGeometry: qt,
  DodecahedronGeometry: Ad,
  EdgesGeometry: Yx,
  ExtrudeGeometry: Ua,
  IcosahedronGeometry: Rd,
  LatheGeometry: kc,
  OctahedronGeometry: Bs,
  PlaneGeometry: Fr,
  PolyhedronGeometry: Br,
  RingGeometry: Vc,
  ShapeGeometry: Pd,
  SphereGeometry: Fa,
  TetrahedronGeometry: Ld,
  TorusGeometry: os,
  TorusKnotGeometry: Id,
  TubeGeometry: Vs,
  WireframeGeometry: ag
});
class Kx extends Qt {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Q(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class og extends mt {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class al extends Qt {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Q(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Q(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ur, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Xi extends al {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new k(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return Ht(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Q(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Q(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Q(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class yr extends Qt {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Q(16777215), this.specular = new Q(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Q(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ur, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Oc, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class lg extends Qt {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Q(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Q(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ur, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class Dd extends Qt {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ur, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class Od extends Qt {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Q(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Q(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ur, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Oc, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Qx extends Qt {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Q(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ur, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Jx extends Jt {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function ga(i, e, t) {
  return !i || // let 'undefined' and 'null' pass
  !t && i.constructor === e ? i : typeof e.BYTES_PER_ELEMENT == "number" ? new e(i) : Array.prototype.slice.call(i);
}
function eM(i) {
  return ArrayBuffer.isView(i) && !(i instanceof DataView);
}
function tM(i) {
  function e(s, r) {
    return i[s] - i[r];
  }
  const t = i.length, n = new Array(t);
  for (let s = 0; s !== t; ++s) n[s] = s;
  return n.sort(e), n;
}
function Gp(i, e, t) {
  const n = i.length, s = new i.constructor(n);
  for (let r = 0, a = 0; a !== n; ++r) {
    const o = t[r] * e;
    for (let l = 0; l !== e; ++l)
      s[a++] = i[o + l];
  }
  return s;
}
function cg(i, e, t, n) {
  let s = 1, r = i[0];
  for (; r !== void 0 && r[n] === void 0; )
    r = i[s++];
  if (r === void 0) return;
  let a = r[n];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        a = r[n], a !== void 0 && (e.push(r.time), t.push.apply(t, a)), r = i[s++];
      while (r !== void 0);
    else if (a.toArray !== void 0)
      do
        a = r[n], a !== void 0 && (e.push(r.time), a.toArray(t, t.length)), r = i[s++];
      while (r !== void 0);
    else
      do
        a = r[n], a !== void 0 && (e.push(r.time), t.push(a)), r = i[s++];
      while (r !== void 0);
}
function f2(i, e, t, n, s = 30) {
  const r = i.clone();
  r.name = e;
  const a = [];
  for (let l = 0; l < r.tracks.length; ++l) {
    const c = r.tracks[l], h = c.getValueSize(), u = [], d = [];
    for (let f = 0; f < c.times.length; ++f) {
      const m = c.times[f] * s;
      if (!(m < t || m >= n)) {
        u.push(c.times[f]);
        for (let g = 0; g < h; ++g)
          d.push(c.values[f * h + g]);
      }
    }
    u.length !== 0 && (c.times = ga(u, c.times.constructor), c.values = ga(d, c.values.constructor), a.push(c));
  }
  r.tracks = a;
  let o = 1 / 0;
  for (let l = 0; l < r.tracks.length; ++l)
    o > r.tracks[l].times[0] && (o = r.tracks[l].times[0]);
  for (let l = 0; l < r.tracks.length; ++l)
    r.tracks[l].shift(-1 * o);
  return r.resetDuration(), r;
}
function p2(i, e = 0, t = i, n = 30) {
  n <= 0 && (n = 30);
  const s = t.tracks.length, r = e / n;
  for (let a = 0; a < s; ++a) {
    const o = t.tracks[a], l = o.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const c = i.tracks.find(function(v) {
      return v.name === o.name && v.ValueTypeName === l;
    });
    if (c === void 0) continue;
    let h = 0;
    const u = o.getValueSize();
    o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = u / 3);
    let d = 0;
    const f = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = f / 3);
    const m = o.times.length - 1;
    let g;
    if (r <= o.times[0]) {
      const v = h, y = u - h;
      g = o.values.slice(v, y);
    } else if (r >= o.times[m]) {
      const v = m * u + h, y = v + u - h;
      g = o.values.slice(v, y);
    } else {
      const v = o.createInterpolant(), y = h, _ = u - h;
      v.evaluate(r), g = v.resultBuffer.slice(y, _);
    }
    l === "quaternion" && new pt().fromArray(g).normalize().conjugate().toArray(g);
    const p = c.times.length;
    for (let v = 0; v < p; ++v) {
      const y = v * f + d;
      if (l === "quaternion")
        pt.multiplyQuaternionsFlat(
          c.values,
          y,
          g,
          0,
          c.values,
          y
        );
      else {
        const _ = f - d * 2;
        for (let x = 0; x < _; ++x)
          c.values[y + x] -= g[x];
      }
    }
  }
  return i.blendMode = km, i;
}
const m2 = {
  convertArray: ga,
  isTypedArray: eM,
  getKeyframeOrder: tM,
  sortedArray: Gp,
  flattenJSON: cg,
  subclip: f2,
  makeClipAdditive: p2
};
class ol {
  constructor(e, t, n, s) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = s !== void 0 ? s : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex, s = t[n], r = t[n - 1];
    e: {
      t: {
        let a;
        n: {
          i: if (!(e < s)) {
            for (let o = n + 2; ; ) {
              if (s === void 0) {
                if (e < r) break i;
                return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
              }
              if (n === o) break;
              if (r = s, s = t[++n], e < s)
                break t;
            }
            a = t.length;
            break n;
          }
          if (!(e >= r)) {
            const o = t[1];
            e < o && (n = 2, r = o);
            for (let l = n - 2; ; ) {
              if (r === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === l) break;
              if (s = r, r = t[--n - 1], e >= r)
                break t;
            }
            a = n, n = 0;
            break n;
          }
          break e;
        }
        for (; n < a; ) {
          const o = n + a >>> 1;
          e < t[o] ? a = o : n = o + 1;
        }
        if (s = t[n], r = t[n - 1], r === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (s === void 0)
          return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
      }
      this._cachedIndex = n, this.intervalChanged_(n, r, s);
    }
    return this.interpolate_(n, r, e, s);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, s = this.valueSize, r = e * s;
    for (let a = 0; a !== s; ++a)
      t[a] = n[r + a];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class nM extends ol {
  constructor(e, t, n, s) {
    super(e, t, n, s), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: fa,
      endingEnd: fa
    };
  }
  intervalChanged_(e, t, n) {
    const s = this.parameterPositions;
    let r = e - 2, a = e + 1, o = s[r], l = s[a];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case pa:
          r = e, o = 2 * t - n;
          break;
        case rc:
          r = s.length - 2, o = t + s[r] - s[r + 1];
          break;
        default:
          r = e, o = n;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case pa:
          a = e, l = 2 * n - t;
          break;
        case rc:
          a = 1, l = n + s[1] - s[0];
          break;
        default:
          a = e - 1, l = t;
      }
    const c = (n - t) * 0.5, h = this.valueSize;
    this._weightPrev = c / (t - o), this._weightNext = c / (l - n), this._offsetPrev = r * h, this._offsetNext = a * h;
  }
  interpolate_(e, t, n, s) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, c = l - o, h = this._offsetPrev, u = this._offsetNext, d = this._weightPrev, f = this._weightNext, m = (n - t) / (s - t), g = m * m, p = g * m, v = -d * p + 2 * d * g - d * m, y = (1 + d) * p + (-1.5 - 2 * d) * g + (-0.5 + d) * m + 1, _ = (-1 - f) * p + (1.5 + f) * g + 0.5 * m, x = f * p - f * g;
    for (let M = 0; M !== o; ++M)
      r[M] = v * a[h + M] + y * a[c + M] + _ * a[l + M] + x * a[u + M];
    return r;
  }
}
class hg extends ol {
  constructor(e, t, n, s) {
    super(e, t, n, s);
  }
  interpolate_(e, t, n, s) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, c = l - o, h = (n - t) / (s - t), u = 1 - h;
    for (let d = 0; d !== o; ++d)
      r[d] = a[c + d] * u + a[l + d] * h;
    return r;
  }
}
class iM extends ol {
  constructor(e, t, n, s) {
    super(e, t, n, s);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class qi {
  constructor(e, t, n, s) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = ga(t, this.TimeBufferType), this.values = ga(n, this.ValueBufferType), this.setInterpolation(s || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON)
      n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: ga(e.times, Array),
        values: ga(e.values, Array)
      };
      const s = e.getInterpolation();
      s !== e.DefaultInterpolation && (n.interpolation = s);
    }
    return n.type = e.ValueTypeName, n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new iM(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new hg(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new nM(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case zo:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Ea:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case mu:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return zo;
      case this.InterpolantFactoryMethodLinear:
        return Ea;
      case this.InterpolantFactoryMethodSmooth:
        return mu;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, s = t.length; n !== s; ++n)
        t[n] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, s = t.length; n !== s; ++n)
        t[n] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const n = this.times, s = n.length;
    let r = 0, a = s - 1;
    for (; r !== s && n[r] < e; )
      ++r;
    for (; a !== -1 && n[a] > t; )
      --a;
    if (++a, r !== 0 || a !== s) {
      r >= a && (a = Math.max(a, 1), r = a - 1);
      const o = this.getValueSize();
      this.times = n.slice(r, a), this.values = this.values.slice(r * o, a * o);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const n = this.times, s = this.values, r = n.length;
    r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let a = null;
    for (let o = 0; o !== r; o++) {
      const l = n[o];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, l), e = !1;
        break;
      }
      if (a !== null && a > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, a), e = !1;
        break;
      }
      a = l;
    }
    if (s !== void 0 && eM(s))
      for (let o = 0, l = s.length; o !== l; ++o) {
        const c = s[o];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), s = this.getInterpolation() === mu, r = e.length - 1;
    let a = 1;
    for (let o = 1; o < r; ++o) {
      let l = !1;
      const c = e[o], h = e[o + 1];
      if (c !== h && (o !== 1 || c !== e[0]))
        if (s)
          l = !0;
        else {
          const u = o * n, d = u - n, f = u + n;
          for (let m = 0; m !== n; ++m) {
            const g = t[u + m];
            if (g !== t[d + m] || g !== t[f + m]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (o !== a) {
          e[a] = e[o];
          const u = o * n, d = a * n;
          for (let f = 0; f !== n; ++f)
            t[d + f] = t[u + f];
        }
        ++a;
      }
    }
    if (r > 0) {
      e[a] = e[r];
      for (let o = r * n, l = a * n, c = 0; c !== n; ++c)
        t[l + c] = t[o + c];
      ++a;
    }
    return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * n)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), n = this.constructor, s = new n(this.name, e, t);
    return s.createInterpolant = this.createInterpolant, s;
  }
}
qi.prototype.TimeBufferType = Float32Array;
qi.prototype.ValueBufferType = Float32Array;
qi.prototype.DefaultInterpolation = Ea;
class Ba extends qi {
}
Ba.prototype.ValueTypeName = "bool";
Ba.prototype.ValueBufferType = Array;
Ba.prototype.DefaultInterpolation = zo;
Ba.prototype.InterpolantFactoryMethodLinear = void 0;
Ba.prototype.InterpolantFactoryMethodSmooth = void 0;
class ug extends qi {
}
ug.prototype.ValueTypeName = "color";
class Cr extends qi {
}
Cr.prototype.ValueTypeName = "number";
class sM extends ol {
  constructor(e, t, n, s) {
    super(e, t, n, s);
  }
  interpolate_(e, t, n, s) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = (n - t) / (s - t);
    let c = e * o;
    for (let h = c + o; c !== h; c += 4)
      pt.slerpFlat(r, 0, a, c - o, a, c, l);
    return r;
  }
}
class Ws extends qi {
  InterpolantFactoryMethodLinear(e) {
    return new sM(this.times, this.values, this.getValueSize(), e);
  }
}
Ws.prototype.ValueTypeName = "quaternion";
Ws.prototype.DefaultInterpolation = Ea;
Ws.prototype.InterpolantFactoryMethodSmooth = void 0;
class ka extends qi {
}
ka.prototype.ValueTypeName = "string";
ka.prototype.ValueBufferType = Array;
ka.prototype.DefaultInterpolation = zo;
ka.prototype.InterpolantFactoryMethodLinear = void 0;
ka.prototype.InterpolantFactoryMethodSmooth = void 0;
class Rr extends qi {
}
Rr.prototype.ValueTypeName = "vector";
class Ra {
  constructor(e, t = -1, n, s = fd) {
    this.name = e, this.tracks = n, this.duration = t, this.blendMode = s, this.uuid = xi(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], n = e.tracks, s = 1 / (e.fps || 1);
    for (let a = 0, o = n.length; a !== o; ++a)
      t.push(v2(n[a]).scale(s));
    const r = new this(e.name, e.duration, t, e.blendMode);
    return r.uuid = e.uuid, r;
  }
  static toJSON(e) {
    const t = [], n = e.tracks, s = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let r = 0, a = n.length; r !== a; ++r)
      t.push(qi.toJSON(n[r]));
    return s;
  }
  static CreateFromMorphTargetSequence(e, t, n, s) {
    const r = t.length, a = [];
    for (let o = 0; o < r; o++) {
      let l = [], c = [];
      l.push(
        (o + r - 1) % r,
        o,
        (o + 1) % r
      ), c.push(0, 1, 0);
      const h = tM(l);
      l = Gp(l, 1, h), c = Gp(c, 1, h), !s && l[0] === 0 && (l.push(r), c.push(c[0])), a.push(
        new Cr(
          ".morphTargetInfluences[" + t[o].name + "]",
          l,
          c
        ).scale(1 / n)
      );
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const s = e;
      n = s.geometry && s.geometry.animations || s.animations;
    }
    for (let s = 0; s < n.length; s++)
      if (n[s].name === t)
        return n[s];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const s = {}, r = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o], h = c.name.match(r);
      if (h && h.length > 1) {
        const u = h[1];
        let d = s[u];
        d || (s[u] = d = []), d.push(c);
      }
    }
    const a = [];
    for (const o in s)
      a.push(this.CreateFromMorphTargetSequence(o, s[o], t, n));
    return a;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(u, d, f, m, g) {
      if (f.length !== 0) {
        const p = [], v = [];
        cg(f, p, v, m), p.length !== 0 && g.push(new u(d, p, v));
      }
    }, s = [], r = e.name || "default", a = e.fps || 30, o = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let u = 0; u < c.length; u++) {
      const d = c[u].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const f = {};
          let m;
          for (m = 0; m < d.length; m++)
            if (d[m].morphTargets)
              for (let g = 0; g < d[m].morphTargets.length; g++)
                f[d[m].morphTargets[g]] = -1;
          for (const g in f) {
            const p = [], v = [];
            for (let y = 0; y !== d[m].morphTargets.length; ++y) {
              const _ = d[m];
              p.push(_.time), v.push(_.morphTarget === g ? 1 : 0);
            }
            s.push(new Cr(".morphTargetInfluence[" + g + "]", p, v));
          }
          l = f.length * a;
        } else {
          const f = ".bones[" + t[u].name + "]";
          n(
            Rr,
            f + ".position",
            d,
            "pos",
            s
          ), n(
            Ws,
            f + ".quaternion",
            d,
            "rot",
            s
          ), n(
            Rr,
            f + ".scale",
            d,
            "scl",
            s
          );
        }
    }
    return s.length === 0 ? null : new this(r, l, s, o);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, s = e.length; n !== s; ++n) {
      const r = this.tracks[n];
      t = Math.max(t, r.times[r.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function g2(i) {
  switch (i.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Cr;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Rr;
    case "color":
      return ug;
    case "quaternion":
      return Ws;
    case "bool":
    case "boolean":
      return Ba;
    case "string":
      return ka;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i);
}
function v2(i) {
  if (i.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = g2(i.type);
  if (i.times === void 0) {
    const t = [], n = [];
    cg(i.keys, t, n, "value"), i.times = t, i.values = n;
  }
  return e.parse !== void 0 ? e.parse(i) : new e(i.name, i.times, i.values, i.interpolation);
}
const Pa = {
  enabled: !1,
  files: {},
  add: function(i, e) {
    this.enabled !== !1 && (this.files[i] = e);
  },
  get: function(i) {
    if (this.enabled !== !1)
      return this.files[i];
  },
  remove: function(i) {
    delete this.files[i];
  },
  clear: function() {
    this.files = {};
  }
};
class dg {
  constructor(e, t, n) {
    const s = this;
    let r = !1, a = 0, o = 0, l;
    const c = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(h) {
      o++, r === !1 && s.onStart !== void 0 && s.onStart(h, a, o), r = !0;
    }, this.itemEnd = function(h) {
      a++, s.onProgress !== void 0 && s.onProgress(h, a, o), a === o && (r = !1, s.onLoad !== void 0 && s.onLoad());
    }, this.itemError = function(h) {
      s.onError !== void 0 && s.onError(h);
    }, this.resolveURL = function(h) {
      return l ? l(h) : h;
    }, this.setURLModifier = function(h) {
      return l = h, this;
    }, this.addHandler = function(h, u) {
      return c.push(h, u), this;
    }, this.removeHandler = function(h) {
      const u = c.indexOf(h);
      return u !== -1 && c.splice(u, 2), this;
    }, this.getHandler = function(h) {
      for (let u = 0, d = c.length; u < d; u += 2) {
        const f = c[u], m = c[u + 1];
        if (f.global && (f.lastIndex = 0), f.test(h))
          return m;
      }
      return null;
    };
  }
}
const fg = /* @__PURE__ */ new dg();
class Vt {
  constructor(e) {
    this.manager = e !== void 0 ? e : fg, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const n = this;
    return new Promise(function(s, r) {
      n.load(e, s, t, r);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
Vt.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Is = {};
class _2 extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class En extends Vt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = Pa.get(e);
    if (r !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(r), this.manager.itemEnd(e);
      }, 0), r;
    if (Is[e] !== void 0) {
      Is[e].push({
        onLoad: t,
        onProgress: n,
        onError: s
      });
      return;
    }
    Is[e] = [], Is[e].push({
      onLoad: t,
      onProgress: n,
      onError: s
    });
    const a = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), o = this.mimeType, l = this.responseType;
    fetch(a).then((c) => {
      if (c.status === 200 || c.status === 0) {
        if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
          return c;
        const h = Is[e], u = c.body.getReader(), d = c.headers.get("Content-Length") || c.headers.get("X-File-Size"), f = d ? parseInt(d) : 0, m = f !== 0;
        let g = 0;
        const p = new ReadableStream({
          start(v) {
            y();
            function y() {
              u.read().then(({ done: _, value: x }) => {
                if (_)
                  v.close();
                else {
                  g += x.byteLength;
                  const M = new ProgressEvent("progress", { lengthComputable: m, loaded: g, total: f });
                  for (let S = 0, w = h.length; S < w; S++) {
                    const E = h[S];
                    E.onProgress && E.onProgress(M);
                  }
                  v.enqueue(x), y();
                }
              });
            }
          }
        });
        return new Response(p);
      } else
        throw new _2(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
    }).then((c) => {
      switch (l) {
        case "arraybuffer":
          return c.arrayBuffer();
        case "blob":
          return c.blob();
        case "document":
          return c.text().then((h) => new DOMParser().parseFromString(h, o));
        case "json":
          return c.json();
        default:
          if (o === void 0)
            return c.text();
          {
            const u = /charset="?([^;"\s]*)"?/i.exec(o), d = u && u[1] ? u[1].toLowerCase() : void 0, f = new TextDecoder(d);
            return c.arrayBuffer().then((m) => f.decode(m));
          }
      }
    }).then((c) => {
      Pa.add(e, c);
      const h = Is[e];
      delete Is[e];
      for (let u = 0, d = h.length; u < d; u++) {
        const f = h[u];
        f.onLoad && f.onLoad(c);
      }
    }).catch((c) => {
      const h = Is[e];
      if (h === void 0)
        throw this.manager.itemError(e), c;
      delete Is[e];
      for (let u = 0, d = h.length; u < d; u++) {
        const f = h[u];
        f.onError && f.onError(c);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class y2 extends Vt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const r = this, a = new En(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(JSON.parse(o)));
      } catch (l) {
        s ? s(l) : console.error(l), r.manager.itemError(e);
      }
    }, n, s);
  }
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const s = Ra.parse(e[n]);
      t.push(s);
    }
    return t;
  }
}
class x2 extends Vt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const r = this, a = [], o = new wd(), l = new En(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(r.withCredentials);
    let c = 0;
    function h(u) {
      l.load(e[u], function(d) {
        const f = r.parse(d, !0);
        a[u] = {
          width: f.width,
          height: f.height,
          format: f.format,
          mipmaps: f.mipmaps
        }, c += 1, c === 6 && (f.mipmapCount === 1 && (o.minFilter = Nt), o.image = a, o.format = f.format, o.needsUpdate = !0, t && t(o));
      }, n, s);
    }
    if (Array.isArray(e))
      for (let u = 0, d = e.length; u < d; ++u)
        h(u);
    else
      l.load(e, function(u) {
        const d = r.parse(u, !0);
        if (d.isCubemap) {
          const f = d.mipmaps.length / d.mipmapCount;
          for (let m = 0; m < f; m++) {
            a[m] = { mipmaps: [] };
            for (let g = 0; g < d.mipmapCount; g++)
              a[m].mipmaps.push(d.mipmaps[m * d.mipmapCount + g]), a[m].format = d.format, a[m].width = d.width, a[m].height = d.height;
          }
          o.image = a;
        } else
          o.image.width = d.width, o.image.height = d.height, o.mipmaps = d.mipmaps;
        d.mipmapCount === 1 && (o.minFilter = Nt), o.format = d.format, o.needsUpdate = !0, t && t(o);
      }, n, s);
    return o;
  }
}
class mc extends Vt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, a = Pa.get(e);
    if (a !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(a), r.manager.itemEnd(e);
      }, 0), a;
    const o = uc("img");
    function l() {
      h(), Pa.add(e, this), t && t(this), r.manager.itemEnd(e);
    }
    function c(u) {
      h(), s && s(u), r.manager.itemError(e), r.manager.itemEnd(e);
    }
    function h() {
      o.removeEventListener("load", l, !1), o.removeEventListener("error", c, !1);
    }
    return o.addEventListener("load", l, !1), o.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(e), o.src = e, o;
  }
}
class pg extends Vt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const r = new Fc();
    r.colorSpace = ft;
    const a = new mc(this.manager);
    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
    let o = 0;
    function l(c) {
      a.load(e[c], function(h) {
        r.images[c] = h, o++, o === 6 && (r.needsUpdate = !0, t && t(r));
      }, void 0, s);
    }
    for (let c = 0; c < e.length; ++c)
      l(c);
    return r;
  }
}
class M2 extends Vt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const r = this, a = new Co(), o = new En(this.manager);
    return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(r.withCredentials), o.load(e, function(l) {
      let c;
      try {
        c = r.parse(l);
      } catch (h) {
        if (s !== void 0)
          s(h);
        else {
          console.error(h);
          return;
        }
      }
      c.image !== void 0 ? a.image = c.image : c.data !== void 0 && (a.image.width = c.width, a.image.height = c.height, a.image.data = c.data), a.wrapS = c.wrapS !== void 0 ? c.wrapS : Kt, a.wrapT = c.wrapT !== void 0 ? c.wrapT : Kt, a.magFilter = c.magFilter !== void 0 ? c.magFilter : Nt, a.minFilter = c.minFilter !== void 0 ? c.minFilter : Nt, a.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.colorSpace !== void 0 ? a.colorSpace = c.colorSpace : c.encoding !== void 0 && (a.encoding = c.encoding), c.flipY !== void 0 && (a.flipY = c.flipY), c.format !== void 0 && (a.format = c.format), c.type !== void 0 && (a.type = c.type), c.mipmaps !== void 0 && (a.mipmaps = c.mipmaps, a.minFilter = ys), c.mipmapCount === 1 && (a.minFilter = Nt), c.generateMipmaps !== void 0 && (a.generateMipmaps = c.generateMipmaps), a.needsUpdate = !0, t && t(a, c);
    }, n, s), a;
  }
}
class Ys extends Vt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const r = new At(), a = new mc(this.manager);
    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(o) {
      r.image = o, r.needsUpdate = !0, t !== void 0 && t(r);
    }, n, s), r;
  }
}
class Ss extends Ze {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Q(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class mg extends Ss {
  constructor(e, t, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Ze.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Q(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const Cf = /* @__PURE__ */ new _e(), Ev = /* @__PURE__ */ new T(), Av = /* @__PURE__ */ new T();
class gg {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new k(512, 512), this.map = null, this.mapPass = null, this.matrix = new _e(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new yd(), this._frameExtents = new k(1, 1), this._viewportCount = 1, this._viewports = [
      new tt(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    Ev.setFromMatrixPosition(e.matrixWorld), t.position.copy(Ev), Av.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Av), t.updateMatrixWorld(), Cf.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Cf), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(Cf);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class b2 extends gg {
  constructor() {
    super(new Zt(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, n = Ho * 2 * e.angle * this.focus, s = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
    (n !== t.fov || s !== t.aspect || r !== t.far) && (t.fov = n, t.aspect = s, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class Wc extends Ss {
  constructor(e, t, n = 0, s = Math.PI / 3, r = 0, a = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Ze.DEFAULT_UP), this.updateMatrix(), this.target = new Ze(), this.distance = n, this.angle = s, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new b2();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const Cv = /* @__PURE__ */ new _e(), Ml = /* @__PURE__ */ new T(), Rf = /* @__PURE__ */ new T();
class S2 extends gg {
  constructor() {
    super(new Zt(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new k(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new tt(2, 1, 1, 1),
      // negative X
      new tt(0, 1, 1, 1),
      // positive Z
      new tt(3, 1, 1, 1),
      // negative Z
      new tt(1, 1, 1, 1),
      // positive Y
      new tt(3, 0, 1, 1),
      // negative Y
      new tt(1, 0, 1, 1)
    ], this._cubeDirections = [
      new T(1, 0, 0),
      new T(-1, 0, 0),
      new T(0, 0, 1),
      new T(0, 0, -1),
      new T(0, 1, 0),
      new T(0, -1, 0)
    ], this._cubeUps = [
      new T(0, 1, 0),
      new T(0, 1, 0),
      new T(0, 1, 0),
      new T(0, 1, 0),
      new T(0, 0, 1),
      new T(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const n = this.camera, s = this.matrix, r = e.distance || n.far;
    r !== n.far && (n.far = r, n.updateProjectionMatrix()), Ml.setFromMatrixPosition(e.matrixWorld), n.position.copy(Ml), Rf.copy(n.position), Rf.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Rf), n.updateMatrixWorld(), s.makeTranslation(-Ml.x, -Ml.y, -Ml.z), Cv.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Cv);
  }
}
class Xo extends Ss {
  constructor(e, t, n = 0, s = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = s, this.shadow = new S2();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class w2 extends gg {
  constructor() {
    super(new Na(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class Xc extends Ss {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Ze.DEFAULT_UP), this.updateMatrix(), this.target = new Ze(), this.shadow = new w2();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class Nd extends Ss {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class vg extends Ss {
  constructor(e, t, n = 10, s = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = s;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class rM {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new T());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const n = e.x, s = e.y, r = e.z, a = this.coefficients;
    return t.copy(a[0]).multiplyScalar(0.282095), t.addScaledVector(a[1], 0.488603 * s), t.addScaledVector(a[2], 0.488603 * r), t.addScaledVector(a[3], 0.488603 * n), t.addScaledVector(a[4], 1.092548 * (n * s)), t.addScaledVector(a[5], 1.092548 * (s * r)), t.addScaledVector(a[6], 0.315392 * (3 * r * r - 1)), t.addScaledVector(a[7], 1.092548 * (n * r)), t.addScaledVector(a[8], 0.546274 * (n * n - s * s)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const n = e.x, s = e.y, r = e.z, a = this.coefficients;
    return t.copy(a[0]).multiplyScalar(0.886227), t.addScaledVector(a[1], 2 * 0.511664 * s), t.addScaledVector(a[2], 2 * 0.511664 * r), t.addScaledVector(a[3], 2 * 0.511664 * n), t.addScaledVector(a[4], 2 * 0.429043 * n * s), t.addScaledVector(a[5], 2 * 0.429043 * s * r), t.addScaledVector(a[6], 0.743125 * r * r - 0.247708), t.addScaledVector(a[7], 2 * 0.429043 * n * r), t.addScaledVector(a[8], 0.429043 * (n * n - s * s)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let s = 0; s < 9; s++)
      n[s].fromArray(e, t + s * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let s = 0; s < 9; s++)
      n[s].toArray(e, t + s * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const n = e.x, s = e.y, r = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * s, t[2] = 0.488603 * r, t[3] = 0.488603 * n, t[4] = 1.092548 * n * s, t[5] = 1.092548 * s * r, t[6] = 0.315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = 0.546274 * (n * n - s * s);
  }
}
class aM extends Ss {
  constructor(e = new rM(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class Ud extends Vt {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, n, s) {
    const r = this, a = new En(r.manager);
    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(JSON.parse(o)));
      } catch (l) {
        s ? s(l) : console.error(l), r.manager.itemError(e);
      }
    }, n, s);
  }
  parse(e) {
    const t = this.textures;
    function n(r) {
      return t[r] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", r), t[r];
    }
    const s = Ud.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (s.uuid = e.uuid), e.name !== void 0 && (s.name = e.name), e.color !== void 0 && s.color !== void 0 && s.color.setHex(e.color), e.roughness !== void 0 && (s.roughness = e.roughness), e.metalness !== void 0 && (s.metalness = e.metalness), e.sheen !== void 0 && (s.sheen = e.sheen), e.sheenColor !== void 0 && (s.sheenColor = new Q().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (s.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && s.emissive !== void 0 && s.emissive.setHex(e.emissive), e.specular !== void 0 && s.specular !== void 0 && s.specular.setHex(e.specular), e.specularIntensity !== void 0 && (s.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && s.specularColor !== void 0 && s.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (s.shininess = e.shininess), e.clearcoat !== void 0 && (s.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (s.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (s.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (s.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (s.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (s.transmission = e.transmission), e.thickness !== void 0 && (s.thickness = e.thickness), e.attenuationDistance !== void 0 && (s.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && s.attenuationColor !== void 0 && s.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (s.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (s.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (s.fog = e.fog), e.flatShading !== void 0 && (s.flatShading = e.flatShading), e.blending !== void 0 && (s.blending = e.blending), e.combine !== void 0 && (s.combine = e.combine), e.side !== void 0 && (s.side = e.side), e.shadowSide !== void 0 && (s.shadowSide = e.shadowSide), e.opacity !== void 0 && (s.opacity = e.opacity), e.transparent !== void 0 && (s.transparent = e.transparent), e.alphaTest !== void 0 && (s.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (s.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (s.depthFunc = e.depthFunc), e.depthTest !== void 0 && (s.depthTest = e.depthTest), e.depthWrite !== void 0 && (s.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (s.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (s.blendSrc = e.blendSrc), e.blendDst !== void 0 && (s.blendDst = e.blendDst), e.blendEquation !== void 0 && (s.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (s.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (s.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (s.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && s.blendColor !== void 0 && s.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (s.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (s.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (s.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (s.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (s.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (s.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (s.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (s.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (s.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (s.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (s.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (s.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (s.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (s.rotation = e.rotation), e.linewidth !== void 0 && (s.linewidth = e.linewidth), e.dashSize !== void 0 && (s.dashSize = e.dashSize), e.gapSize !== void 0 && (s.gapSize = e.gapSize), e.scale !== void 0 && (s.scale = e.scale), e.polygonOffset !== void 0 && (s.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (s.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (s.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (s.dithering = e.dithering), e.alphaToCoverage !== void 0 && (s.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (s.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (s.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (s.visible = e.visible), e.toneMapped !== void 0 && (s.toneMapped = e.toneMapped), e.userData !== void 0 && (s.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? s.vertexColors = e.vertexColors > 0 : s.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const r in e.uniforms) {
        const a = e.uniforms[r];
        switch (s.uniforms[r] = {}, a.type) {
          case "t":
            s.uniforms[r].value = n(a.value);
            break;
          case "c":
            s.uniforms[r].value = new Q().setHex(a.value);
            break;
          case "v2":
            s.uniforms[r].value = new k().fromArray(a.value);
            break;
          case "v3":
            s.uniforms[r].value = new T().fromArray(a.value);
            break;
          case "v4":
            s.uniforms[r].value = new tt().fromArray(a.value);
            break;
          case "m3":
            s.uniforms[r].value = new Qe().fromArray(a.value);
            break;
          case "m4":
            s.uniforms[r].value = new _e().fromArray(a.value);
            break;
          default:
            s.uniforms[r].value = a.value;
        }
      }
    if (e.defines !== void 0 && (s.defines = e.defines), e.vertexShader !== void 0 && (s.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (s.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (s.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const r in e.extensions)
        s.extensions[r] = e.extensions[r];
    if (e.lights !== void 0 && (s.lights = e.lights), e.clipping !== void 0 && (s.clipping = e.clipping), e.size !== void 0 && (s.size = e.size), e.sizeAttenuation !== void 0 && (s.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (s.map = n(e.map)), e.matcap !== void 0 && (s.matcap = n(e.matcap)), e.alphaMap !== void 0 && (s.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (s.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (s.bumpScale = e.bumpScale), e.normalMap !== void 0 && (s.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (s.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let r = e.normalScale;
      Array.isArray(r) === !1 && (r = [r, r]), s.normalScale = new k().fromArray(r);
    }
    return e.displacementMap !== void 0 && (s.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (s.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (s.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (s.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (s.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (s.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (s.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (s.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (s.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (s.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (s.envMap = n(e.envMap)), e.envMapIntensity !== void 0 && (s.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (s.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (s.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (s.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (s.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (s.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (s.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (s.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (s.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (s.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (s.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (s.clearcoatNormalScale = new k().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (s.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (s.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (s.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (s.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (s.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (s.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (s.sheenRoughnessMap = n(e.sheenRoughnessMap)), s;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: Kx,
      SpriteMaterial: Km,
      RawShaderMaterial: og,
      ShaderMaterial: mt,
      PointsMaterial: hr,
      MeshPhysicalMaterial: Xi,
      MeshStandardMaterial: al,
      MeshPhongMaterial: yr,
      MeshToonMaterial: lg,
      MeshNormalMaterial: Dd,
      MeshLambertMaterial: Od,
      MeshDepthMaterial: Md,
      MeshDistanceMaterial: jm,
      MeshBasicMaterial: on,
      MeshMatcapMaterial: Qx,
      LineDashedMaterial: Jx,
      LineBasicMaterial: Jt,
      Material: Qt
    };
    return new t[e]();
  }
}
class Pr {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, s = e.length; n < s; n++)
      t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class _g extends Be {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class oM extends Vt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const r = this, a = new En(r.manager);
    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(JSON.parse(o)));
      } catch (l) {
        s ? s(l) : console.error(l), r.manager.itemError(e);
      }
    }, n, s);
  }
  parse(e) {
    const t = {}, n = {};
    function s(f, m) {
      if (t[m] !== void 0) return t[m];
      const p = f.interleavedBuffers[m], v = r(f, p.buffer), y = go(p.type, v), _ = new Bc(y, p.stride);
      return _.uuid = p.uuid, t[m] = _, _;
    }
    function r(f, m) {
      if (n[m] !== void 0) return n[m];
      const p = f.arrayBuffers[m], v = new Uint32Array(p).buffer;
      return n[m] = v, v;
    }
    const a = e.isInstancedBufferGeometry ? new _g() : new Be(), o = e.data.index;
    if (o !== void 0) {
      const f = go(o.type, o.array);
      a.setIndex(new dt(f, 1));
    }
    const l = e.data.attributes;
    for (const f in l) {
      const m = l[f];
      let g;
      if (m.isInterleavedBufferAttribute) {
        const p = s(e.data, m.data);
        g = new ei(p, m.itemSize, m.offset, m.normalized);
      } else {
        const p = go(m.type, m.array), v = m.isInstancedBufferAttribute ? Aa : dt;
        g = new v(p, m.itemSize, m.normalized);
      }
      m.name !== void 0 && (g.name = m.name), m.usage !== void 0 && g.setUsage(m.usage), m.updateRange !== void 0 && (g.updateRange.offset = m.updateRange.offset, g.updateRange.count = m.updateRange.count), a.setAttribute(f, g);
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const f in c) {
        const m = c[f], g = [];
        for (let p = 0, v = m.length; p < v; p++) {
          const y = m[p];
          let _;
          if (y.isInterleavedBufferAttribute) {
            const x = s(e.data, y.data);
            _ = new ei(x, y.itemSize, y.offset, y.normalized);
          } else {
            const x = go(y.type, y.array);
            _ = new dt(x, y.itemSize, y.normalized);
          }
          y.name !== void 0 && (_.name = y.name), g.push(_);
        }
        a.morphAttributes[f] = g;
      }
    e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
    const u = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (u !== void 0)
      for (let f = 0, m = u.length; f !== m; ++f) {
        const g = u[f];
        a.addGroup(g.start, g.count, g.materialIndex);
      }
    const d = e.data.boundingSphere;
    if (d !== void 0) {
      const f = new T();
      d.center !== void 0 && f.fromArray(d.center), a.boundingSphere = new oi(f, d.radius);
    }
    return e.name && (a.name = e.name), e.userData && (a.userData = e.userData), a;
  }
}
class T2 extends Vt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const r = this, a = this.path === "" ? Pr.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || a;
    const o = new En(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(l) {
      let c = null;
      try {
        c = JSON.parse(l);
      } catch (u) {
        s !== void 0 && s(u), console.error("THREE:ObjectLoader: Can't parse " + e + ".", u.message);
        return;
      }
      const h = c.metadata;
      if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
        s !== void 0 && s(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      r.parse(c, t);
    }, n, s);
  }
  async loadAsync(e, t) {
    const n = this, s = this.path === "" ? Pr.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || s;
    const r = new En(this.manager);
    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
    const a = await r.loadAsync(e, t), o = JSON.parse(a), l = o.metadata;
    if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(o);
  }
  parse(e, t) {
    const n = this.parseAnimations(e.animations), s = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, s), a = this.parseImages(e.images, function() {
      t !== void 0 && t(c);
    }), o = this.parseTextures(e.textures, a), l = this.parseMaterials(e.materials, o), c = this.parseObject(e.object, r, l, o, n), h = this.parseSkeletons(e.skeletons, c);
    if (this.bindSkeletons(c, h), t !== void 0) {
      let u = !1;
      for (const d in a)
        if (a[d].data instanceof HTMLImageElement) {
          u = !0;
          break;
        }
      u === !1 && t(c);
    }
    return c;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), s = this.parseGeometries(e.geometries, n), r = await this.parseImagesAsync(e.images), a = this.parseTextures(e.textures, r), o = this.parseMaterials(e.materials, a), l = this.parseObject(e.object, s, o, a, t), c = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, c), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, s = e.length; n < s; n++) {
        const r = new _r().fromJSON(e[n]);
        t[r.uuid] = r;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {}, s = {};
    if (t.traverse(function(r) {
      r.isBone && (s[r.uuid] = r);
    }), e !== void 0)
      for (let r = 0, a = e.length; r < a; r++) {
        const o = new rl().fromJSON(e[r], s);
        n[o.uuid] = o;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const s = new oM();
      for (let r = 0, a = e.length; r < a; r++) {
        let o;
        const l = e[r];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            o = s.parse(l);
            break;
          default:
            l.type in Tv ? o = Tv[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`);
        }
        o.uuid = l.uuid, l.name !== void 0 && (o.name = l.name), l.userData !== void 0 && (o.userData = l.userData), n[l.uuid] = o;
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {}, s = {};
    if (e !== void 0) {
      const r = new Ud();
      r.setTextures(t);
      for (let a = 0, o = e.length; a < o; a++) {
        const l = e[a];
        n[l.uuid] === void 0 && (n[l.uuid] = r.parse(l)), s[l.uuid] = n[l.uuid];
      }
    }
    return s;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const s = e[n], r = Ra.parse(s);
        t[r.uuid] = r;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this, s = {};
    let r;
    function a(l) {
      return n.manager.itemStart(l), r.load(l, function() {
        n.manager.itemEnd(l);
      }, void 0, function() {
        n.manager.itemError(l), n.manager.itemEnd(l);
      });
    }
    function o(l) {
      if (typeof l == "string") {
        const c = l, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : n.resourcePath + c;
        return a(h);
      } else
        return l.data ? {
          data: go(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new dg(t);
      r = new mc(l), r.setCrossOrigin(this.crossOrigin);
      for (let c = 0, h = e.length; c < h; c++) {
        const u = e[c], d = u.url;
        if (Array.isArray(d)) {
          const f = [];
          for (let m = 0, g = d.length; m < g; m++) {
            const p = d[m], v = o(p);
            v !== null && (v instanceof HTMLImageElement ? f.push(v) : f.push(new Co(v.data, v.width, v.height)));
          }
          s[u.uuid] = new ma(f);
        } else {
          const f = o(u.url);
          s[u.uuid] = new ma(f);
        }
      }
    }
    return s;
  }
  async parseImagesAsync(e) {
    const t = this, n = {};
    let s;
    async function r(a) {
      if (typeof a == "string") {
        const o = a, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(o) ? o : t.resourcePath + o;
        return await s.loadAsync(l);
      } else
        return a.data ? {
          data: go(a.type, a.data),
          width: a.width,
          height: a.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      s = new mc(this.manager), s.setCrossOrigin(this.crossOrigin);
      for (let a = 0, o = e.length; a < o; a++) {
        const l = e[a], c = l.url;
        if (Array.isArray(c)) {
          const h = [];
          for (let u = 0, d = c.length; u < d; u++) {
            const f = c[u], m = await r(f);
            m !== null && (m instanceof HTMLImageElement ? h.push(m) : h.push(new Co(m.data, m.width, m.height)));
          }
          n[l.uuid] = new ma(h);
        } else {
          const h = await r(l.url);
          n[l.uuid] = new ma(h);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(r, a) {
      return typeof r == "number" ? r : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", r), a[r]);
    }
    const s = {};
    if (e !== void 0)
      for (let r = 0, a = e.length; r < a; r++) {
        const o = e[r];
        o.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), t[o.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", o.image);
        const l = t[o.image], c = l.data;
        let h;
        Array.isArray(c) ? (h = new Fc(), c.length === 6 && (h.needsUpdate = !0)) : (c && c.data ? h = new Co() : h = new At(), c && (h.needsUpdate = !0)), h.source = l, h.uuid = o.uuid, o.name !== void 0 && (h.name = o.name), o.mapping !== void 0 && (h.mapping = n(o.mapping, E2)), o.channel !== void 0 && (h.channel = o.channel), o.offset !== void 0 && h.offset.fromArray(o.offset), o.repeat !== void 0 && h.repeat.fromArray(o.repeat), o.center !== void 0 && h.center.fromArray(o.center), o.rotation !== void 0 && (h.rotation = o.rotation), o.wrap !== void 0 && (h.wrapS = n(o.wrap[0], Rv), h.wrapT = n(o.wrap[1], Rv)), o.format !== void 0 && (h.format = o.format), o.internalFormat !== void 0 && (h.internalFormat = o.internalFormat), o.type !== void 0 && (h.type = o.type), o.colorSpace !== void 0 && (h.colorSpace = o.colorSpace), o.encoding !== void 0 && (h.encoding = o.encoding), o.minFilter !== void 0 && (h.minFilter = n(o.minFilter, Pv)), o.magFilter !== void 0 && (h.magFilter = n(o.magFilter, Pv)), o.anisotropy !== void 0 && (h.anisotropy = o.anisotropy), o.flipY !== void 0 && (h.flipY = o.flipY), o.generateMipmaps !== void 0 && (h.generateMipmaps = o.generateMipmaps), o.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = o.premultiplyAlpha), o.unpackAlignment !== void 0 && (h.unpackAlignment = o.unpackAlignment), o.compareFunction !== void 0 && (h.compareFunction = o.compareFunction), o.userData !== void 0 && (h.userData = o.userData), s[o.uuid] = h;
      }
    return s;
  }
  parseObject(e, t, n, s, r) {
    let a;
    function o(d) {
      return t[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", d), t[d];
    }
    function l(d) {
      if (d !== void 0) {
        if (Array.isArray(d)) {
          const f = [];
          for (let m = 0, g = d.length; m < g; m++) {
            const p = d[m];
            n[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), f.push(n[p]);
          }
          return f;
        }
        return n[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", d), n[d];
      }
    }
    function c(d) {
      return s[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", d), s[d];
    }
    let h, u;
    switch (e.type) {
      case "Scene":
        a = new $m(), e.background !== void 0 && (Number.isInteger(e.background) ? a.background = new Q(e.background) : a.background = c(e.background)), e.environment !== void 0 && (a.environment = c(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? a.fog = new sl(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (a.fog = new il(e.fog.color, e.fog.density)), e.fog.name !== "" && (a.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (a.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (a.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        a = new Zt(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (a.focus = e.focus), e.zoom !== void 0 && (a.zoom = e.zoom), e.filmGauge !== void 0 && (a.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (a.filmOffset = e.filmOffset), e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        a = new Na(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (a.zoom = e.zoom), e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        a = new Nd(e.color, e.intensity);
        break;
      case "DirectionalLight":
        a = new Xc(e.color, e.intensity);
        break;
      case "PointLight":
        a = new Xo(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        a = new vg(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        a = new Wc(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        a = new mg(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        a = new aM().fromJSON(e);
        break;
      case "SkinnedMesh":
        h = o(e.geometry), u = l(e.material), a = new Sd(h, u), e.bindMode !== void 0 && (a.bindMode = e.bindMode), e.bindMatrix !== void 0 && a.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (a.skeleton = e.skeleton);
        break;
      case "Mesh":
        h = o(e.geometry), u = l(e.material), a = new le(h, u);
        break;
      case "InstancedMesh":
        h = o(e.geometry), u = l(e.material);
        const d = e.count, f = e.instanceMatrix, m = e.instanceColor;
        a = new Qm(h, u, d), a.instanceMatrix = new Aa(new Float32Array(f.array), 16), m !== void 0 && (a.instanceColor = new Aa(new Float32Array(m.array), m.itemSize));
        break;
      case "LOD":
        a = new Hx();
        break;
      case "Line":
        a = new pn(o(e.geometry), l(e.material));
        break;
      case "LineLoop":
        a = new Jm(o(e.geometry), l(e.material));
        break;
      case "LineSegments":
        a = new bi(o(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        a = new ya(o(e.geometry), l(e.material));
        break;
      case "Sprite":
        a = new zx(l(e.material));
        break;
      case "Group":
        a = new Gn();
        break;
      case "Bone":
        a = new Vo();
        break;
      default:
        a = new Ze();
    }
    if (a.uuid = e.uuid, e.name !== void 0 && (a.name = e.name), e.matrix !== void 0 ? (a.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (a.matrixAutoUpdate = e.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (e.position !== void 0 && a.position.fromArray(e.position), e.rotation !== void 0 && a.rotation.fromArray(e.rotation), e.quaternion !== void 0 && a.quaternion.fromArray(e.quaternion), e.scale !== void 0 && a.scale.fromArray(e.scale)), e.up !== void 0 && a.up.fromArray(e.up), e.castShadow !== void 0 && (a.castShadow = e.castShadow), e.receiveShadow !== void 0 && (a.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (a.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (a.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (a.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && a.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (a.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (a.visible = e.visible), e.frustumCulled !== void 0 && (a.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (a.renderOrder = e.renderOrder), e.userData !== void 0 && (a.userData = e.userData), e.layers !== void 0 && (a.layers.mask = e.layers), e.children !== void 0) {
      const d = e.children;
      for (let f = 0; f < d.length; f++)
        a.add(this.parseObject(d[f], t, n, s, r));
    }
    if (e.animations !== void 0) {
      const d = e.animations;
      for (let f = 0; f < d.length; f++) {
        const m = d[f];
        a.animations.push(r[m]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (a.autoUpdate = e.autoUpdate);
      const d = e.levels;
      for (let f = 0; f < d.length; f++) {
        const m = d[f], g = a.getObjectByProperty("uuid", m.object);
        g !== void 0 && a.addLevel(g, m.distance, m.hysteresis);
      }
    }
    return a;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(n) {
      if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
        const s = t[n.skeleton];
        s === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(s, n.bindMatrix);
      }
    });
  }
}
const E2 = {
  UVMapping: ud,
  CubeReflectionMapping: Gs,
  CubeRefractionMapping: Tr,
  EquirectangularReflectionMapping: ko,
  EquirectangularRefractionMapping: ic,
  CubeUVReflectionMapping: tl
}, Rv = {
  RepeatWrapping: Tn,
  ClampToEdgeWrapping: Kt,
  MirroredRepeatWrapping: Er
}, Pv = {
  NearestFilter: lt,
  NearestMipmapNearestFilter: sc,
  NearestMipmapLinearFilter: Eo,
  LinearFilter: Nt,
  LinearMipmapNearestFilter: dd,
  LinearMipmapLinearFilter: ys
};
class lM extends Vt {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, n, s) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, a = Pa.get(e);
    if (a !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(a), r.manager.itemEnd(e);
      }, 0), a;
    const o = {};
    o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader, fetch(e, o).then(function(l) {
      return l.blob();
    }).then(function(l) {
      return createImageBitmap(l, Object.assign(r.options, { colorSpaceConversion: "none" }));
    }).then(function(l) {
      Pa.add(e, l), t && t(l), r.manager.itemEnd(e);
    }).catch(function(l) {
      s && s(l), r.manager.itemError(e), r.manager.itemEnd(e);
    }), r.manager.itemStart(e);
  }
}
let Hh;
class yg {
  static getContext() {
    return Hh === void 0 && (Hh = new (window.AudioContext || window.webkitAudioContext)()), Hh;
  }
  static setContext(e) {
    Hh = e;
  }
}
class A2 extends Vt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const r = this, a = new En(this.manager);
    a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
      try {
        const c = l.slice(0);
        yg.getContext().decodeAudioData(c, function(u) {
          t(u);
        }, o);
      } catch (c) {
        o(c);
      }
    }, n, s);
    function o(l) {
      s ? s(l) : console.error(l), r.manager.itemError(e);
    }
  }
}
const Lv = /* @__PURE__ */ new _e(), Iv = /* @__PURE__ */ new _e(), Kr = /* @__PURE__ */ new _e();
class C2 {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Zt(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Zt(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, Kr.copy(e.projectionMatrix);
      const s = t.eyeSep / 2, r = s * t.near / t.focus, a = t.near * Math.tan(_a * t.fov * 0.5) / t.zoom;
      let o, l;
      Iv.elements[12] = -s, Lv.elements[12] = s, o = -a * t.aspect + r, l = a * t.aspect + r, Kr.elements[0] = 2 * t.near / (l - o), Kr.elements[8] = (l + o) / (l - o), this.cameraL.projectionMatrix.copy(Kr), o = -a * t.aspect - r, l = a * t.aspect - r, Kr.elements[0] = 2 * t.near / (l - o), Kr.elements[8] = (l + o) / (l - o), this.cameraR.projectionMatrix.copy(Kr);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Iv), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Lv);
  }
}
class qc {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = Dv(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = Dv();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function Dv() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Qr = /* @__PURE__ */ new T(), Ov = /* @__PURE__ */ new pt(), R2 = /* @__PURE__ */ new T(), Jr = /* @__PURE__ */ new T();
class P2 extends Ze {
  constructor() {
    super(), this.type = "AudioListener", this.context = yg.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new qc();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, n = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Qr, Ov, R2), Jr.set(0, 0, -1).applyQuaternion(Ov), t.positionX) {
      const s = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Qr.x, s), t.positionY.linearRampToValueAtTime(Qr.y, s), t.positionZ.linearRampToValueAtTime(Qr.z, s), t.forwardX.linearRampToValueAtTime(Jr.x, s), t.forwardY.linearRampToValueAtTime(Jr.y, s), t.forwardZ.linearRampToValueAtTime(Jr.z, s), t.upX.linearRampToValueAtTime(n.x, s), t.upY.linearRampToValueAtTime(n.y, s), t.upZ.linearRampToValueAtTime(n.z, s);
    } else
      t.setPosition(Qr.x, Qr.y, Qr.z), t.setOrientation(Jr.x, Jr.y, Jr.z, n.x, n.y, n.z);
  }
}
class cM extends Ze {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const ea = /* @__PURE__ */ new T(), Nv = /* @__PURE__ */ new pt(), L2 = /* @__PURE__ */ new T(), ta = /* @__PURE__ */ new T();
class I2 extends cM {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, n) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(ea, Nv, L2), ta.set(0, 0, 1).applyQuaternion(Nv);
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(ea.x, n), t.positionY.linearRampToValueAtTime(ea.y, n), t.positionZ.linearRampToValueAtTime(ea.z, n), t.orientationX.linearRampToValueAtTime(ta.x, n), t.orientationY.linearRampToValueAtTime(ta.y, n), t.orientationZ.linearRampToValueAtTime(ta.z, n);
    } else
      t.setPosition(ea.x, ea.y, ea.z), t.setOrientation(ta.x, ta.y, ta.z);
  }
}
class D2 {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++)
      e += t[n];
    return e / t.length;
  }
}
class hM {
  constructor(e, t, n) {
    this.binding = e, this.valueSize = n;
    let s, r, a;
    switch (t) {
      case "quaternion":
        s = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        s = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
        break;
      default:
        s = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
    }
    this._mixBufferRegion = s, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const n = this.buffer, s = this.valueSize, r = e * s + s;
    let a = this.cumulativeWeight;
    if (a === 0) {
      for (let o = 0; o !== s; ++o)
        n[r + o] = n[o];
      a = t;
    } else {
      a += t;
      const o = t / a;
      this._mixBufferRegion(n, r, 0, o, s);
    }
    this.cumulativeWeight = a;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, n = this.valueSize, s = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, s, 0, e, n), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, n = this.buffer, s = e * t + t, r = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
      const l = t * this._origIndex;
      this._mixBufferRegion(
        n,
        s,
        l,
        1 - r,
        t
      );
    }
    a > 0 && this._mixBufferRegionAdditive(n, s, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (n[l] !== n[l + t]) {
        o.setValue(n, s);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, n = this.valueSize, s = n * this._origIndex;
    e.getValue(t, s);
    for (let r = n, a = s; r !== a; ++r)
      t[r] = t[s + r % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let n = e; n < t; n++)
      this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  // mix functions
  _select(e, t, n, s, r) {
    if (s >= 0.5)
      for (let a = 0; a !== r; ++a)
        e[t + a] = e[n + a];
  }
  _slerp(e, t, n, s) {
    pt.slerpFlat(e, t, e, t, e, n, s);
  }
  _slerpAdditive(e, t, n, s, r) {
    const a = this._workIndex * r;
    pt.multiplyQuaternionsFlat(e, a, e, t, e, n), pt.slerpFlat(e, t, e, t, e, a, s);
  }
  _lerp(e, t, n, s, r) {
    const a = 1 - s;
    for (let o = 0; o !== r; ++o) {
      const l = t + o;
      e[l] = e[l] * a + e[n + o] * s;
    }
  }
  _lerpAdditive(e, t, n, s, r) {
    for (let a = 0; a !== r; ++a) {
      const o = t + a;
      e[o] = e[o] + e[n + a] * s;
    }
  }
}
const xg = "\\[\\]\\.:\\/", O2 = new RegExp("[" + xg + "]", "g"), Mg = "[^" + xg + "]", N2 = "[^" + xg.replace("\\.", "") + "]", U2 = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", Mg), F2 = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", N2), B2 = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Mg), k2 = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Mg), z2 = new RegExp(
  "^" + U2 + F2 + B2 + k2 + "$"
), H2 = ["material", "materials", "bones", "map"];
class G2 {
  constructor(e, t, n) {
    const s = n || it.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, s);
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, s = this._bindings[n];
    s !== void 0 && s.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let s = this._targetGroup.nCachedObjects_, r = n.length; s !== r; ++s)
      n[s].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class it {
  constructor(e, t, n) {
    this.path = t, this.parsedPath = n || it.parseTrackName(t), this.node = it.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup ? new it.Composite(e, t, n) : new it(e, t, n);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(O2, "");
  }
  static parseTrackName(e) {
    const t = z2.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, s = n.nodeName && n.nodeName.lastIndexOf(".");
    if (s !== void 0 && s !== -1) {
      const r = n.nodeName.substring(s + 1);
      H2.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, s), n.objectName = r);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return n;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0)
        return n;
    }
    if (e.children) {
      const n = function(r) {
        for (let a = 0; a < r.length; a++) {
          const o = r[a];
          if (o.name === t || o.uuid === t)
            return o;
          const l = n(o.children);
          if (l) return l;
        }
        return null;
      }, s = n(e.children);
      if (s)
        return s;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let s = 0, r = n.length; s !== r; ++s)
      e[t++] = n[s];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let s = 0, r = n.length; s !== r; ++s)
      n[s] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let s = 0, r = n.length; s !== r; ++s)
      n[s] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let s = 0, r = n.length; s !== r; ++s)
      n[s] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, n = t.objectName, s = t.propertyName;
    let r = t.propertyIndex;
    if (e || (e = it.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (n) {
      let c = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === c) {
              c = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[n];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[c];
      }
    }
    const a = e[s];
    if (a === void 0) {
      const c = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + s + " but it wasn't found.", e);
      return;
    }
    let o = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? o = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (r !== void 0) {
      if (s === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r;
    } else a.fromArray !== void 0 && a.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (l = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = s;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][o];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
it.Composite = G2;
it.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
it.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
it.prototype.GetterByBindingType = [
  it.prototype._getValue_direct,
  it.prototype._getValue_array,
  it.prototype._getValue_arrayElement,
  it.prototype._getValue_toArray
];
it.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    it.prototype._setValue_direct,
    it.prototype._setValue_direct_setNeedsUpdate,
    it.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    it.prototype._setValue_array,
    it.prototype._setValue_array_setNeedsUpdate,
    it.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    it.prototype._setValue_arrayElement,
    it.prototype._setValue_arrayElement_setNeedsUpdate,
    it.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    it.prototype._setValue_fromArray,
    it.prototype._setValue_fromArray_setNeedsUpdate,
    it.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class V2 {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = xi(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, s = arguments.length; n !== s; ++n)
      e[arguments[n].uuid] = n;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, n = this._paths, s = this._parsedPaths, r = this._bindings, a = r.length;
    let o, l = e.length, c = this.nCachedObjects_;
    for (let h = 0, u = arguments.length; h !== u; ++h) {
      const d = arguments[h], f = d.uuid;
      let m = t[f];
      if (m === void 0) {
        m = l++, t[f] = m, e.push(d);
        for (let g = 0, p = a; g !== p; ++g)
          r[g].push(new it(d, n[g], s[g]));
      } else if (m < c) {
        o = e[m];
        const g = --c, p = e[g];
        t[p.uuid] = m, e[m] = p, t[f] = g, e[g] = d;
        for (let v = 0, y = a; v !== y; ++v) {
          const _ = r[v], x = _[g];
          let M = _[m];
          _[m] = x, M === void 0 && (M = new it(d, n[v], s[v])), _[g] = M;
        }
      } else e[m] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = c;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, s = n.length;
    let r = this.nCachedObjects_;
    for (let a = 0, o = arguments.length; a !== o; ++a) {
      const l = arguments[a], c = l.uuid, h = t[c];
      if (h !== void 0 && h >= r) {
        const u = r++, d = e[u];
        t[d.uuid] = h, e[h] = d, t[c] = u, e[u] = l;
        for (let f = 0, m = s; f !== m; ++f) {
          const g = n[f], p = g[u], v = g[h];
          g[h] = p, g[u] = v;
        }
      }
    }
    this.nCachedObjects_ = r;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, s = n.length;
    let r = this.nCachedObjects_, a = e.length;
    for (let o = 0, l = arguments.length; o !== l; ++o) {
      const c = arguments[o], h = c.uuid, u = t[h];
      if (u !== void 0)
        if (delete t[h], u < r) {
          const d = --r, f = e[d], m = --a, g = e[m];
          t[f.uuid] = u, e[u] = f, t[g.uuid] = d, e[d] = g, e.pop();
          for (let p = 0, v = s; p !== v; ++p) {
            const y = n[p], _ = y[d], x = y[m];
            y[u] = _, y[d] = x, y.pop();
          }
        } else {
          const d = --a, f = e[d];
          d > 0 && (t[f.uuid] = u), e[u] = f, e.pop();
          for (let m = 0, g = s; m !== g; ++m) {
            const p = n[m];
            p[u] = p[d], p.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let s = n[e];
    const r = this._bindings;
    if (s !== void 0) return r[s];
    const a = this._paths, o = this._parsedPaths, l = this._objects, c = l.length, h = this.nCachedObjects_, u = new Array(c);
    s = r.length, n[e] = s, a.push(e), o.push(t), r.push(u);
    for (let d = h, f = l.length; d !== f; ++d) {
      const m = l[d];
      u[d] = new it(m, e, t);
    }
    return u;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, n = t[e];
    if (n !== void 0) {
      const s = this._paths, r = this._parsedPaths, a = this._bindings, o = a.length - 1, l = a[o], c = e[o];
      t[c] = n, a[n] = l, a.pop(), r[n] = r[o], r.pop(), s[n] = s[o], s.pop();
    }
  }
}
class uM {
  constructor(e, t, n = null, s = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = s;
    const r = t.tracks, a = r.length, o = new Array(a), l = {
      endingStart: fa,
      endingEnd: fa
    };
    for (let c = 0; c !== a; ++c) {
      const h = r[c].createInterpolant(null);
      o[c] = h, h.settings = l;
    }
    this._interpolantSettings = l, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Bm, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if (e.fadeOut(t), this.fadeIn(t), n) {
      const s = this._clip.duration, r = e._clip.duration, a = r / s, o = s / r;
      e.warp(1, a, t), this.warp(o, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const s = this._mixer, r = s.time, a = this.timeScale;
    let o = this._timeScaleInterpolant;
    o === null && (o = s._lendControlInterpolant(), this._timeScaleInterpolant = o);
    const l = o.parameterPositions, c = o.sampleValues;
    return l[0] = r, l[1] = r + n, c[0] = e / a, c[1] = t / a, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, n, s) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const r = this._startTime;
    if (r !== null) {
      const l = (e - r) * n;
      l < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * l);
    }
    t *= this._updateTimeScale(e);
    const a = this._updateTime(t), o = this._updateWeight(e);
    if (o > 0) {
      const l = this._interpolants, c = this._propertyBindings;
      switch (this.blendMode) {
        case km:
          for (let h = 0, u = l.length; h !== u; ++h)
            l[h].evaluate(a), c[h].accumulateAdditive(o);
          break;
        case fd:
        default:
          for (let h = 0, u = l.length; h !== u; ++h)
            l[h].evaluate(a), c[h].accumulate(s, o);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const s = n.evaluate(e)[0];
        t *= s, e > n.parameterPositions[1] && (this.stopFading(), s === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const s = n.evaluate(e)[0];
        t *= s, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, n = this.loop;
    let s = this.time + e, r = this._loopCount;
    const a = n === ux;
    if (e === 0)
      return r === -1 ? s : a && (r & 1) === 1 ? t - s : s;
    if (n === Fm) {
      r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (s >= t)
          s = t;
        else if (s < 0)
          s = 0;
        else {
          this.time = s;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = s, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), s >= t || s < 0) {
        const o = Math.floor(s / t);
        s -= t * o, r += Math.abs(o);
        const l = this.repetitions - r;
        if (l <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, s = e > 0 ? t : 0, this.time = s, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, a);
          } else
            this._setEndings(!1, !1, a);
          this._loopCount = r, this.time = s, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: o
          });
        }
      } else
        this.time = s;
      if (a && (r & 1) === 1)
        return t - s;
    }
    return s;
  }
  _setEndings(e, t, n) {
    const s = this._interpolantSettings;
    n ? (s.endingStart = pa, s.endingEnd = pa) : (e ? s.endingStart = this.zeroSlopeAtStart ? pa : fa : s.endingStart = rc, t ? s.endingEnd = this.zeroSlopeAtEnd ? pa : fa : s.endingEnd = rc);
  }
  _scheduleFading(e, t, n) {
    const s = this._mixer, r = s.time;
    let a = this._weightInterpolant;
    a === null && (a = s._lendControlInterpolant(), this._weightInterpolant = a);
    const o = a.parameterPositions, l = a.sampleValues;
    return o[0] = r, l[0] = t, o[1] = r + e, l[1] = n, this;
  }
}
const W2 = new Float32Array(1);
class dM extends bs {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root, s = e._clip.tracks, r = s.length, a = e._propertyBindings, o = e._interpolants, l = n.uuid, c = this._bindingsByRootAndName;
    let h = c[l];
    h === void 0 && (h = {}, c[l] = h);
    for (let u = 0; u !== r; ++u) {
      const d = s[u], f = d.name;
      let m = h[f];
      if (m !== void 0)
        ++m.referenceCount, a[u] = m;
      else {
        if (m = a[u], m !== void 0) {
          m._cacheIndex === null && (++m.referenceCount, this._addInactiveBinding(m, l, f));
          continue;
        }
        const g = t && t._propertyBindings[u].binding.parsedPath;
        m = new hM(
          it.create(n, f, g),
          d.ValueTypeName,
          d.getValueSize()
        ), ++m.referenceCount, this._addInactiveBinding(m, l, f), a[u] = m;
      }
      o[u].resultBuffer = m.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid, s = e._clip.uuid, r = this._actionsByClip[s];
        this._bindAction(
          e,
          r && r.knownActions[0]
        ), this._addInactiveAction(e, s, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, s = t.length; n !== s; ++n) {
        const r = t[n];
        r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, s = t.length; n !== s; ++n) {
        const r = t[n];
        --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const s = this._actions, r = this._actionsByClip;
    let a = r[t];
    if (a === void 0)
      a = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, r[t] = a;
    else {
      const o = a.knownActions;
      e._byClipCacheIndex = o.length, o.push(e);
    }
    e._cacheIndex = s.length, s.push(e), a.actionByRoot[n] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, n = t[t.length - 1], s = e._cacheIndex;
    n._cacheIndex = s, t[s] = n, t.pop(), e._cacheIndex = null;
    const r = e._clip.uuid, a = this._actionsByClip, o = a[r], l = o.knownActions, c = l[l.length - 1], h = e._byClipCacheIndex;
    c._byClipCacheIndex = h, l[h] = c, l.pop(), e._byClipCacheIndex = null;
    const u = o.actionByRoot, d = (e._localRoot || this._root).uuid;
    delete u[d], l.length === 0 && delete a[r], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, s = t.length; n !== s; ++n) {
      const r = t[n];
      --r.referenceCount === 0 && this._removeInactiveBinding(r);
    }
  }
  _lendAction(e) {
    const t = this._actions, n = e._cacheIndex, s = this._nActiveActions++, r = t[s];
    e._cacheIndex = s, t[s] = e, r._cacheIndex = n, t[n] = r;
  }
  _takeBackAction(e) {
    const t = this._actions, n = e._cacheIndex, s = --this._nActiveActions, r = t[s];
    e._cacheIndex = s, t[s] = e, r._cacheIndex = n, t[n] = r;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, n) {
    const s = this._bindingsByRootAndName, r = this._bindings;
    let a = s[t];
    a === void 0 && (a = {}, s[t] = a), a[n] = e, e._cacheIndex = r.length, r.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, n = e.binding, s = n.rootNode.uuid, r = n.path, a = this._bindingsByRootAndName, o = a[s], l = t[t.length - 1], c = e._cacheIndex;
    l._cacheIndex = c, t[c] = l, t.pop(), delete o[r], Object.keys(o).length === 0 && delete a[s];
  }
  _lendBinding(e) {
    const t = this._bindings, n = e._cacheIndex, s = this._nActiveBindings++, r = t[s];
    e._cacheIndex = s, t[s] = e, r._cacheIndex = n, t[n] = r;
  }
  _takeBackBinding(e) {
    const t = this._bindings, n = e._cacheIndex, s = --this._nActiveBindings, r = t[s];
    e._cacheIndex = s, t[s] = e, r._cacheIndex = n, t[n] = r;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let n = e[t];
    return n === void 0 && (n = new hg(
      new Float32Array(2),
      new Float32Array(2),
      1,
      W2
    ), n.__cacheIndex = t, e[t] = n), n;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, n = e.__cacheIndex, s = --this._nActiveControlInterpolants, r = t[s];
    e.__cacheIndex = s, t[s] = e, r.__cacheIndex = n, t[n] = r;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, n) {
    const s = t || this._root, r = s.uuid;
    let a = typeof e == "string" ? Ra.findByName(s, e) : e;
    const o = a !== null ? a.uuid : e, l = this._actionsByClip[o];
    let c = null;
    if (n === void 0 && (a !== null ? n = a.blendMode : n = fd), l !== void 0) {
      const u = l.actionByRoot[r];
      if (u !== void 0 && u.blendMode === n)
        return u;
      c = l.knownActions[0], a === null && (a = c._clip);
    }
    if (a === null) return null;
    const h = new uM(this, a, t, n);
    return this._bindAction(h, c), this._addInactiveAction(h, o, r), h;
  }
  // get an existing action
  existingAction(e, t) {
    const n = t || this._root, s = n.uuid, r = typeof e == "string" ? Ra.findByName(n, e) : e, a = r ? r.uuid : e, o = this._actionsByClip[a];
    return o !== void 0 && o.actionByRoot[s] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n)
      e[n].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, n = this._nActiveActions, s = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1;
    for (let c = 0; c !== n; ++c)
      t[c]._update(s, e, r, a);
    const o = this._bindings, l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c)
      o[c].apply(a);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, n = e.uuid, s = this._actionsByClip, r = s[n];
    if (r !== void 0) {
      const a = r.knownActions;
      for (let o = 0, l = a.length; o !== l; ++o) {
        const c = a[o];
        this._deactivateAction(c);
        const h = c._cacheIndex, u = t[t.length - 1];
        c._cacheIndex = null, c._byClipCacheIndex = null, u._cacheIndex = h, t[h] = u, t.pop(), this._removeInactiveBindingsForAction(c);
      }
      delete s[n];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, n = this._actionsByClip;
    for (const a in n) {
      const o = n[a].actionByRoot, l = o[t];
      l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const s = this._bindingsByRootAndName, r = s[t];
    if (r !== void 0)
      for (const a in r) {
        const o = r[a];
        o.restoreOriginalState(), this._removeInactiveBinding(o);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class bg {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new bg(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let X2 = 0;
class q2 extends bs {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: X2++ }), this.name = "", this.usage = cc, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, s = t.length; n < s; n++)
      this.uniforms.push(t[n].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Du extends Bc {
  constructor(e, t, n = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class Y2 {
  constructor(e, t, n, s, r) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = s, this.count = r, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
class Fd {
  constructor(e, t, n = 0, s = 1 / 0) {
    this.ray = new Oa(e, t), this.near = n, this.far = s, this.camera = null, this.layers = new gd(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, n = []) {
    return Vp(e, this, n, t), n.sort(Uv), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let s = 0, r = e.length; s < r; s++)
      Vp(e[s], this, n, t);
    return n.sort(Uv), n;
  }
}
function Uv(i, e) {
  return i.distance - e.distance;
}
function Vp(i, e, t, n) {
  if (i.layers.test(e.layers) && i.raycast(e, t), n === !0) {
    const s = i.children;
    for (let r = 0, a = s.length; r < a; r++)
      Vp(s[r], e, t, !0);
  }
}
class Wp {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Ht(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class j2 {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Fv = /* @__PURE__ */ new k();
class Z2 {
  constructor(e = new k(1 / 0, 1 / 0), t = new k(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Fv.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Fv).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Bv = /* @__PURE__ */ new T(), Gh = /* @__PURE__ */ new T();
class fM {
  constructor(e = new T(), t = new T()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    Bv.subVectors(e, this.start), Gh.subVectors(this.end, this.start);
    const n = Gh.dot(Gh);
    let r = Gh.dot(Bv) / n;
    return t && (r = Ht(r, 0, 1)), r;
  }
  closestPointToPoint(e, t, n) {
    const s = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(s).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const kv = /* @__PURE__ */ new T();
class $2 extends Ze {
  constructor(e, t) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const n = new Be(), s = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let a = 0, o = 1, l = 32; a < l; a++, o++) {
      const c = a / l * Math.PI * 2, h = o / l * Math.PI * 2;
      s.push(
        Math.cos(c),
        Math.sin(c),
        1,
        Math.cos(h),
        Math.sin(h),
        1
      );
    }
    n.setAttribute("position", new ye(s, 3));
    const r = new Jt({ fog: !1, toneMapped: !1 });
    this.cone = new bi(n, r), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), kv.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(kv), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const nr = /* @__PURE__ */ new T(), Vh = /* @__PURE__ */ new _e(), Pf = /* @__PURE__ */ new _e();
class K2 extends bi {
  constructor(e) {
    const t = pM(e), n = new Be(), s = [], r = [], a = new Q(0, 0, 1), o = new Q(0, 1, 0);
    for (let c = 0; c < t.length; c++) {
      const h = t[c];
      h.parent && h.parent.isBone && (s.push(0, 0, 0), s.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b));
    }
    n.setAttribute("position", new ye(s, 3)), n.setAttribute("color", new ye(r, 3));
    const l = new Jt({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(n, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, n = this.geometry, s = n.getAttribute("position");
    Pf.copy(this.root.matrixWorld).invert();
    for (let r = 0, a = 0; r < t.length; r++) {
      const o = t[r];
      o.parent && o.parent.isBone && (Vh.multiplyMatrices(Pf, o.matrixWorld), nr.setFromMatrixPosition(Vh), s.setXYZ(a, nr.x, nr.y, nr.z), Vh.multiplyMatrices(Pf, o.parent.matrixWorld), nr.setFromMatrixPosition(Vh), s.setXYZ(a + 1, nr.x, nr.y, nr.z), a += 2);
    }
    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function pM(i) {
  const e = [];
  i.isBone === !0 && e.push(i);
  for (let t = 0; t < i.children.length; t++)
    e.push.apply(e, pM(i.children[t]));
  return e;
}
class Q2 extends le {
  constructor(e, t, n) {
    const s = new Fa(t, 4, 2), r = new on({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(s, r), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const J2 = /* @__PURE__ */ new T(), zv = /* @__PURE__ */ new Q(), Hv = /* @__PURE__ */ new Q();
class eR extends Ze {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
    const s = new Bs(t);
    s.rotateY(Math.PI * 0.5), this.material = new on({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const r = s.getAttribute("position"), a = new Float32Array(r.count * 3);
    s.setAttribute("color", new dt(a, 3)), this.add(new le(s, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      zv.copy(this.light.color), Hv.copy(this.light.groundColor);
      for (let n = 0, s = t.count; n < s; n++) {
        const r = n < s / 2 ? zv : Hv;
        t.setXYZ(n, r.r, r.g, r.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(J2.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class Sg extends bi {
  constructor(e = 10, t = 10, n = 4473924, s = 8947848) {
    n = new Q(n), s = new Q(s);
    const r = t / 2, a = e / t, o = e / 2, l = [], c = [];
    for (let d = 0, f = 0, m = -o; d <= t; d++, m += a) {
      l.push(-o, 0, m, o, 0, m), l.push(m, 0, -o, m, 0, o);
      const g = d === r ? n : s;
      g.toArray(c, f), f += 3, g.toArray(c, f), f += 3, g.toArray(c, f), f += 3, g.toArray(c, f), f += 3;
    }
    const h = new Be();
    h.setAttribute("position", new ye(l, 3)), h.setAttribute("color", new ye(c, 3));
    const u = new Jt({ vertexColors: !0, toneMapped: !1 });
    super(h, u), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class tR extends bi {
  constructor(e = 10, t = 16, n = 8, s = 64, r = 4473924, a = 8947848) {
    r = new Q(r), a = new Q(a);
    const o = [], l = [];
    if (t > 1)
      for (let u = 0; u < t; u++) {
        const d = u / t * (Math.PI * 2), f = Math.sin(d) * e, m = Math.cos(d) * e;
        o.push(0, 0, 0), o.push(f, 0, m);
        const g = u & 1 ? r : a;
        l.push(g.r, g.g, g.b), l.push(g.r, g.g, g.b);
      }
    for (let u = 0; u < n; u++) {
      const d = u & 1 ? r : a, f = e - e / n * u;
      for (let m = 0; m < s; m++) {
        let g = m / s * (Math.PI * 2), p = Math.sin(g) * f, v = Math.cos(g) * f;
        o.push(p, 0, v), l.push(d.r, d.g, d.b), g = (m + 1) / s * (Math.PI * 2), p = Math.sin(g) * f, v = Math.cos(g) * f, o.push(p, 0, v), l.push(d.r, d.g, d.b);
      }
    }
    const c = new Be();
    c.setAttribute("position", new ye(o, 3)), c.setAttribute("color", new ye(l, 3));
    const h = new Jt({ vertexColors: !0, toneMapped: !1 });
    super(c, h), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const Gv = /* @__PURE__ */ new T(), Wh = /* @__PURE__ */ new T(), Vv = /* @__PURE__ */ new T();
class nR extends Ze {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let s = new Be();
    s.setAttribute("position", new ye([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const r = new Jt({ fog: !1, toneMapped: !1 });
    this.lightPlane = new pn(s, r), this.add(this.lightPlane), s = new Be(), s.setAttribute("position", new ye([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new pn(s, r), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), Gv.setFromMatrixPosition(this.light.matrixWorld), Wh.setFromMatrixPosition(this.light.target.matrixWorld), Vv.subVectors(Wh, Gv), this.lightPlane.lookAt(Wh), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Wh), this.targetLine.scale.z = Vv.length();
  }
}
const Xh = /* @__PURE__ */ new T(), kt = /* @__PURE__ */ new _d();
class iR extends bi {
  constructor(e) {
    const t = new Be(), n = new Jt({ color: 16777215, vertexColors: !0, toneMapped: !1 }), s = [], r = [], a = {};
    o("n1", "n2"), o("n2", "n4"), o("n4", "n3"), o("n3", "n1"), o("f1", "f2"), o("f2", "f4"), o("f4", "f3"), o("f3", "f1"), o("n1", "f1"), o("n2", "f2"), o("n3", "f3"), o("n4", "f4"), o("p", "n1"), o("p", "n2"), o("p", "n3"), o("p", "n4"), o("u1", "u2"), o("u2", "u3"), o("u3", "u1"), o("c", "t"), o("p", "c"), o("cn1", "cn2"), o("cn3", "cn4"), o("cf1", "cf2"), o("cf3", "cf4");
    function o(m, g) {
      l(m), l(g);
    }
    function l(m) {
      s.push(0, 0, 0), r.push(0, 0, 0), a[m] === void 0 && (a[m] = []), a[m].push(s.length / 3 - 1);
    }
    t.setAttribute("position", new ye(s, 3)), t.setAttribute("color", new ye(r, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update();
    const c = new Q(16755200), h = new Q(16711680), u = new Q(43775), d = new Q(16777215), f = new Q(3355443);
    this.setColors(c, h, u, d, f);
  }
  setColors(e, t, n, s, r) {
    const o = this.geometry.getAttribute("color");
    o.setXYZ(0, e.r, e.g, e.b), o.setXYZ(1, e.r, e.g, e.b), o.setXYZ(2, e.r, e.g, e.b), o.setXYZ(3, e.r, e.g, e.b), o.setXYZ(4, e.r, e.g, e.b), o.setXYZ(5, e.r, e.g, e.b), o.setXYZ(6, e.r, e.g, e.b), o.setXYZ(7, e.r, e.g, e.b), o.setXYZ(8, e.r, e.g, e.b), o.setXYZ(9, e.r, e.g, e.b), o.setXYZ(10, e.r, e.g, e.b), o.setXYZ(11, e.r, e.g, e.b), o.setXYZ(12, e.r, e.g, e.b), o.setXYZ(13, e.r, e.g, e.b), o.setXYZ(14, e.r, e.g, e.b), o.setXYZ(15, e.r, e.g, e.b), o.setXYZ(16, e.r, e.g, e.b), o.setXYZ(17, e.r, e.g, e.b), o.setXYZ(18, e.r, e.g, e.b), o.setXYZ(19, e.r, e.g, e.b), o.setXYZ(20, e.r, e.g, e.b), o.setXYZ(21, e.r, e.g, e.b), o.setXYZ(22, e.r, e.g, e.b), o.setXYZ(23, e.r, e.g, e.b), o.setXYZ(24, t.r, t.g, t.b), o.setXYZ(25, t.r, t.g, t.b), o.setXYZ(26, t.r, t.g, t.b), o.setXYZ(27, t.r, t.g, t.b), o.setXYZ(28, t.r, t.g, t.b), o.setXYZ(29, t.r, t.g, t.b), o.setXYZ(30, t.r, t.g, t.b), o.setXYZ(31, t.r, t.g, t.b), o.setXYZ(32, n.r, n.g, n.b), o.setXYZ(33, n.r, n.g, n.b), o.setXYZ(34, n.r, n.g, n.b), o.setXYZ(35, n.r, n.g, n.b), o.setXYZ(36, n.r, n.g, n.b), o.setXYZ(37, n.r, n.g, n.b), o.setXYZ(38, s.r, s.g, s.b), o.setXYZ(39, s.r, s.g, s.b), o.setXYZ(40, r.r, r.g, r.b), o.setXYZ(41, r.r, r.g, r.b), o.setXYZ(42, r.r, r.g, r.b), o.setXYZ(43, r.r, r.g, r.b), o.setXYZ(44, r.r, r.g, r.b), o.setXYZ(45, r.r, r.g, r.b), o.setXYZ(46, r.r, r.g, r.b), o.setXYZ(47, r.r, r.g, r.b), o.setXYZ(48, r.r, r.g, r.b), o.setXYZ(49, r.r, r.g, r.b), o.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, n = 1, s = 1;
    kt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Xt("c", t, e, kt, 0, 0, -1), Xt("t", t, e, kt, 0, 0, 1), Xt("n1", t, e, kt, -1, -1, -1), Xt("n2", t, e, kt, n, -1, -1), Xt("n3", t, e, kt, -1, s, -1), Xt("n4", t, e, kt, n, s, -1), Xt("f1", t, e, kt, -1, -1, 1), Xt("f2", t, e, kt, n, -1, 1), Xt("f3", t, e, kt, -1, s, 1), Xt("f4", t, e, kt, n, s, 1), Xt("u1", t, e, kt, n * 0.7, s * 1.1, -1), Xt("u2", t, e, kt, -1 * 0.7, s * 1.1, -1), Xt("u3", t, e, kt, 0, s * 2, -1), Xt("cf1", t, e, kt, -1, 0, 1), Xt("cf2", t, e, kt, n, 0, 1), Xt("cf3", t, e, kt, 0, -1, 1), Xt("cf4", t, e, kt, 0, s, 1), Xt("cn1", t, e, kt, -1, 0, -1), Xt("cn2", t, e, kt, n, 0, -1), Xt("cn3", t, e, kt, 0, -1, -1), Xt("cn4", t, e, kt, 0, s, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Xt(i, e, t, n, s, r, a) {
  Xh.set(s, r, a).unproject(n);
  const o = e[i];
  if (o !== void 0) {
    const l = t.getAttribute("position");
    for (let c = 0, h = o.length; c < h; c++)
      l.setXYZ(o[c], Xh.x, Xh.y, Xh.z);
  }
}
const qh = /* @__PURE__ */ new ln();
class sR extends bi {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), s = new Float32Array(8 * 3), r = new Be();
    r.setIndex(new dt(n, 1)), r.setAttribute("position", new dt(s, 3)), super(r, new Jt({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && qh.setFromObject(this.object), qh.isEmpty()) return;
    const t = qh.min, n = qh.max, s = this.geometry.attributes.position, r = s.array;
    r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = t.x, r[4] = n.y, r[5] = n.z, r[6] = t.x, r[7] = t.y, r[8] = n.z, r[9] = n.x, r[10] = t.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = t.z, r[15] = t.x, r[16] = n.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = n.x, r[22] = t.y, r[23] = t.z, s.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class mM extends bi {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), s = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], r = new Be();
    r.setIndex(new dt(n, 1)), r.setAttribute("position", new ye(s, 3)), super(r, new Jt({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class rR extends pn {
  constructor(e, t = 1, n = 16776960) {
    const s = n, r = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], a = new Be();
    a.setAttribute("position", new ye(r, 3)), a.computeBoundingSphere(), super(a, new Jt({ color: s, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new Be();
    l.setAttribute("position", new ye(o, 3)), l.computeBoundingSphere(), this.add(new le(l, new on({ color: s, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const Wv = /* @__PURE__ */ new T();
let Yh, Lf;
class aR extends Ze {
  // dir is assumed to be normalized
  constructor(e = new T(0, 0, 1), t = new T(0, 0, 0), n = 1, s = 16776960, r = n * 0.2, a = r * 0.2) {
    super(), this.type = "ArrowHelper", Yh === void 0 && (Yh = new Be(), Yh.setAttribute("position", new ye([0, 0, 0, 0, 1, 0], 3)), Lf = new qt(0, 0.5, 1, 5, 1), Lf.translate(0, -0.5, 0)), this.position.copy(t), this.line = new pn(Yh, new Jt({ color: s, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new le(Lf, new on({ color: s, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, r, a);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      Wv.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(Wv, t);
    }
  }
  setLength(e, t = e * 0.2, n = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class wg extends bi {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], n = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], s = new Be();
    s.setAttribute("position", new ye(t, 3)), s.setAttribute("color", new ye(n, 3));
    const r = new Jt({ vertexColors: !0, toneMapped: !1 });
    super(s, r), this.type = "AxesHelper";
  }
  setColors(e, t, n) {
    const s = new Q(), r = this.geometry.attributes.color.array;
    return s.set(e), s.toArray(r, 0), s.toArray(r, 3), s.set(t), s.toArray(r, 6), s.toArray(r, 9), s.set(n), s.toArray(r, 12), s.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class gM {
  constructor() {
    this.type = "ShapePath", this.color = new Q(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new Wo(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, s) {
    return this.currentPath.quadraticCurveTo(e, t, n, s), this;
  }
  bezierCurveTo(e, t, n, s, r, a) {
    return this.currentPath.bezierCurveTo(e, t, n, s, r, a), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(v) {
      const y = [];
      for (let _ = 0, x = v.length; _ < x; _++) {
        const M = v[_], S = new _r();
        S.curves = M.curves, y.push(S);
      }
      return y;
    }
    function n(v, y) {
      const _ = y.length;
      let x = !1;
      for (let M = _ - 1, S = 0; S < _; M = S++) {
        let w = y[M], E = y[S], b = E.x - w.x, A = E.y - w.y;
        if (Math.abs(A) > Number.EPSILON) {
          if (A < 0 && (w = y[S], b = -b, E = y[M], A = -A), v.y < w.y || v.y > E.y) continue;
          if (v.y === w.y) {
            if (v.x === w.x) return !0;
          } else {
            const D = A * (v.x - w.x) - b * (v.y - w.y);
            if (D === 0) return !0;
            if (D < 0) continue;
            x = !x;
          }
        } else {
          if (v.y !== w.y) continue;
          if (E.x <= v.x && v.x <= w.x || w.x <= v.x && v.x <= E.x) return !0;
        }
      }
      return x;
    }
    const s = ms.isClockWise, r = this.subPaths;
    if (r.length === 0) return [];
    let a, o, l;
    const c = [];
    if (r.length === 1)
      return o = r[0], l = new _r(), l.curves = o.curves, c.push(l), c;
    let h = !s(r[0].getPoints());
    h = e ? !h : h;
    const u = [], d = [];
    let f = [], m = 0, g;
    d[m] = void 0, f[m] = [];
    for (let v = 0, y = r.length; v < y; v++)
      o = r[v], g = o.getPoints(), a = s(g), a = e ? !a : a, a ? (!h && d[m] && m++, d[m] = { s: new _r(), p: g }, d[m].s.curves = o.curves, h && m++, f[m] = []) : f[m].push({ h: o, p: g[0] });
    if (!d[0]) return t(r);
    if (d.length > 1) {
      let v = !1, y = 0;
      for (let _ = 0, x = d.length; _ < x; _++)
        u[_] = [];
      for (let _ = 0, x = d.length; _ < x; _++) {
        const M = f[_];
        for (let S = 0; S < M.length; S++) {
          const w = M[S];
          let E = !0;
          for (let b = 0; b < d.length; b++)
            n(w.p, d[b].p) && (_ !== b && y++, E ? (E = !1, u[b].push(w)) : v = !0);
          E && u[_].push(w);
        }
      }
      y > 0 && v === !1 && (f = u);
    }
    let p;
    for (let v = 0, y = d.length; v < y; v++) {
      l = d[v].s, c.push(l), p = f[v];
      for (let _ = 0, x = p.length; _ < x; _++)
        l.holes.push(p[_].h);
    }
    return c;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: td
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = td);
const oR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: hd,
  AddEquation: mi,
  AddOperation: Jy,
  AdditiveAnimationBlendMode: km,
  AdditiveBlending: Ta,
  AlphaFormat: sx,
  AlwaysCompare: bx,
  AlwaysDepth: qy,
  AlwaysStencilFunc: Op,
  AmbientLight: Nd,
  AnimationAction: uM,
  AnimationClip: Ra,
  AnimationLoader: y2,
  AnimationMixer: dM,
  AnimationObjectGroup: V2,
  AnimationUtils: m2,
  ArcCurve: Vx,
  ArrayCamera: Fx,
  ArrowHelper: aR,
  AttachedBindMode: lp,
  Audio: cM,
  AudioAnalyser: D2,
  AudioContext: yg,
  AudioListener: P2,
  AudioLoader: A2,
  AxesHelper: wg,
  BackSide: Wn,
  BasicDepthPacking: fx,
  BasicShadowMap: zy,
  Bone: Vo,
  BooleanKeyframeTrack: Ba,
  Box2: Z2,
  Box3: ln,
  Box3Helper: mM,
  BoxGeometry: Pt,
  BoxHelper: sR,
  BufferAttribute: dt,
  BufferGeometry: Be,
  BufferGeometryLoader: oM,
  ByteType: nx,
  Cache: Pa,
  Camera: _d,
  CameraHelper: iR,
  CanvasTexture: kC,
  CapsuleGeometry: zc,
  CatmullRomCurve3: Ed,
  CineonToneMapping: cd,
  CircleGeometry: Hc,
  ClampToEdgeWrapping: Kt,
  Clock: qc,
  Color: Q,
  ColorKeyframeTrack: ug,
  ColorManagement: gt,
  CompressedArrayTexture: FC,
  CompressedCubeTexture: BC,
  CompressedTexture: wd,
  CompressedTextureLoader: x2,
  ConeGeometry: Gc,
  ConstantAlphaFactor: Vy,
  ConstantColorFactor: Hy,
  CubeCamera: Rx,
  CubeReflectionMapping: Gs,
  CubeRefractionMapping: Tr,
  CubeTexture: Fc,
  CubeTextureLoader: pg,
  CubeUVReflectionMapping: tl,
  CubicBezierCurve: tg,
  CubicBezierCurve3: Wx,
  CubicInterpolant: nM,
  CullFaceBack: op,
  CullFaceFront: ky,
  CullFaceFrontBack: z1,
  CullFaceNone: By,
  Curve: Oi,
  CurvePath: qx,
  CustomBlending: Fo,
  CustomToneMapping: ex,
  CylinderGeometry: qt,
  Cylindrical: j2,
  Data3DTexture: Xm,
  DataArrayTexture: md,
  DataTexture: Co,
  DataTextureLoader: M2,
  DataUtils: XS,
  DecrementStencilOp: Z1,
  DecrementWrapStencilOp: K1,
  DefaultLoadingManager: fg,
  DepthFormat: gr,
  DepthStencilFormat: Ar,
  DepthTexture: bd,
  DetachedBindMode: tx,
  DirectionalLight: Xc,
  DirectionalLightHelper: nR,
  DiscreteInterpolant: iM,
  DisplayP3ColorSpace: pd,
  DodecahedronGeometry: Ad,
  DoubleSide: $t,
  DstAlphaFactor: Ic,
  DstColorFactor: Dc,
  DynamicCopyUsage: dS,
  DynamicDrawUsage: aS,
  DynamicReadUsage: cS,
  EdgesGeometry: Yx,
  EllipseCurve: Td,
  EqualCompare: vx,
  EqualDepth: jy,
  EqualStencilFunc: tS,
  EquirectangularReflectionMapping: ko,
  EquirectangularRefractionMapping: ic,
  Euler: Jn,
  EventDispatcher: bs,
  ExtrudeGeometry: Ua,
  FileLoader: En,
  Float16BufferAttribute: KS,
  Float32BufferAttribute: ye,
  Float64BufferAttribute: QS,
  FloatType: hs,
  Fog: sl,
  FogExp2: il,
  FramebufferTexture: UC,
  FrontSide: Wi,
  Frustum: yd,
  GLBufferAttribute: Y2,
  GLSL1: pS,
  GLSL3: Np,
  GreaterCompare: yx,
  GreaterDepth: $y,
  GreaterEqualCompare: Mx,
  GreaterEqualDepth: Zy,
  GreaterEqualStencilFunc: rS,
  GreaterStencilFunc: iS,
  GridHelper: Sg,
  Group: Gn,
  HalfFloatType: zt,
  HemisphereLight: mg,
  HemisphereLightHelper: eR,
  IcosahedronGeometry: Rd,
  ImageBitmapLoader: lM,
  ImageLoader: mc,
  ImageUtils: Wm,
  IncrementStencilOp: j1,
  IncrementWrapStencilOp: $1,
  InstancedBufferAttribute: Aa,
  InstancedBufferGeometry: _g,
  InstancedInterleavedBuffer: Du,
  InstancedMesh: Qm,
  Int16BufferAttribute: ZS,
  Int32BufferAttribute: $S,
  Int8BufferAttribute: qS,
  IntType: Lm,
  InterleavedBuffer: Bc,
  InterleavedBufferAttribute: ei,
  Interpolant: ol,
  InterpolateDiscrete: zo,
  InterpolateLinear: Ea,
  InterpolateSmooth: mu,
  InvertStencilOp: Q1,
  KeepStencilOp: la,
  KeyframeTrack: qi,
  LOD: Hx,
  LatheGeometry: kc,
  Layers: gd,
  LessCompare: gx,
  LessDepth: Yy,
  LessEqualCompare: _x,
  LessEqualDepth: nc,
  LessEqualStencilFunc: nS,
  LessStencilFunc: eS,
  Light: Ss,
  LightProbe: aM,
  Line: pn,
  Line3: fM,
  LineBasicMaterial: Jt,
  LineCurve: ng,
  LineCurve3: Xx,
  LineDashedMaterial: Jx,
  LineLoop: Jm,
  LineSegments: bi,
  LinearDisplayP3ColorSpace: Uc,
  LinearEncoding: Hm,
  LinearFilter: Nt,
  LinearInterpolant: hg,
  LinearMipMapLinearFilter: X1,
  LinearMipMapNearestFilter: W1,
  LinearMipmapLinearFilter: ys,
  LinearMipmapNearestFilter: dd,
  LinearSRGBColorSpace: en,
  LinearToneMapping: od,
  LinearTransfer: ac,
  Loader: Vt,
  LoaderUtils: Pr,
  LoadingManager: dg,
  LoopOnce: Fm,
  LoopPingPong: ux,
  LoopRepeat: Bm,
  LuminanceAlphaFormat: ax,
  LuminanceFormat: rx,
  MOUSE: aa,
  Material: Qt,
  MaterialLoader: Ud,
  MathUtils: Kn,
  Matrix3: Qe,
  Matrix4: _e,
  MaxEquation: Cu,
  Mesh: le,
  MeshBasicMaterial: on,
  MeshDepthMaterial: Md,
  MeshDistanceMaterial: jm,
  MeshLambertMaterial: Od,
  MeshMatcapMaterial: Qx,
  MeshNormalMaterial: Dd,
  MeshPhongMaterial: yr,
  MeshPhysicalMaterial: Xi,
  MeshStandardMaterial: al,
  MeshToonMaterial: lg,
  MinEquation: Au,
  MirroredRepeatWrapping: Er,
  MixOperation: Qy,
  MultiplyBlending: Eu,
  MultiplyOperation: Oc,
  NearestFilter: lt,
  NearestMipMapLinearFilter: V1,
  NearestMipMapNearestFilter: G1,
  NearestMipmapLinearFilter: Eo,
  NearestMipmapNearestFilter: sc,
  NeverCompare: mx,
  NeverDepth: Xy,
  NeverStencilFunc: J1,
  NoBlending: vt,
  NoColorSpace: vi,
  NoToneMapping: ps,
  NormalAnimationBlendMode: fd,
  NormalBlending: Gi,
  NotEqualCompare: xx,
  NotEqualDepth: Ky,
  NotEqualStencilFunc: sS,
  NumberKeyframeTrack: Cr,
  Object3D: Ze,
  ObjectLoader: T2,
  ObjectSpaceNormalMap: px,
  OctahedronGeometry: Bs,
  OneFactor: Lc,
  OneMinusConstantAlphaFactor: Wy,
  OneMinusConstantColorFactor: Gy,
  OneMinusDstAlphaFactor: rd,
  OneMinusDstColorFactor: ad,
  OneMinusSrcAlphaFactor: wr,
  OneMinusSrcColorFactor: sd,
  OrthographicCamera: Na,
  P3Primaries: lc,
  PCFShadowMap: nd,
  PCFSoftShadowMap: Am,
  PMREMGenerator: Fp,
  Path: Wo,
  PerspectiveCamera: Zt,
  Plane: as,
  PlaneGeometry: Fr,
  PlaneHelper: rR,
  PointLight: Xo,
  PointLightHelper: Q2,
  Points: ya,
  PointsMaterial: hr,
  PolarGridHelper: tR,
  PolyhedronGeometry: Br,
  PositionalAudio: I2,
  PropertyBinding: it,
  PropertyMixer: hM,
  QuadraticBezierCurve: ig,
  QuadraticBezierCurve3: sg,
  Quaternion: pt,
  QuaternionKeyframeTrack: Ws,
  QuaternionLinearInterpolant: sM,
  RED_GREEN_RGTC2_Format: Ip,
  RED_RGTC1_Format: hx,
  REVISION: td,
  RGBADepthPacking: Gm,
  RGBAFormat: gi,
  RGBAIntegerFormat: Um,
  RGBA_ASTC_10x10_Format: Ep,
  RGBA_ASTC_10x5_Format: Sp,
  RGBA_ASTC_10x6_Format: wp,
  RGBA_ASTC_10x8_Format: Tp,
  RGBA_ASTC_12x10_Format: Ap,
  RGBA_ASTC_12x12_Format: Cp,
  RGBA_ASTC_4x4_Format: mp,
  RGBA_ASTC_5x4_Format: gp,
  RGBA_ASTC_5x5_Format: vp,
  RGBA_ASTC_6x5_Format: _p,
  RGBA_ASTC_6x6_Format: yp,
  RGBA_ASTC_8x5_Format: xp,
  RGBA_ASTC_8x6_Format: Mp,
  RGBA_ASTC_8x8_Format: bp,
  RGBA_BPTC_Format: pu,
  RGBA_ETC2_EAC_Format: pp,
  RGBA_PVRTC_2BPPV1_Format: dp,
  RGBA_PVRTC_4BPPV1_Format: up,
  RGBA_S3TC_DXT1_Format: uu,
  RGBA_S3TC_DXT3_Format: du,
  RGBA_S3TC_DXT5_Format: fu,
  RGB_BPTC_SIGNED_Format: Rp,
  RGB_BPTC_UNSIGNED_Format: Pp,
  RGB_ETC1_Format: cx,
  RGB_ETC2_Format: fp,
  RGB_PVRTC_2BPPV1_Format: hp,
  RGB_PVRTC_4BPPV1_Format: cp,
  RGB_S3TC_DXT1_Format: hu,
  RGFormat: lx,
  RGIntegerFormat: Nm,
  RawShaderMaterial: og,
  Ray: Oa,
  Raycaster: Fd,
  Rec709Primaries: oc,
  RectAreaLight: vg,
  RedFormat: ox,
  RedIntegerFormat: Om,
  ReinhardToneMapping: ld,
  RenderTarget: Ex,
  RepeatWrapping: Tn,
  ReplaceStencilOp: Y1,
  ReverseSubtractEquation: Rm,
  RingGeometry: Vc,
  SIGNED_RED_GREEN_RGTC2_Format: Dp,
  SIGNED_RED_RGTC1_Format: Lp,
  SRGBColorSpace: ft,
  SRGBTransfer: Mt,
  Scene: $m,
  ShaderChunk: Ke,
  ShaderLib: zn,
  ShaderMaterial: mt,
  ShadowMaterial: Kx,
  Shape: _r,
  ShapeGeometry: Pd,
  ShapePath: gM,
  ShapeUtils: ms,
  ShortType: ix,
  Skeleton: rl,
  SkeletonHelper: K2,
  SkinnedMesh: Sd,
  Source: ma,
  Sphere: oi,
  SphereGeometry: Fa,
  Spherical: Wp,
  SphericalHarmonics3: rM,
  SplineCurve: rg,
  SpotLight: Wc,
  SpotLightHelper: $2,
  Sprite: zx,
  SpriteMaterial: Km,
  SrcAlphaFactor: Sr,
  SrcAlphaSaturateFactor: Pm,
  SrcColorFactor: id,
  StaticCopyUsage: uS,
  StaticDrawUsage: cc,
  StaticReadUsage: lS,
  StereoCamera: C2,
  StreamCopyUsage: fS,
  StreamDrawUsage: oS,
  StreamReadUsage: hS,
  StringKeyframeTrack: ka,
  SubtractEquation: Cm,
  SubtractiveBlending: Tu,
  TOUCH: oa,
  TangentSpaceNormalMap: Ur,
  TetrahedronGeometry: Ld,
  Texture: At,
  TextureLoader: Ys,
  TorusGeometry: os,
  TorusKnotGeometry: Id,
  Triangle: Zn,
  TriangleFanDrawMode: Ru,
  TriangleStripDrawMode: zm,
  TrianglesDrawMode: dx,
  TubeGeometry: Vs,
  TwoPassDoubleSide: H1,
  UVMapping: ud,
  Uint16BufferAttribute: vd,
  Uint32BufferAttribute: qm,
  Uint8BufferAttribute: YS,
  Uint8ClampedBufferAttribute: jS,
  Uniform: bg,
  UniformsGroup: q2,
  UniformsLib: ve,
  UniformsUtils: cn,
  UnsignedByteType: ks,
  UnsignedInt248Type: zs,
  UnsignedIntType: Fs,
  UnsignedShort4444Type: Im,
  UnsignedShort5551Type: Dm,
  UnsignedShortType: Nc,
  VSMShadowMap: zi,
  Vector2: k,
  Vector3: T,
  Vector4: tt,
  VectorKeyframeTrack: Rr,
  VideoTexture: Gx,
  WebGL1Renderer: Bx,
  WebGL3DRenderTarget: DS,
  WebGLArrayRenderTarget: IS,
  WebGLCoordinateSystem: us,
  WebGLCubeRenderTarget: Px,
  WebGLMultipleRenderTargets: OS,
  WebGLRenderTarget: xt,
  WebGLRenderer: Zm,
  WebGLUtils: Ux,
  WebGPUCoordinateSystem: hc,
  WireframeGeometry: ag,
  WrapAroundEnding: rc,
  ZeroCurvatureEnding: fa,
  ZeroFactor: Bo,
  ZeroSlopeEnding: pa,
  ZeroStencilOp: q1,
  _SRGBAFormat: Pu,
  createCanvasElement: Tx,
  sRGBEncoding: vr
}, Symbol.toStringTag, { value: "Module" }));
function Ds(i) {
  if (i === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return i;
}
function vM(i, e) {
  i.prototype = Object.create(e.prototype), i.prototype.constructor = i, i.__proto__ = e;
}
/*!
 * GSAP 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Mi = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
}, qo = {
  duration: 0.5,
  overwrite: !1,
  delay: 0
}, Tg, wn, Lt, gs = 1e8, In = 1 / gs, Xp = Math.PI * 2, lR = Xp / 4, cR = 0, _M = Math.sqrt, hR = Math.cos, uR = Math.sin, gn = function(e) {
  return typeof e == "string";
}, Gt = function(e) {
  return typeof e == "function";
}, Xs = function(e) {
  return typeof e == "number";
}, Eg = function(e) {
  return typeof e > "u";
}, xs = function(e) {
  return typeof e == "object";
}, ti = function(e) {
  return e !== !1;
}, Ag = function() {
  return typeof window < "u";
}, jh = function(e) {
  return Gt(e) || gn(e);
}, yM = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, Dn = Array.isArray, qp = /(?:-?\.?\d|\.)+/gi, xM = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, yo = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, If = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, MM = /[+-]=-?[.\d]+/, bM = /[^,'"\[\]\s]+/gi, dR = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Ot, rs, Yp, Cg, Si = {}, Ou = {}, SM, wM = function(e) {
  return (Ou = Yo(e, Si)) && ri;
}, Rg = function(e, t) {
  return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()");
}, gc = function(e, t) {
  return !t && console.warn(e);
}, TM = function(e, t) {
  return e && (Si[e] = t) && Ou && (Ou[e] = t) || Si;
}, vc = function() {
  return 0;
}, fR = {
  suppressEvents: !0,
  isStart: !0,
  kill: !1
}, vu = {
  suppressEvents: !0,
  kill: !1
}, pR = {
  suppressEvents: !0
}, Pg = {}, xr = [], jp = {}, EM, pi = {}, Df = {}, Xv = 30, _u = [], Lg = "", Ig = function(e) {
  var t = e[0], n, s;
  if (xs(t) || Gt(t) || (e = [e]), !(n = (t._gsap || {}).harness)) {
    for (s = _u.length; s-- && !_u[s].targetTest(t); )
      ;
    n = _u[s];
  }
  for (s = e.length; s--; )
    e[s] && (e[s]._gsap || (e[s]._gsap = new $M(e[s], n))) || e.splice(s, 1);
  return e;
}, xa = function(e) {
  return e._gsap || Ig(Di(e))[0]._gsap;
}, AM = function(e, t, n) {
  return (n = e[t]) && Gt(n) ? e[t]() : Eg(n) && e.getAttribute && e.getAttribute(t) || n;
}, ni = function(e, t) {
  return (e = e.split(",")).forEach(t) || e;
}, jt = function(e) {
  return Math.round(e * 1e5) / 1e5 || 0;
}, an = function(e) {
  return Math.round(e * 1e7) / 1e7 || 0;
}, Ro = function(e, t) {
  var n = t.charAt(0), s = parseFloat(t.substr(2));
  return e = parseFloat(e), n === "+" ? e + s : n === "-" ? e - s : n === "*" ? e * s : e / s;
}, mR = function(e, t) {
  for (var n = t.length, s = 0; e.indexOf(t[s]) < 0 && ++s < n; )
    ;
  return s < n;
}, Nu = function() {
  var e = xr.length, t = xr.slice(0), n, s;
  for (jp = {}, xr.length = 0, n = 0; n < e; n++)
    s = t[n], s && s._lazy && (s.render(s._lazy[0], s._lazy[1], !0)._lazy = 0);
}, CM = function(e, t, n, s) {
  xr.length && !wn && Nu(), e.render(t, n, wn && t < 0 && (e._initted || e._startAt)), xr.length && !wn && Nu();
}, RM = function(e) {
  var t = parseFloat(e);
  return (t || t === 0) && (e + "").match(bM).length < 2 ? t : gn(e) ? e.trim() : e;
}, PM = function(e) {
  return e;
}, wi = function(e, t) {
  for (var n in t)
    n in e || (e[n] = t[n]);
  return e;
}, gR = function(e) {
  return function(t, n) {
    for (var s in n)
      s in t || s === "duration" && e || s === "ease" || (t[s] = n[s]);
  };
}, Yo = function(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}, qv = function i(e, t) {
  for (var n in t)
    n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = xs(t[n]) ? i(e[n] || (e[n] = {}), t[n]) : t[n]);
  return e;
}, Uu = function(e, t) {
  var n = {}, s;
  for (s in e)
    s in t || (n[s] = e[s]);
  return n;
}, Vl = function(e) {
  var t = e.parent || Ot, n = e.keyframes ? gR(Dn(e.keyframes)) : wi;
  if (ti(e.inherit))
    for (; t; )
      n(e, t.vars.defaults), t = t.parent || t._dp;
  return e;
}, vR = function(e, t) {
  for (var n = e.length, s = n === t.length; s && n-- && e[n] === t[n]; )
    ;
  return n < 0;
}, LM = function(e, t, n, s, r) {
  var a = e[s], o;
  if (r)
    for (o = t[r]; a && a[r] > o; )
      a = a._prev;
  return a ? (t._next = a._next, a._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[s] = t, t._prev = a, t.parent = t._dp = e, t;
}, Bd = function(e, t, n, s) {
  n === void 0 && (n = "_first"), s === void 0 && (s = "_last");
  var r = t._prev, a = t._next;
  r ? r._next = a : e[n] === t && (e[n] = a), a ? a._prev = r : e[s] === t && (e[s] = r), t._next = t._prev = t.parent = null;
}, Lr = function(e, t) {
  e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0;
}, Ma = function(e, t) {
  if (e && (!t || t._end > e._dur || t._start < 0))
    for (var n = e; n; )
      n._dirty = 1, n = n.parent;
  return e;
}, _R = function(e) {
  for (var t = e.parent; t && t.parent; )
    t._dirty = 1, t.totalDuration(), t = t.parent;
  return e;
}, Zp = function(e, t, n, s) {
  return e._startAt && (wn ? e._startAt.revert(vu) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, s));
}, yR = function i(e) {
  return !e || e._ts && i(e.parent);
}, Yv = function(e) {
  return e._repeat ? jo(e._tTime, e = e.duration() + e._rDelay) * e : 0;
}, jo = function(e, t) {
  var n = Math.floor(e = an(e / t));
  return e && n === e ? n - 1 : n;
}, Fu = function(e, t) {
  return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur);
}, kd = function(e) {
  return e._end = an(e._start + (e._tDur / Math.abs(e._ts || e._rts || In) || 0));
}, zd = function(e, t) {
  var n = e._dp;
  return n && n.smoothChildTiming && e._ts && (e._start = an(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), kd(e), n._dirty || Ma(n, e)), e;
}, IM = function(e, t) {
  var n;
  if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = Fu(e.rawTime(), t), (!t._dur || Yc(0, t.totalDuration(), n) - t._tTime > In) && t.render(n, !0)), Ma(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
    if (e._dur < e.duration())
      for (n = e; n._dp; )
        n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
    e._zTime = -1e-8;
  }
}, ls = function(e, t, n, s) {
  return t.parent && Lr(t), t._start = an((Xs(n) ? n : n || e !== Ot ? Ci(e, n, t) : e._time) + t._delay), t._end = an(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), LM(e, t, "_first", "_last", e._sort ? "_start" : 0), $p(t) || (e._recent = t), s || IM(e, t), e._ts < 0 && zd(e, e._tTime), e;
}, DM = function(e, t) {
  return (Si.ScrollTrigger || Rg("scrollTrigger", t)) && Si.ScrollTrigger.create(t, e);
}, OM = function(e, t, n, s, r) {
  if (Og(e, t, r), !e._initted)
    return 1;
  if (!n && e._pt && !wn && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && EM !== _i.frame)
    return xr.push(e), e._lazy = [r, s], 1;
}, xR = function i(e) {
  var t = e.parent;
  return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || i(t));
}, $p = function(e) {
  var t = e.data;
  return t === "isFromStart" || t === "isStart";
}, MR = function(e, t, n, s) {
  var r = e.ratio, a = t < 0 || !t && (!e._start && xR(e) && !(!e._initted && $p(e)) || (e._ts < 0 || e._dp._ts < 0) && !$p(e)) ? 0 : 1, o = e._rDelay, l = 0, c, h, u;
  if (o && e._repeat && (l = Yc(0, e._tDur, t), h = jo(l, o), e._yoyo && h & 1 && (a = 1 - a), h !== jo(e._tTime, o) && (r = 1 - a, e.vars.repeatRefresh && e._initted && e.invalidate())), a !== r || wn || s || e._zTime === In || !t && e._zTime) {
    if (!e._initted && OM(e, t, s, n, l))
      return;
    for (u = e._zTime, e._zTime = t || (n ? In : 0), n || (n = t && !u), e.ratio = a, e._from && (a = 1 - a), e._time = 0, e._tTime = l, c = e._pt; c; )
      c.r(a, c.d), c = c._next;
    t < 0 && Zp(e, t, n, !0), e._onUpdate && !n && yi(e, "onUpdate"), l && e._repeat && !n && e.parent && yi(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === a && (a && Lr(e, 1), !n && !wn && (yi(e, a ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()));
  } else e._zTime || (e._zTime = t);
}, bR = function(e, t, n) {
  var s;
  if (n > t)
    for (s = e._first; s && s._start <= n; ) {
      if (s.data === "isPause" && s._start > t)
        return s;
      s = s._next;
    }
  else
    for (s = e._last; s && s._start >= n; ) {
      if (s.data === "isPause" && s._start < t)
        return s;
      s = s._prev;
    }
}, Zo = function(e, t, n, s) {
  var r = e._repeat, a = an(t) || 0, o = e._tTime / e._tDur;
  return o && !s && (e._time *= a / e._dur), e._dur = a, e._tDur = r ? r < 0 ? 1e10 : an(a * (r + 1) + e._rDelay * r) : a, o > 0 && !s && zd(e, e._tTime = e._tDur * o), e.parent && kd(e), n || Ma(e.parent, e), e;
}, jv = function(e) {
  return e instanceof Hn ? Ma(e) : Zo(e, e._dur);
}, SR = {
  _start: 0,
  endTime: vc,
  totalDuration: vc
}, Ci = function i(e, t, n) {
  var s = e.labels, r = e._recent || SR, a = e.duration() >= gs ? r.endTime(!1) : e._dur, o, l, c;
  return gn(t) && (isNaN(t) || t in s) ? (l = t.charAt(0), c = t.substr(-1) === "%", o = t.indexOf("="), l === "<" || l === ">" ? (o >= 0 && (t = t.replace(/=/, "")), (l === "<" ? r._start : r.endTime(r._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (o < 0 ? r : n).totalDuration() / 100 : 1)) : o < 0 ? (t in s || (s[t] = a), s[t]) : (l = parseFloat(t.charAt(o - 1) + t.substr(o + 1)), c && n && (l = l / 100 * (Dn(n) ? n[0] : n).totalDuration()), o > 1 ? i(e, t.substr(0, o - 1), n) + l : a + l)) : t == null ? a : +t;
}, Wl = function(e, t, n) {
  var s = Xs(t[1]), r = (s ? 2 : 1) + (e < 2 ? 0 : 1), a = t[r], o, l;
  if (s && (a.duration = t[1]), a.parent = n, e) {
    for (o = a, l = n; l && !("immediateRender" in o); )
      o = l.vars.defaults || {}, l = ti(l.vars.inherit) && l.parent;
    a.immediateRender = ti(o.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[r - 1];
  }
  return new rn(t[0], a, t[r + 1]);
}, kr = function(e, t) {
  return e || e === 0 ? t(e) : t;
}, Yc = function(e, t, n) {
  return n < e ? e : n > t ? t : n;
}, Ln = function(e, t) {
  return !gn(e) || !(t = dR.exec(e)) ? "" : t[1];
}, wR = function(e, t, n) {
  return kr(n, function(s) {
    return Yc(e, t, s);
  });
}, Kp = [].slice, NM = function(e, t) {
  return e && xs(e) && "length" in e && (!t && !e.length || e.length - 1 in e && xs(e[0])) && !e.nodeType && e !== rs;
}, TR = function(e, t, n) {
  return n === void 0 && (n = []), e.forEach(function(s) {
    var r;
    return gn(s) && !t || NM(s, 1) ? (r = n).push.apply(r, Di(s)) : n.push(s);
  }) || n;
}, Di = function(e, t, n) {
  return Lt && !t && Lt.selector ? Lt.selector(e) : gn(e) && !n && (Yp || !$o()) ? Kp.call((t || Cg).querySelectorAll(e), 0) : Dn(e) ? TR(e, n) : NM(e) ? Kp.call(e, 0) : e ? [e] : [];
}, Qp = function(e) {
  return e = Di(e)[0] || gc("Invalid scope") || {}, function(t) {
    var n = e.current || e.nativeElement || e;
    return Di(t, n.querySelectorAll ? n : n === e ? gc("Invalid scope") || Cg.createElement("div") : e);
  };
}, UM = function(e) {
  return e.sort(function() {
    return 0.5 - Math.random();
  });
}, FM = function(e) {
  if (Gt(e))
    return e;
  var t = xs(e) ? e : {
    each: e
  }, n = ba(t.ease), s = t.from || 0, r = parseFloat(t.base) || 0, a = {}, o = s > 0 && s < 1, l = isNaN(s) || o, c = t.axis, h = s, u = s;
  return gn(s) ? h = u = {
    center: 0.5,
    edges: 0.5,
    end: 1
  }[s] || 0 : !o && l && (h = s[0], u = s[1]), function(d, f, m) {
    var g = (m || t).length, p = a[g], v, y, _, x, M, S, w, E, b;
    if (!p) {
      if (b = t.grid === "auto" ? 0 : (t.grid || [1, gs])[1], !b) {
        for (w = -1e8; w < (w = m[b++].getBoundingClientRect().left) && b < g; )
          ;
        b < g && b--;
      }
      for (p = a[g] = [], v = l ? Math.min(b, g) * h - 0.5 : s % b, y = b === gs ? 0 : l ? g * u / b - 0.5 : s / b | 0, w = 0, E = gs, S = 0; S < g; S++)
        _ = S % b - v, x = y - (S / b | 0), p[S] = M = c ? Math.abs(c === "y" ? x : _) : _M(_ * _ + x * x), M > w && (w = M), M < E && (E = M);
      s === "random" && UM(p), p.max = w - E, p.min = E, p.v = g = (parseFloat(t.amount) || parseFloat(t.each) * (b > g ? g - 1 : c ? c === "y" ? g / b : b : Math.max(b, g / b)) || 0) * (s === "edges" ? -1 : 1), p.b = g < 0 ? r - g : r, p.u = Ln(t.amount || t.each) || 0, n = n && g < 0 ? YM(n) : n;
    }
    return g = (p[d] - p.min) / p.max || 0, an(p.b + (n ? n(g) : g) * p.v) + p.u;
  };
}, Jp = function(e) {
  var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
  return function(n) {
    var s = an(Math.round(parseFloat(n) / e) * e * t);
    return (s - s % 1) / t + (Xs(n) ? 0 : Ln(n));
  };
}, BM = function(e, t) {
  var n = Dn(e), s, r;
  return !n && xs(e) && (s = n = e.radius || gs, e.values ? (e = Di(e.values), (r = !Xs(e[0])) && (s *= s)) : e = Jp(e.increment)), kr(t, n ? Gt(e) ? function(a) {
    return r = e(a), Math.abs(r - a) <= s ? r : a;
  } : function(a) {
    for (var o = parseFloat(r ? a.x : a), l = parseFloat(r ? a.y : 0), c = gs, h = 0, u = e.length, d, f; u--; )
      r ? (d = e[u].x - o, f = e[u].y - l, d = d * d + f * f) : d = Math.abs(e[u] - o), d < c && (c = d, h = u);
    return h = !s || c <= s ? e[h] : a, r || h === a || Xs(a) ? h : h + Ln(a);
  } : Jp(e));
}, kM = function(e, t, n, s) {
  return kr(Dn(e) ? !t : n === !0 ? !!(n = 0) : !s, function() {
    return Dn(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (s = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * 0.99)) / n) * n * s) / s;
  });
}, ER = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function(s) {
    return t.reduce(function(r, a) {
      return a(r);
    }, s);
  };
}, AR = function(e, t) {
  return function(n) {
    return e(parseFloat(n)) + (t || Ln(n));
  };
}, CR = function(e, t, n) {
  return HM(e, t, 0, 1, n);
}, zM = function(e, t, n) {
  return kr(n, function(s) {
    return e[~~t(s)];
  });
}, RR = function i(e, t, n) {
  var s = t - e;
  return Dn(e) ? zM(e, i(0, e.length), t) : kr(n, function(r) {
    return (s + (r - e) % s) % s + e;
  });
}, PR = function i(e, t, n) {
  var s = t - e, r = s * 2;
  return Dn(e) ? zM(e, i(0, e.length - 1), t) : kr(n, function(a) {
    return a = (r + (a - e) % r) % r || 0, e + (a > s ? r - a : a);
  });
}, _c = function(e) {
  for (var t = 0, n = "", s, r, a, o; ~(s = e.indexOf("random(", t)); )
    a = e.indexOf(")", s), o = e.charAt(s + 7) === "[", r = e.substr(s + 7, a - s - 7).match(o ? bM : qp), n += e.substr(t, s - t) + kM(o ? r : +r[0], o ? 0 : +r[1], +r[2] || 1e-5), t = a + 1;
  return n + e.substr(t, e.length - t);
}, HM = function(e, t, n, s, r) {
  var a = t - e, o = s - n;
  return kr(r, function(l) {
    return n + ((l - e) / a * o || 0);
  });
}, LR = function i(e, t, n, s) {
  var r = isNaN(e + t) ? 0 : function(f) {
    return (1 - f) * e + f * t;
  };
  if (!r) {
    var a = gn(e), o = {}, l, c, h, u, d;
    if (n === !0 && (s = 1) && (n = null), a)
      e = {
        p: e
      }, t = {
        p: t
      };
    else if (Dn(e) && !Dn(t)) {
      for (h = [], u = e.length, d = u - 2, c = 1; c < u; c++)
        h.push(i(e[c - 1], e[c]));
      u--, r = function(m) {
        m *= u;
        var g = Math.min(d, ~~m);
        return h[g](m - g);
      }, n = t;
    } else s || (e = Yo(Dn(e) ? [] : {}, e));
    if (!h) {
      for (l in t)
        Dg.call(o, e, l, "get", t[l]);
      r = function(m) {
        return Fg(m, o) || (a ? e.p : e);
      };
    }
  }
  return kr(n, r);
}, Zv = function(e, t, n) {
  var s = e.labels, r = gs, a, o, l;
  for (a in s)
    o = s[a] - t, o < 0 == !!n && o && r > (o = Math.abs(o)) && (l = a, r = o);
  return l;
}, yi = function(e, t, n) {
  var s = e.vars, r = s[t], a = Lt, o = e._ctx, l, c, h;
  if (r)
    return l = s[t + "Params"], c = s.callbackScope || e, n && xr.length && Nu(), o && (Lt = o), h = l ? r.apply(c, l) : r.call(c), Lt = a, h;
}, Ll = function(e) {
  return Lr(e), e.scrollTrigger && e.scrollTrigger.kill(!!wn), e.progress() < 1 && yi(e, "onInterrupt"), e;
}, xo, GM = [], VM = function(e) {
  if (e)
    if (e = !e.name && e.default || e, Ag() || e.headless) {
      var t = e.name, n = Gt(e), s = t && !n && e.init ? function() {
        this._props = [];
      } : e, r = {
        init: vc,
        render: Fg,
        add: Dg,
        kill: YR,
        modifier: qR,
        rawVars: 0
      }, a = {
        targetTest: 0,
        get: 0,
        getSetter: Ug,
        aliases: {},
        register: 0
      };
      if ($o(), e !== s) {
        if (pi[t])
          return;
        wi(s, wi(Uu(e, r), a)), Yo(s.prototype, Yo(r, Uu(e, a))), pi[s.prop = t] = s, e.targetTest && (_u.push(s), Pg[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin";
      }
      TM(t, s), e.register && e.register(ri, s, ii);
    } else
      GM.push(e);
}, St = 255, Il = {
  aqua: [0, St, St],
  lime: [0, St, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, St],
  navy: [0, 0, 128],
  white: [St, St, St],
  olive: [128, 128, 0],
  yellow: [St, St, 0],
  orange: [St, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [St, 0, 0],
  pink: [St, 192, 203],
  cyan: [0, St, St],
  transparent: [St, St, St, 0]
}, Of = function(e, t, n) {
  return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (n - t) * e * 6 : e < 0.5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * St + 0.5 | 0;
}, WM = function(e, t, n) {
  var s = e ? Xs(e) ? [e >> 16, e >> 8 & St, e & St] : 0 : Il.black, r, a, o, l, c, h, u, d, f, m;
  if (!s) {
    if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Il[e])
      s = Il[e];
    else if (e.charAt(0) === "#") {
      if (e.length < 6 && (r = e.charAt(1), a = e.charAt(2), o = e.charAt(3), e = "#" + r + r + a + a + o + o + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9)
        return s = parseInt(e.substr(1, 6), 16), [s >> 16, s >> 8 & St, s & St, parseInt(e.substr(7), 16) / 255];
      e = parseInt(e.substr(1), 16), s = [e >> 16, e >> 8 & St, e & St];
    } else if (e.substr(0, 3) === "hsl") {
      if (s = m = e.match(qp), !t)
        l = +s[0] % 360 / 360, c = +s[1] / 100, h = +s[2] / 100, a = h <= 0.5 ? h * (c + 1) : h + c - h * c, r = h * 2 - a, s.length > 3 && (s[3] *= 1), s[0] = Of(l + 1 / 3, r, a), s[1] = Of(l, r, a), s[2] = Of(l - 1 / 3, r, a);
      else if (~e.indexOf("="))
        return s = e.match(xM), n && s.length < 4 && (s[3] = 1), s;
    } else
      s = e.match(qp) || Il.transparent;
    s = s.map(Number);
  }
  return t && !m && (r = s[0] / St, a = s[1] / St, o = s[2] / St, u = Math.max(r, a, o), d = Math.min(r, a, o), h = (u + d) / 2, u === d ? l = c = 0 : (f = u - d, c = h > 0.5 ? f / (2 - u - d) : f / (u + d), l = u === r ? (a - o) / f + (a < o ? 6 : 0) : u === a ? (o - r) / f + 2 : (r - a) / f + 4, l *= 60), s[0] = ~~(l + 0.5), s[1] = ~~(c * 100 + 0.5), s[2] = ~~(h * 100 + 0.5)), n && s.length < 4 && (s[3] = 1), s;
}, XM = function(e) {
  var t = [], n = [], s = -1;
  return e.split(Mr).forEach(function(r) {
    var a = r.match(yo) || [];
    t.push.apply(t, a), n.push(s += a.length + 1);
  }), t.c = n, t;
}, $v = function(e, t, n) {
  var s = "", r = (e + s).match(Mr), a = t ? "hsla(" : "rgba(", o = 0, l, c, h, u;
  if (!r)
    return e;
  if (r = r.map(function(d) {
    return (d = WM(d, t, 1)) && a + (t ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) + ")";
  }), n && (h = XM(e), l = n.c, l.join(s) !== h.c.join(s)))
    for (c = e.replace(Mr, "1").split(yo), u = c.length - 1; o < u; o++)
      s += c[o] + (~l.indexOf(o) ? r.shift() || a + "0,0,0,0)" : (h.length ? h : r.length ? r : n).shift());
  if (!c)
    for (c = e.split(Mr), u = c.length - 1; o < u; o++)
      s += c[o] + r[o];
  return s + c[u];
}, Mr = function() {
  var i = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
  for (e in Il)
    i += "|" + e + "\\b";
  return new RegExp(i + ")", "gi");
}(), IR = /hsl[a]?\(/, qM = function(e) {
  var t = e.join(" "), n;
  if (Mr.lastIndex = 0, Mr.test(t))
    return n = IR.test(t), e[1] = $v(e[1], n), e[0] = $v(e[0], n, XM(e[1])), !0;
}, yc, _i = function() {
  var i = Date.now, e = 500, t = 33, n = i(), s = n, r = 1e3 / 240, a = r, o = [], l, c, h, u, d, f, m = function g(p) {
    var v = i() - s, y = p === !0, _, x, M, S;
    if ((v > e || v < 0) && (n += v - t), s += v, M = s - n, _ = M - a, (_ > 0 || y) && (S = ++u.frame, d = M - u.time * 1e3, u.time = M = M / 1e3, a += _ + (_ >= r ? 4 : r - _), x = 1), y || (l = c(g)), x)
      for (f = 0; f < o.length; f++)
        o[f](M, d, S, p);
  };
  return u = {
    time: 0,
    frame: 0,
    tick: function() {
      m(!0);
    },
    deltaRatio: function(p) {
      return d / (1e3 / (p || 60));
    },
    wake: function() {
      SM && (!Yp && Ag() && (rs = Yp = window, Cg = rs.document || {}, Si.gsap = ri, (rs.gsapVersions || (rs.gsapVersions = [])).push(ri.version), wM(Ou || rs.GreenSockGlobals || !rs.gsap && rs || {}), GM.forEach(VM)), h = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && u.sleep(), c = h || function(p) {
        return setTimeout(p, a - u.time * 1e3 + 1 | 0);
      }, yc = 1, m(2));
    },
    sleep: function() {
      (h ? cancelAnimationFrame : clearTimeout)(l), yc = 0, c = vc;
    },
    lagSmoothing: function(p, v) {
      e = p || 1 / 0, t = Math.min(v || 33, e);
    },
    fps: function(p) {
      r = 1e3 / (p || 240), a = u.time * 1e3 + r;
    },
    add: function(p, v, y) {
      var _ = v ? function(x, M, S, w) {
        p(x, M, S, w), u.remove(_);
      } : p;
      return u.remove(p), o[y ? "unshift" : "push"](_), $o(), _;
    },
    remove: function(p, v) {
      ~(v = o.indexOf(p)) && o.splice(v, 1) && f >= v && f--;
    },
    _listeners: o
  }, u;
}(), $o = function() {
  return !yc && _i.wake();
}, ut = {}, DR = /^[\d.\-M][\d.\-,\s]/, OR = /["']/g, NR = function(e) {
  for (var t = {}, n = e.substr(1, e.length - 3).split(":"), s = n[0], r = 1, a = n.length, o, l, c; r < a; r++)
    l = n[r], o = r !== a - 1 ? l.lastIndexOf(",") : l.length, c = l.substr(0, o), t[s] = isNaN(c) ? c.replace(OR, "").trim() : +c, s = l.substr(o + 1).trim();
  return t;
}, UR = function(e) {
  var t = e.indexOf("(") + 1, n = e.indexOf(")"), s = e.indexOf("(", t);
  return e.substring(t, ~s && s < n ? e.indexOf(")", n + 1) : n);
}, FR = function(e) {
  var t = (e + "").split("("), n = ut[t[0]];
  return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [NR(t[1])] : UR(e).split(",").map(RM)) : ut._CE && DR.test(e) ? ut._CE("", e) : n;
}, YM = function(e) {
  return function(t) {
    return 1 - e(1 - t);
  };
}, jM = function i(e, t) {
  for (var n = e._first, s; n; )
    n instanceof Hn ? i(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? i(n.timeline, t) : (s = n._ease, n._ease = n._yEase, n._yEase = s, n._yoyo = t)), n = n._next;
}, ba = function(e, t) {
  return e && (Gt(e) ? e : ut[e] || FR(e)) || t;
}, za = function(e, t, n, s) {
  n === void 0 && (n = function(l) {
    return 1 - t(1 - l);
  }), s === void 0 && (s = function(l) {
    return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
  });
  var r = {
    easeIn: t,
    easeOut: n,
    easeInOut: s
  }, a;
  return ni(e, function(o) {
    ut[o] = Si[o] = r, ut[a = o.toLowerCase()] = n;
    for (var l in r)
      ut[a + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = ut[o + "." + l] = r[l];
  }), r;
}, ZM = function(e) {
  return function(t) {
    return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
  };
}, Nf = function i(e, t, n) {
  var s = t >= 1 ? t : 1, r = (n || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1), a = r / Xp * (Math.asin(1 / s) || 0), o = function(h) {
    return h === 1 ? 1 : s * Math.pow(2, -10 * h) * uR((h - a) * r) + 1;
  }, l = e === "out" ? o : e === "in" ? function(c) {
    return 1 - o(1 - c);
  } : ZM(o);
  return r = Xp / r, l.config = function(c, h) {
    return i(e, c, h);
  }, l;
}, Uf = function i(e, t) {
  t === void 0 && (t = 1.70158);
  var n = function(a) {
    return a ? --a * a * ((t + 1) * a + t) + 1 : 0;
  }, s = e === "out" ? n : e === "in" ? function(r) {
    return 1 - n(1 - r);
  } : ZM(n);
  return s.config = function(r) {
    return i(e, r);
  }, s;
};
ni("Linear,Quad,Cubic,Quart,Quint,Strong", function(i, e) {
  var t = e < 5 ? e + 1 : e;
  za(i + ",Power" + (t - 1), e ? function(n) {
    return Math.pow(n, t);
  } : function(n) {
    return n;
  }, function(n) {
    return 1 - Math.pow(1 - n, t);
  }, function(n) {
    return n < 0.5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2;
  });
});
ut.Linear.easeNone = ut.none = ut.Linear.easeIn;
za("Elastic", Nf("in"), Nf("out"), Nf());
(function(i, e) {
  var t = 1 / e, n = 2 * t, s = 2.5 * t, r = function(o) {
    return o < t ? i * o * o : o < n ? i * Math.pow(o - 1.5 / e, 2) + 0.75 : o < s ? i * (o -= 2.25 / e) * o + 0.9375 : i * Math.pow(o - 2.625 / e, 2) + 0.984375;
  };
  za("Bounce", function(a) {
    return 1 - r(1 - a);
  }, r);
})(7.5625, 2.75);
za("Expo", function(i) {
  return Math.pow(2, 10 * (i - 1)) * i + i * i * i * i * i * i * (1 - i);
});
za("Circ", function(i) {
  return -(_M(1 - i * i) - 1);
});
za("Sine", function(i) {
  return i === 1 ? 1 : -hR(i * lR) + 1;
});
za("Back", Uf("in"), Uf("out"), Uf());
ut.SteppedEase = ut.steps = Si.SteppedEase = {
  config: function(e, t) {
    e === void 0 && (e = 1);
    var n = 1 / e, s = e + (t ? 0 : 1), r = t ? 1 : 0, a = 1 - In;
    return function(o) {
      return ((s * Yc(0, a, o) | 0) + r) * n;
    };
  }
};
qo.ease = ut["quad.out"];
ni("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(i) {
  return Lg += i + "," + i + "Params,";
});
var $M = function(e, t) {
  this.id = cR++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : AM, this.set = t ? t.getSetter : Ug;
}, xc = /* @__PURE__ */ function() {
  function i(t) {
    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Zo(this, +t.duration, 1, 1), this.data = t.data, Lt && (this._ctx = Lt, Lt.data.push(this)), yc || _i.wake();
  }
  var e = i.prototype;
  return e.delay = function(n) {
    return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay;
  }, e.duration = function(n) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur;
  }, e.totalDuration = function(n) {
    return arguments.length ? (this._dirty = 0, Zo(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, e.totalTime = function(n, s) {
    if ($o(), !arguments.length)
      return this._tTime;
    var r = this._dp;
    if (r && r.smoothChildTiming && this._ts) {
      for (zd(this, n), !r._dp || r.parent || IM(r, this); r && r.parent; )
        r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && ls(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== n || !this._dur && !s || this._initted && Math.abs(this._zTime) === In || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), CM(this, n, s)), this;
  }, e.time = function(n, s) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + Yv(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), s) : this._time;
  }, e.totalProgress = function(n, s) {
    return arguments.length ? this.totalTime(this.totalDuration() * n, s) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
  }, e.progress = function(n, s) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + Yv(this), s) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, e.iteration = function(n, s) {
    var r = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (n - 1) * r, s) : this._repeat ? jo(this._tTime, r) + 1 : 1;
  }, e.timeScale = function(n, s) {
    if (!arguments.length)
      return this._rts === -1e-8 ? 0 : this._rts;
    if (this._rts === n)
      return this;
    var r = this.parent && this._ts ? Fu(this.parent._time, this) : this._tTime;
    return this._rts = +n || 0, this._ts = this._ps || n === -1e-8 ? 0 : this._rts, this.totalTime(Yc(-Math.abs(this._delay), this._tDur, r), s !== !1), kd(this), _R(this);
  }, e.paused = function(n) {
    return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : ($o(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== In && (this._tTime -= In)))), this) : this._ps;
  }, e.startTime = function(n) {
    if (arguments.length) {
      this._start = n;
      var s = this.parent || this._dp;
      return s && (s._sort || !this.parent) && ls(s, this, n - this._delay), this;
    }
    return this._start;
  }, e.endTime = function(n) {
    return this._start + (ti(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, e.rawTime = function(n) {
    var s = this.parent || this._dp;
    return s ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Fu(s.rawTime(n), this) : this._tTime : this._tTime;
  }, e.revert = function(n) {
    n === void 0 && (n = pR);
    var s = wn;
    return wn = n, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(n), this.totalTime(-0.01, n.suppressEvents)), this.data !== "nested" && n.kill !== !1 && this.kill(), wn = s, this;
  }, e.globalTime = function(n) {
    for (var s = this, r = arguments.length ? n : s.rawTime(); s; )
      r = s._start + r / (Math.abs(s._ts) || 1), s = s._dp;
    return !this.parent && this._sat ? this._sat.globalTime(n) : r;
  }, e.repeat = function(n) {
    return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, jv(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, e.repeatDelay = function(n) {
    if (arguments.length) {
      var s = this._time;
      return this._rDelay = n, jv(this), s ? this.time(s) : this;
    }
    return this._rDelay;
  }, e.yoyo = function(n) {
    return arguments.length ? (this._yoyo = n, this) : this._yoyo;
  }, e.seek = function(n, s) {
    return this.totalTime(Ci(this, n), ti(s));
  }, e.restart = function(n, s) {
    return this.play().totalTime(n ? -this._delay : 0, ti(s)), this._dur || (this._zTime = -1e-8), this;
  }, e.play = function(n, s) {
    return n != null && this.seek(n, s), this.reversed(!1).paused(!1);
  }, e.reverse = function(n, s) {
    return n != null && this.seek(n || this.totalDuration(), s), this.reversed(!0).paused(!1);
  }, e.pause = function(n, s) {
    return n != null && this.seek(n, s), this.paused(!0);
  }, e.resume = function() {
    return this.paused(!1);
  }, e.reversed = function(n) {
    return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -1e-8 : 0)), this) : this._rts < 0;
  }, e.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -1e-8, this;
  }, e.isActive = function() {
    var n = this.parent || this._dp, s = this._start, r;
    return !!(!n || this._ts && this._initted && n.isActive() && (r = n.rawTime(!0)) >= s && r < this.endTime(!0) - In);
  }, e.eventCallback = function(n, s, r) {
    var a = this.vars;
    return arguments.length > 1 ? (s ? (a[n] = s, r && (a[n + "Params"] = r), n === "onUpdate" && (this._onUpdate = s)) : delete a[n], this) : a[n];
  }, e.then = function(n) {
    var s = this;
    return new Promise(function(r) {
      var a = Gt(n) ? n : PM, o = function() {
        var c = s.then;
        s.then = null, Gt(a) && (a = a(s)) && (a.then || a === s) && (s.then = c), r(a), s.then = c;
      };
      s._initted && s.totalProgress() === 1 && s._ts >= 0 || !s._tTime && s._ts < 0 ? o() : s._prom = o;
    });
  }, e.kill = function() {
    Ll(this);
  }, i;
}();
wi(xc.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -1e-8,
  _prom: 0,
  _ps: !1,
  _rts: 1
});
var Hn = /* @__PURE__ */ function(i) {
  vM(e, i);
  function e(n, s) {
    var r;
    return n === void 0 && (n = {}), r = i.call(this, n) || this, r.labels = {}, r.smoothChildTiming = !!n.smoothChildTiming, r.autoRemoveChildren = !!n.autoRemoveChildren, r._sort = ti(n.sortChildren), Ot && ls(n.parent || Ot, Ds(r), s), n.reversed && r.reverse(), n.paused && r.paused(!0), n.scrollTrigger && DM(Ds(r), n.scrollTrigger), r;
  }
  var t = e.prototype;
  return t.to = function(s, r, a) {
    return Wl(0, arguments, this), this;
  }, t.from = function(s, r, a) {
    return Wl(1, arguments, this), this;
  }, t.fromTo = function(s, r, a, o) {
    return Wl(2, arguments, this), this;
  }, t.set = function(s, r, a) {
    return r.duration = 0, r.parent = this, Vl(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new rn(s, r, Ci(this, a), 1), this;
  }, t.call = function(s, r, a) {
    return ls(this, rn.delayedCall(0, s, r), a);
  }, t.staggerTo = function(s, r, a, o, l, c, h) {
    return a.duration = r, a.stagger = a.stagger || o, a.onComplete = c, a.onCompleteParams = h, a.parent = this, new rn(s, a, Ci(this, l)), this;
  }, t.staggerFrom = function(s, r, a, o, l, c, h) {
    return a.runBackwards = 1, Vl(a).immediateRender = ti(a.immediateRender), this.staggerTo(s, r, a, o, l, c, h);
  }, t.staggerFromTo = function(s, r, a, o, l, c, h, u) {
    return o.startAt = a, Vl(o).immediateRender = ti(o.immediateRender), this.staggerTo(s, r, o, l, c, h, u);
  }, t.render = function(s, r, a) {
    var o = this._time, l = this._dirty ? this.totalDuration() : this._tDur, c = this._dur, h = s <= 0 ? 0 : an(s), u = this._zTime < 0 != s < 0 && (this._initted || !c), d, f, m, g, p, v, y, _, x, M, S, w;
    if (this !== Ot && h > l && s >= 0 && (h = l), h !== this._tTime || a || u) {
      if (o !== this._time && c && (h += this._time - o, s += this._time - o), d = h, x = this._start, _ = this._ts, v = !_, u && (c || (o = this._zTime), (s || !r) && (this._zTime = s)), this._repeat) {
        if (S = this._yoyo, p = c + this._rDelay, this._repeat < -1 && s < 0)
          return this.totalTime(p * 100 + s, r, a);
        if (d = an(h % p), h === l ? (g = this._repeat, d = c) : (M = an(h / p), g = ~~M, g && g === M && (d = c, g--), d > c && (d = c)), M = jo(this._tTime, p), !o && this._tTime && M !== g && this._tTime - M * p - this._dur <= 0 && (M = g), S && g & 1 && (d = c - d, w = 1), g !== M && !this._lock) {
          var E = S && M & 1, b = E === (S && g & 1);
          if (g < M && (E = !E), o = E ? 0 : h % c ? c : h, this._lock = 1, this.render(o || (w ? 0 : an(g * p)), r, !c)._lock = 0, this._tTime = h, !r && this.parent && yi(this, "onRepeat"), this.vars.repeatRefresh && !w && (this.invalidate()._lock = 1), o && o !== this._time || v !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
            return this;
          if (c = this._dur, l = this._tDur, b && (this._lock = 2, o = E ? c : -1e-4, this.render(o, !0), this.vars.repeatRefresh && !w && this.invalidate()), this._lock = 0, !this._ts && !v)
            return this;
          jM(this, w);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (y = bR(this, an(o), an(d)), y && (h -= d - (d = y._start))), this._tTime = h, this._time = d, this._act = !_, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = s, o = 0), !o && d && !r && !g && (yi(this, "onStart"), this._tTime !== h))
        return this;
      if (d >= o && s >= 0)
        for (f = this._first; f; ) {
          if (m = f._next, (f._act || d >= f._start) && f._ts && y !== f) {
            if (f.parent !== this)
              return this.render(s, r, a);
            if (f.render(f._ts > 0 ? (d - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (d - f._start) * f._ts, r, a), d !== this._time || !this._ts && !v) {
              y = 0, m && (h += this._zTime = -1e-8);
              break;
            }
          }
          f = m;
        }
      else {
        f = this._last;
        for (var A = s < 0 ? s : d; f; ) {
          if (m = f._prev, (f._act || A <= f._end) && f._ts && y !== f) {
            if (f.parent !== this)
              return this.render(s, r, a);
            if (f.render(f._ts > 0 ? (A - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (A - f._start) * f._ts, r, a || wn && (f._initted || f._startAt)), d !== this._time || !this._ts && !v) {
              y = 0, m && (h += this._zTime = A ? -1e-8 : In);
              break;
            }
          }
          f = m;
        }
      }
      if (y && !r && (this.pause(), y.render(d >= o ? 0 : -1e-8)._zTime = d >= o ? 1 : -1, this._ts))
        return this._start = x, kd(this), this.render(s, r, a);
      this._onUpdate && !r && yi(this, "onUpdate", !0), (h === l && this._tTime >= this.totalDuration() || !h && o) && (x === this._start || Math.abs(_) !== Math.abs(this._ts)) && (this._lock || ((s || !c) && (h === l && this._ts > 0 || !h && this._ts < 0) && Lr(this, 1), !r && !(s < 0 && !o) && (h || o || !l) && (yi(this, h === l && s >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(h < l && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, t.add = function(s, r) {
    var a = this;
    if (Xs(r) || (r = Ci(this, r, s)), !(s instanceof xc)) {
      if (Dn(s))
        return s.forEach(function(o) {
          return a.add(o, r);
        }), this;
      if (gn(s))
        return this.addLabel(s, r);
      if (Gt(s))
        s = rn.delayedCall(0, s);
      else
        return this;
    }
    return this !== s ? ls(this, s, r) : this;
  }, t.getChildren = function(s, r, a, o) {
    s === void 0 && (s = !0), r === void 0 && (r = !0), a === void 0 && (a = !0), o === void 0 && (o = -1e8);
    for (var l = [], c = this._first; c; )
      c._start >= o && (c instanceof rn ? r && l.push(c) : (a && l.push(c), s && l.push.apply(l, c.getChildren(!0, r, a)))), c = c._next;
    return l;
  }, t.getById = function(s) {
    for (var r = this.getChildren(1, 1, 1), a = r.length; a--; )
      if (r[a].vars.id === s)
        return r[a];
  }, t.remove = function(s) {
    return gn(s) ? this.removeLabel(s) : Gt(s) ? this.killTweensOf(s) : (s.parent === this && Bd(this, s), s === this._recent && (this._recent = this._last), Ma(this));
  }, t.totalTime = function(s, r) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = an(_i.time - (this._ts > 0 ? s / this._ts : (this.totalDuration() - s) / -this._ts))), i.prototype.totalTime.call(this, s, r), this._forcing = 0, this) : this._tTime;
  }, t.addLabel = function(s, r) {
    return this.labels[s] = Ci(this, r), this;
  }, t.removeLabel = function(s) {
    return delete this.labels[s], this;
  }, t.addPause = function(s, r, a) {
    var o = rn.delayedCall(0, r || vc, a);
    return o.data = "isPause", this._hasPause = 1, ls(this, o, Ci(this, s));
  }, t.removePause = function(s) {
    var r = this._first;
    for (s = Ci(this, s); r; )
      r._start === s && r.data === "isPause" && Lr(r), r = r._next;
  }, t.killTweensOf = function(s, r, a) {
    for (var o = this.getTweensOf(s, a), l = o.length; l--; )
      ur !== o[l] && o[l].kill(s, r);
    return this;
  }, t.getTweensOf = function(s, r) {
    for (var a = [], o = Di(s), l = this._first, c = Xs(r), h; l; )
      l instanceof rn ? mR(l._targets, o) && (c ? (!ur || l._initted && l._ts) && l.globalTime(0) <= r && l.globalTime(l.totalDuration()) > r : !r || l.isActive()) && a.push(l) : (h = l.getTweensOf(o, r)).length && a.push.apply(a, h), l = l._next;
    return a;
  }, t.tweenTo = function(s, r) {
    r = r || {};
    var a = this, o = Ci(a, s), l = r, c = l.startAt, h = l.onStart, u = l.onStartParams, d = l.immediateRender, f, m = rn.to(a, wi({
      ease: r.ease || "none",
      lazy: !1,
      immediateRender: !1,
      time: o,
      overwrite: "auto",
      duration: r.duration || Math.abs((o - (c && "time" in c ? c.time : a._time)) / a.timeScale()) || In,
      onStart: function() {
        if (a.pause(), !f) {
          var p = r.duration || Math.abs((o - (c && "time" in c ? c.time : a._time)) / a.timeScale());
          m._dur !== p && Zo(m, p, 0, 1).render(m._time, !0, !0), f = 1;
        }
        h && h.apply(m, u || []);
      }
    }, r));
    return d ? m.render(0) : m;
  }, t.tweenFromTo = function(s, r, a) {
    return this.tweenTo(r, wi({
      startAt: {
        time: Ci(this, s)
      }
    }, a));
  }, t.recent = function() {
    return this._recent;
  }, t.nextLabel = function(s) {
    return s === void 0 && (s = this._time), Zv(this, Ci(this, s));
  }, t.previousLabel = function(s) {
    return s === void 0 && (s = this._time), Zv(this, Ci(this, s), 1);
  }, t.currentLabel = function(s) {
    return arguments.length ? this.seek(s, !0) : this.previousLabel(this._time + In);
  }, t.shiftChildren = function(s, r, a) {
    a === void 0 && (a = 0);
    for (var o = this._first, l = this.labels, c; o; )
      o._start >= a && (o._start += s, o._end += s), o = o._next;
    if (r)
      for (c in l)
        l[c] >= a && (l[c] += s);
    return Ma(this);
  }, t.invalidate = function(s) {
    var r = this._first;
    for (this._lock = 0; r; )
      r.invalidate(s), r = r._next;
    return i.prototype.invalidate.call(this, s);
  }, t.clear = function(s) {
    s === void 0 && (s = !0);
    for (var r = this._first, a; r; )
      a = r._next, this.remove(r), r = a;
    return this._dp && (this._time = this._tTime = this._pTime = 0), s && (this.labels = {}), Ma(this);
  }, t.totalDuration = function(s) {
    var r = 0, a = this, o = a._last, l = gs, c, h, u;
    if (arguments.length)
      return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -s : s));
    if (a._dirty) {
      for (u = a.parent; o; )
        c = o._prev, o._dirty && o.totalDuration(), h = o._start, h > l && a._sort && o._ts && !a._lock ? (a._lock = 1, ls(a, o, h - o._delay, 1)._lock = 0) : l = h, h < 0 && o._ts && (r -= h, (!u && !a._dp || u && u.smoothChildTiming) && (a._start += h / a._ts, a._time -= h, a._tTime -= h), a.shiftChildren(-h, !1, -1 / 0), l = 0), o._end > r && o._ts && (r = o._end), o = c;
      Zo(a, a === Ot && a._time > r ? a._time : r, 1, 1), a._dirty = 0;
    }
    return a._tDur;
  }, e.updateRoot = function(s) {
    if (Ot._ts && (CM(Ot, Fu(s, Ot)), EM = _i.frame), _i.frame >= Xv) {
      Xv += Mi.autoSleep || 120;
      var r = Ot._first;
      if ((!r || !r._ts) && Mi.autoSleep && _i._listeners.length < 2) {
        for (; r && !r._ts; )
          r = r._next;
        r || _i.sleep();
      }
    }
  }, e;
}(xc);
wi(Hn.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var BR = function(e, t, n, s, r, a, o) {
  var l = new ii(this._pt, e, t, 0, 1, nb, null, r), c = 0, h = 0, u, d, f, m, g, p, v, y;
  for (l.b = n, l.e = s, n += "", s += "", (v = ~s.indexOf("random(")) && (s = _c(s)), a && (y = [n, s], a(y, e, t), n = y[0], s = y[1]), d = n.match(If) || []; u = If.exec(s); )
    m = u[0], g = s.substring(c, u.index), f ? f = (f + 1) % 5 : g.substr(-5) === "rgba(" && (f = 1), m !== d[h++] && (p = parseFloat(d[h - 1]) || 0, l._pt = {
      _next: l._pt,
      p: g || h === 1 ? g : ",",
      //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
      s: p,
      c: m.charAt(1) === "=" ? Ro(p, m) - p : parseFloat(m) - p,
      m: f && f < 4 ? Math.round : 0
    }, c = If.lastIndex);
  return l.c = c < s.length ? s.substring(c, s.length) : "", l.fp = o, (MM.test(s) || v) && (l.e = 0), this._pt = l, l;
}, Dg = function(e, t, n, s, r, a, o, l, c, h) {
  Gt(s) && (s = s(r || 0, e, a));
  var u = e[t], d = n !== "get" ? n : Gt(u) ? c ? e[t.indexOf("set") || !Gt(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : u, f = Gt(u) ? c ? VR : eb : Ng, m;
  if (gn(s) && (~s.indexOf("random(") && (s = _c(s)), s.charAt(1) === "=" && (m = Ro(d, s) + (Ln(d) || 0), (m || m === 0) && (s = m))), !h || d !== s || em)
    return !isNaN(d * s) && s !== "" ? (m = new ii(this._pt, e, t, +d || 0, s - (d || 0), typeof u == "boolean" ? XR : tb, 0, f), c && (m.fp = c), o && m.modifier(o, this, e), this._pt = m) : (!u && !(t in e) && Rg(t, s), BR.call(this, e, t, d, s, f, l || Mi.stringFilter, c));
}, kR = function(e, t, n, s, r) {
  if (Gt(e) && (e = Xl(e, r, t, n, s)), !xs(e) || e.style && e.nodeType || Dn(e) || yM(e))
    return gn(e) ? Xl(e, r, t, n, s) : e;
  var a = {}, o;
  for (o in e)
    a[o] = Xl(e[o], r, t, n, s);
  return a;
}, KM = function(e, t, n, s, r, a) {
  var o, l, c, h;
  if (pi[e] && (o = new pi[e]()).init(r, o.rawVars ? t[e] : kR(t[e], s, r, a, n), n, s, a) !== !1 && (n._pt = l = new ii(n._pt, r, e, 0, 1, o.render, o, 0, o.priority), n !== xo))
    for (c = n._ptLookup[n._targets.indexOf(r)], h = o._props.length; h--; )
      c[o._props[h]] = l;
  return o;
}, ur, em, Og = function i(e, t, n) {
  var s = e.vars, r = s.ease, a = s.startAt, o = s.immediateRender, l = s.lazy, c = s.onUpdate, h = s.runBackwards, u = s.yoyoEase, d = s.keyframes, f = s.autoRevert, m = e._dur, g = e._startAt, p = e._targets, v = e.parent, y = v && v.data === "nested" ? v.vars.targets : p, _ = e._overwrite === "auto" && !Tg, x = e.timeline, M, S, w, E, b, A, D, B, X, L, F, H, G;
  if (x && (!d || !r) && (r = "none"), e._ease = ba(r, qo.ease), e._yEase = u ? YM(ba(u === !0 ? r : u, qo.ease)) : 0, u && e._yoyo && !e._repeat && (u = e._yEase, e._yEase = e._ease, e._ease = u), e._from = !x && !!s.runBackwards, !x || d && !s.stagger) {
    if (B = p[0] ? xa(p[0]).harness : 0, H = B && s[B.prop], M = Uu(s, Pg), g && (g._zTime < 0 && g.progress(1), t < 0 && h && o && !f ? g.render(-1, !0) : g.revert(h && m ? vu : fR), g._lazy = 0), a) {
      if (Lr(e._startAt = rn.set(p, wi({
        data: "isStart",
        overwrite: !1,
        parent: v,
        immediateRender: !0,
        lazy: !g && ti(l),
        startAt: null,
        delay: 0,
        onUpdate: c && function() {
          return yi(e, "onUpdate");
        },
        stagger: 0
      }, a))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (wn || !o && !f) && e._startAt.revert(vu), o && m && t <= 0 && n <= 0) {
        t && (e._zTime = t);
        return;
      }
    } else if (h && m && !g) {
      if (t && (o = !1), w = wi({
        overwrite: !1,
        data: "isFromStart",
        //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        lazy: o && !g && ti(l),
        immediateRender: o,
        //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
        stagger: 0,
        parent: v
        //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
      }, M), H && (w[B.prop] = H), Lr(e._startAt = rn.set(p, w)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (wn ? e._startAt.revert(vu) : e._startAt.render(-1, !0)), e._zTime = t, !o)
        i(e._startAt, In, In);
      else if (!t)
        return;
    }
    for (e._pt = e._ptCache = 0, l = m && ti(l) || l && !m, S = 0; S < p.length; S++) {
      if (b = p[S], D = b._gsap || Ig(p)[S]._gsap, e._ptLookup[S] = L = {}, jp[D.id] && xr.length && Nu(), F = y === p ? S : y.indexOf(b), B && (X = new B()).init(b, H || M, e, F, y) !== !1 && (e._pt = E = new ii(e._pt, b, X.name, 0, 1, X.render, X, 0, X.priority), X._props.forEach(function(te) {
        L[te] = E;
      }), X.priority && (A = 1)), !B || H)
        for (w in M)
          pi[w] && (X = KM(w, M, e, F, b, y)) ? X.priority && (A = 1) : L[w] = E = Dg.call(e, b, w, "get", M[w], F, y, 0, s.stringFilter);
      e._op && e._op[S] && e.kill(b, e._op[S]), _ && e._pt && (ur = e, Ot.killTweensOf(b, L, e.globalTime(t)), G = !e.parent, ur = 0), e._pt && l && (jp[D.id] = 1);
    }
    A && ib(e), e._onInit && e._onInit(e);
  }
  e._onUpdate = c, e._initted = (!e._op || e._pt) && !G, d && t <= 0 && x.render(gs, !0, !0);
}, zR = function(e, t, n, s, r, a, o, l) {
  var c = (e._pt && e._ptCache || (e._ptCache = {}))[t], h, u, d, f;
  if (!c)
    for (c = e._ptCache[t] = [], d = e._ptLookup, f = e._targets.length; f--; ) {
      if (h = d[f][t], h && h.d && h.d._pt)
        for (h = h.d._pt; h && h.p !== t && h.fp !== t; )
          h = h._next;
      if (!h)
        return em = 1, e.vars[t] = "+=0", Og(e, o), em = 0, l ? gc(t + " not eligible for reset") : 1;
      c.push(h);
    }
  for (f = c.length; f--; )
    u = c[f], h = u._pt || u, h.s = (s || s === 0) && !r ? s : h.s + (s || 0) + a * h.c, h.c = n - h.s, u.e && (u.e = jt(n) + Ln(u.e)), u.b && (u.b = h.s + Ln(u.b));
}, HR = function(e, t) {
  var n = e[0] ? xa(e[0]).harness : 0, s = n && n.aliases, r, a, o, l;
  if (!s)
    return t;
  r = Yo({}, t);
  for (a in s)
    if (a in r)
      for (l = s[a].split(","), o = l.length; o--; )
        r[l[o]] = r[a];
  return r;
}, GR = function(e, t, n, s) {
  var r = t.ease || s || "power1.inOut", a, o;
  if (Dn(t))
    o = n[e] || (n[e] = []), t.forEach(function(l, c) {
      return o.push({
        t: c / (t.length - 1) * 100,
        v: l,
        e: r
      });
    });
  else
    for (a in t)
      o = n[a] || (n[a] = []), a === "ease" || o.push({
        t: parseFloat(e),
        v: t[a],
        e: r
      });
}, Xl = function(e, t, n, s, r) {
  return Gt(e) ? e.call(t, n, s, r) : gn(e) && ~e.indexOf("random(") ? _c(e) : e;
}, QM = Lg + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", JM = {};
ni(QM + ",id,stagger,delay,duration,paused,scrollTrigger", function(i) {
  return JM[i] = 1;
});
var rn = /* @__PURE__ */ function(i) {
  vM(e, i);
  function e(n, s, r, a) {
    var o;
    typeof s == "number" && (r.duration = s, s = r, r = null), o = i.call(this, a ? s : Vl(s)) || this;
    var l = o.vars, c = l.duration, h = l.delay, u = l.immediateRender, d = l.stagger, f = l.overwrite, m = l.keyframes, g = l.defaults, p = l.scrollTrigger, v = l.yoyoEase, y = s.parent || Ot, _ = (Dn(n) || yM(n) ? Xs(n[0]) : "length" in s) ? [n] : Di(n), x, M, S, w, E, b, A, D;
    if (o._targets = _.length ? Ig(_) : gc("GSAP target " + n + " not found. https://gsap.com", !Mi.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = f, m || d || jh(c) || jh(h)) {
      if (s = o.vars, x = o.timeline = new Hn({
        data: "nested",
        defaults: g || {},
        targets: y && y.data === "nested" ? y.vars.targets : _
      }), x.kill(), x.parent = x._dp = Ds(o), x._start = 0, d || jh(c) || jh(h)) {
        if (w = _.length, A = d && FM(d), xs(d))
          for (E in d)
            ~QM.indexOf(E) && (D || (D = {}), D[E] = d[E]);
        for (M = 0; M < w; M++)
          S = Uu(s, JM), S.stagger = 0, v && (S.yoyoEase = v), D && Yo(S, D), b = _[M], S.duration = +Xl(c, Ds(o), M, b, _), S.delay = (+Xl(h, Ds(o), M, b, _) || 0) - o._delay, !d && w === 1 && S.delay && (o._delay = h = S.delay, o._start += h, S.delay = 0), x.to(b, S, A ? A(M, b, _) : 0), x._ease = ut.none;
        x.duration() ? c = h = 0 : o.timeline = 0;
      } else if (m) {
        Vl(wi(x.vars.defaults, {
          ease: "none"
        })), x._ease = ba(m.ease || s.ease || "none");
        var B = 0, X, L, F;
        if (Dn(m))
          m.forEach(function(H) {
            return x.to(_, H, ">");
          }), x.duration();
        else {
          S = {};
          for (E in m)
            E === "ease" || E === "easeEach" || GR(E, m[E], S, m.easeEach);
          for (E in S)
            for (X = S[E].sort(function(H, G) {
              return H.t - G.t;
            }), B = 0, M = 0; M < X.length; M++)
              L = X[M], F = {
                ease: L.e,
                duration: (L.t - (M ? X[M - 1].t : 0)) / 100 * c
              }, F[E] = L.v, x.to(_, F, B), B += F.duration;
          x.duration() < c && x.to({}, {
            duration: c - x.duration()
          });
        }
      }
      c || o.duration(c = x.duration());
    } else
      o.timeline = 0;
    return f === !0 && !Tg && (ur = Ds(o), Ot.killTweensOf(_), ur = 0), ls(y, Ds(o), r), s.reversed && o.reverse(), s.paused && o.paused(!0), (u || !c && !m && o._start === an(y._time) && ti(u) && yR(Ds(o)) && y.data !== "nested") && (o._tTime = -1e-8, o.render(Math.max(0, -h) || 0)), p && DM(Ds(o), p), o;
  }
  var t = e.prototype;
  return t.render = function(s, r, a) {
    var o = this._time, l = this._tDur, c = this._dur, h = s < 0, u = s > l - In && !h ? l : s < In ? 0 : s, d, f, m, g, p, v, y, _, x;
    if (!c)
      MR(this, s, r, a);
    else if (u !== this._tTime || !s || a || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== h || this._lazy) {
      if (d = u, _ = this.timeline, this._repeat) {
        if (g = c + this._rDelay, this._repeat < -1 && h)
          return this.totalTime(g * 100 + s, r, a);
        if (d = an(u % g), u === l ? (m = this._repeat, d = c) : (p = an(u / g), m = ~~p, m && m === p ? (d = c, m--) : d > c && (d = c)), v = this._yoyo && m & 1, v && (x = this._yEase, d = c - d), p = jo(this._tTime, g), d === o && !a && this._initted && m === p)
          return this._tTime = u, this;
        m !== p && (_ && this._yEase && jM(_, v), this.vars.repeatRefresh && !v && !this._lock && d !== g && this._initted && (this._lock = a = 1, this.render(an(g * m), !0).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (OM(this, h ? s : d, a, r, u))
          return this._tTime = 0, this;
        if (o !== this._time && !(a && this.vars.repeatRefresh && m !== p))
          return this;
        if (c !== this._dur)
          return this.render(s, r, a);
      }
      if (this._tTime = u, this._time = d, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = y = (x || this._ease)(d / c), this._from && (this.ratio = y = 1 - y), d && !o && !r && !m && (yi(this, "onStart"), this._tTime !== u))
        return this;
      for (f = this._pt; f; )
        f.r(y, f.d), f = f._next;
      _ && _.render(s < 0 ? s : _._dur * _._ease(d / this._dur), r, a) || this._startAt && (this._zTime = s), this._onUpdate && !r && (h && Zp(this, s, r, a), yi(this, "onUpdate")), this._repeat && m !== p && this.vars.onRepeat && !r && this.parent && yi(this, "onRepeat"), (u === this._tDur || !u) && this._tTime === u && (h && !this._onUpdate && Zp(this, s, !0, !0), (s || !c) && (u === this._tDur && this._ts > 0 || !u && this._ts < 0) && Lr(this, 1), !r && !(h && !o) && (u || o || v) && (yi(this, u === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(u < l && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, t.targets = function() {
    return this._targets;
  }, t.invalidate = function(s) {
    return (!s || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(s), i.prototype.invalidate.call(this, s);
  }, t.resetTo = function(s, r, a, o, l) {
    yc || _i.wake(), this._ts || this.play();
    var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts), h;
    return this._initted || Og(this, c), h = this._ease(c / this._dur), zR(this, s, r, a, o, h, c, l) ? this.resetTo(s, r, a, o, 1) : (zd(this, 0), this.parent || LM(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, t.kill = function(s, r) {
    if (r === void 0 && (r = "all"), !s && (!r || r === "all"))
      return this._lazy = this._pt = 0, this.parent ? Ll(this) : this.scrollTrigger && this.scrollTrigger.kill(!!wn), this;
    if (this.timeline) {
      var a = this.timeline.totalDuration();
      return this.timeline.killTweensOf(s, r, ur && ur.vars.overwrite !== !0)._first || Ll(this), this.parent && a !== this.timeline.totalDuration() && Zo(this, this._dur * this.timeline._tDur / a, 0, 1), this;
    }
    var o = this._targets, l = s ? Di(s) : o, c = this._ptLookup, h = this._pt, u, d, f, m, g, p, v;
    if ((!r || r === "all") && vR(o, l))
      return r === "all" && (this._pt = 0), Ll(this);
    for (u = this._op = this._op || [], r !== "all" && (gn(r) && (g = {}, ni(r, function(y) {
      return g[y] = 1;
    }), r = g), r = HR(o, r)), v = o.length; v--; )
      if (~l.indexOf(o[v])) {
        d = c[v], r === "all" ? (u[v] = r, m = d, f = {}) : (f = u[v] = u[v] || {}, m = r);
        for (g in m)
          p = d && d[g], p && ((!("kill" in p.d) || p.d.kill(g) === !0) && Bd(this, p, "_pt"), delete d[g]), f !== "all" && (f[g] = 1);
      }
    return this._initted && !this._pt && h && Ll(this), this;
  }, e.to = function(s, r) {
    return new e(s, r, arguments[2]);
  }, e.from = function(s, r) {
    return Wl(1, arguments);
  }, e.delayedCall = function(s, r, a, o) {
    return new e(r, 0, {
      immediateRender: !1,
      lazy: !1,
      overwrite: !1,
      delay: s,
      onComplete: r,
      onReverseComplete: r,
      onCompleteParams: a,
      onReverseCompleteParams: a,
      callbackScope: o
    });
  }, e.fromTo = function(s, r, a) {
    return Wl(2, arguments);
  }, e.set = function(s, r) {
    return r.duration = 0, r.repeatDelay || (r.repeat = 0), new e(s, r);
  }, e.killTweensOf = function(s, r, a) {
    return Ot.killTweensOf(s, r, a);
  }, e;
}(xc);
wi(rn.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
ni("staggerTo,staggerFrom,staggerFromTo", function(i) {
  rn[i] = function() {
    var e = new Hn(), t = Kp.call(arguments, 0);
    return t.splice(i === "staggerFromTo" ? 5 : 4, 0, 0), e[i].apply(e, t);
  };
});
var Ng = function(e, t, n) {
  return e[t] = n;
}, eb = function(e, t, n) {
  return e[t](n);
}, VR = function(e, t, n, s) {
  return e[t](s.fp, n);
}, WR = function(e, t, n) {
  return e.setAttribute(t, n);
}, Ug = function(e, t) {
  return Gt(e[t]) ? eb : Eg(e[t]) && e.setAttribute ? WR : Ng;
}, tb = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
}, XR = function(e, t) {
  return t.set(t.t, t.p, !!(t.s + t.c * e), t);
}, nb = function(e, t) {
  var n = t._pt, s = "";
  if (!e && t.b)
    s = t.b;
  else if (e === 1 && t.e)
    s = t.e;
  else {
    for (; n; )
      s = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + s, n = n._next;
    s += t.c;
  }
  t.set(t.t, t.p, s, t);
}, Fg = function(e, t) {
  for (var n = t._pt; n; )
    n.r(e, n.d), n = n._next;
}, qR = function(e, t, n, s) {
  for (var r = this._pt, a; r; )
    a = r._next, r.p === s && r.modifier(e, t, n), r = a;
}, YR = function(e) {
  for (var t = this._pt, n, s; t; )
    s = t._next, t.p === e && !t.op || t.op === e ? Bd(this, t, "_pt") : t.dep || (n = 1), t = s;
  return !n;
}, jR = function(e, t, n, s) {
  s.mSet(e, t, s.m.call(s.tween, n, s.mt), s);
}, ib = function(e) {
  for (var t = e._pt, n, s, r, a; t; ) {
    for (n = t._next, s = r; s && s.pr > t.pr; )
      s = s._next;
    (t._prev = s ? s._prev : a) ? t._prev._next = t : r = t, (t._next = s) ? s._prev = t : a = t, t = n;
  }
  e._pt = r;
}, ii = /* @__PURE__ */ function() {
  function i(t, n, s, r, a, o, l, c, h) {
    this.t = n, this.s = r, this.c = a, this.p = s, this.r = o || tb, this.d = l || this, this.set = c || Ng, this.pr = h || 0, this._next = t, t && (t._prev = this);
  }
  var e = i.prototype;
  return e.modifier = function(n, s, r) {
    this.mSet = this.mSet || this.set, this.set = jR, this.m = n, this.mt = r, this.tween = s;
  }, i;
}();
ni(Lg + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(i) {
  return Pg[i] = 1;
});
Si.TweenMax = Si.TweenLite = rn;
Si.TimelineLite = Si.TimelineMax = Hn;
Ot = new Hn({
  sortChildren: !1,
  defaults: qo,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0
});
Mi.stringFilter = qM;
var Sa = [], yu = {}, ZR = [], Kv = 0, $R = 0, Ff = function(e) {
  return (yu[e] || ZR).map(function(t) {
    return t();
  });
}, tm = function() {
  var e = Date.now(), t = [];
  e - Kv > 2 && (Ff("matchMediaInit"), Sa.forEach(function(n) {
    var s = n.queries, r = n.conditions, a, o, l, c;
    for (o in s)
      a = rs.matchMedia(s[o]).matches, a && (l = 1), a !== r[o] && (r[o] = a, c = 1);
    c && (n.revert(), l && t.push(n));
  }), Ff("matchMediaRevert"), t.forEach(function(n) {
    return n.onMatch(n, function(s) {
      return n.add(null, s);
    });
  }), Kv = e, Ff("matchMedia"));
}, sb = /* @__PURE__ */ function() {
  function i(t, n) {
    this.selector = n && Qp(n), this.data = [], this._r = [], this.isReverted = !1, this.id = $R++, t && this.add(t);
  }
  var e = i.prototype;
  return e.add = function(n, s, r) {
    Gt(n) && (r = s, s = n, n = Gt);
    var a = this, o = function() {
      var c = Lt, h = a.selector, u;
      return c && c !== a && c.data.push(a), r && (a.selector = Qp(r)), Lt = a, u = s.apply(a, arguments), Gt(u) && a._r.push(u), Lt = c, a.selector = h, a.isReverted = !1, u;
    };
    return a.last = o, n === Gt ? o(a, function(l) {
      return a.add(null, l);
    }) : n ? a[n] = o : o;
  }, e.ignore = function(n) {
    var s = Lt;
    Lt = null, n(this), Lt = s;
  }, e.getTweens = function() {
    var n = [];
    return this.data.forEach(function(s) {
      return s instanceof i ? n.push.apply(n, s.getTweens()) : s instanceof rn && !(s.parent && s.parent.data === "nested") && n.push(s);
    }), n;
  }, e.clear = function() {
    this._r.length = this.data.length = 0;
  }, e.kill = function(n, s) {
    var r = this;
    if (n ? function() {
      for (var o = r.getTweens(), l = r.data.length, c; l--; )
        c = r.data[l], c.data === "isFlip" && (c.revert(), c.getChildren(!0, !0, !1).forEach(function(h) {
          return o.splice(o.indexOf(h), 1);
        }));
      for (o.map(function(h) {
        return {
          g: h._dur || h._delay || h._sat && !h._sat.vars.immediateRender ? h.globalTime(0) : -1 / 0,
          t: h
        };
      }).sort(function(h, u) {
        return u.g - h.g || -1 / 0;
      }).forEach(function(h) {
        return h.t.revert(n);
      }), l = r.data.length; l--; )
        c = r.data[l], c instanceof Hn ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(), c.kill()) : !(c instanceof rn) && c.revert && c.revert(n);
      r._r.forEach(function(h) {
        return h(n, r);
      }), r.isReverted = !0;
    }() : this.data.forEach(function(o) {
      return o.kill && o.kill();
    }), this.clear(), s)
      for (var a = Sa.length; a--; )
        Sa[a].id === this.id && Sa.splice(a, 1);
  }, e.revert = function(n) {
    this.kill(n || {});
  }, i;
}(), KR = /* @__PURE__ */ function() {
  function i(t) {
    this.contexts = [], this.scope = t, Lt && Lt.data.push(this);
  }
  var e = i.prototype;
  return e.add = function(n, s, r) {
    xs(n) || (n = {
      matches: n
    });
    var a = new sb(0, r || this.scope), o = a.conditions = {}, l, c, h;
    Lt && !a.selector && (a.selector = Lt.selector), this.contexts.push(a), s = a.add("onMatch", s), a.queries = n;
    for (c in n)
      c === "all" ? h = 1 : (l = rs.matchMedia(n[c]), l && (Sa.indexOf(a) < 0 && Sa.push(a), (o[c] = l.matches) && (h = 1), l.addListener ? l.addListener(tm) : l.addEventListener("change", tm)));
    return h && s(a, function(u) {
      return a.add(null, u);
    }), this;
  }, e.revert = function(n) {
    this.kill(n || {});
  }, e.kill = function(n) {
    this.contexts.forEach(function(s) {
      return s.kill(n, !0);
    });
  }, i;
}(), Bu = {
  registerPlugin: function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    t.forEach(function(s) {
      return VM(s);
    });
  },
  timeline: function(e) {
    return new Hn(e);
  },
  getTweensOf: function(e, t) {
    return Ot.getTweensOf(e, t);
  },
  getProperty: function(e, t, n, s) {
    gn(e) && (e = Di(e)[0]);
    var r = xa(e || {}).get, a = n ? PM : RM;
    return n === "native" && (n = ""), e && (t ? a((pi[t] && pi[t].get || r)(e, t, n, s)) : function(o, l, c) {
      return a((pi[o] && pi[o].get || r)(e, o, l, c));
    });
  },
  quickSetter: function(e, t, n) {
    if (e = Di(e), e.length > 1) {
      var s = e.map(function(h) {
        return ri.quickSetter(h, t, n);
      }), r = s.length;
      return function(h) {
        for (var u = r; u--; )
          s[u](h);
      };
    }
    e = e[0] || {};
    var a = pi[t], o = xa(e), l = o.harness && (o.harness.aliases || {})[t] || t, c = a ? function(h) {
      var u = new a();
      xo._pt = 0, u.init(e, n ? h + n : h, xo, 0, [e]), u.render(1, u), xo._pt && Fg(1, xo);
    } : o.set(e, l);
    return a ? c : function(h) {
      return c(e, l, n ? h + n : h, o, 1);
    };
  },
  quickTo: function(e, t, n) {
    var s, r = ri.to(e, wi((s = {}, s[t] = "+=0.1", s.paused = !0, s.stagger = 0, s), n || {})), a = function(l, c, h) {
      return r.resetTo(t, l, c, h);
    };
    return a.tween = r, a;
  },
  isTweening: function(e) {
    return Ot.getTweensOf(e, !0).length > 0;
  },
  defaults: function(e) {
    return e && e.ease && (e.ease = ba(e.ease, qo.ease)), qv(qo, e || {});
  },
  config: function(e) {
    return qv(Mi, e || {});
  },
  registerEffect: function(e) {
    var t = e.name, n = e.effect, s = e.plugins, r = e.defaults, a = e.extendTimeline;
    (s || "").split(",").forEach(function(o) {
      return o && !pi[o] && !Si[o] && gc(t + " effect requires " + o + " plugin.");
    }), Df[t] = function(o, l, c) {
      return n(Di(o), wi(l || {}, r), c);
    }, a && (Hn.prototype[t] = function(o, l, c) {
      return this.add(Df[t](o, xs(l) ? l : (c = l) && {}, this), c);
    });
  },
  registerEase: function(e, t) {
    ut[e] = ba(t);
  },
  parseEase: function(e, t) {
    return arguments.length ? ba(e, t) : ut;
  },
  getById: function(e) {
    return Ot.getById(e);
  },
  exportRoot: function(e, t) {
    e === void 0 && (e = {});
    var n = new Hn(e), s, r;
    for (n.smoothChildTiming = ti(e.smoothChildTiming), Ot.remove(n), n._dp = 0, n._time = n._tTime = Ot._time, s = Ot._first; s; )
      r = s._next, (t || !(!s._dur && s instanceof rn && s.vars.onComplete === s._targets[0])) && ls(n, s, s._start - s._delay), s = r;
    return ls(Ot, n, 0), n;
  },
  context: function(e, t) {
    return e ? new sb(e, t) : Lt;
  },
  matchMedia: function(e) {
    return new KR(e);
  },
  matchMediaRefresh: function() {
    return Sa.forEach(function(e) {
      var t = e.conditions, n, s;
      for (s in t)
        t[s] && (t[s] = !1, n = 1);
      n && e.revert();
    }) || tm();
  },
  addEventListener: function(e, t) {
    var n = yu[e] || (yu[e] = []);
    ~n.indexOf(t) || n.push(t);
  },
  removeEventListener: function(e, t) {
    var n = yu[e], s = n && n.indexOf(t);
    s >= 0 && n.splice(s, 1);
  },
  utils: {
    wrap: RR,
    wrapYoyo: PR,
    distribute: FM,
    random: kM,
    snap: BM,
    normalize: CR,
    getUnit: Ln,
    clamp: wR,
    splitColor: WM,
    toArray: Di,
    selector: Qp,
    mapRange: HM,
    pipe: ER,
    unitize: AR,
    interpolate: LR,
    shuffle: UM
  },
  install: wM,
  effects: Df,
  ticker: _i,
  updateRoot: Hn.updateRoot,
  plugins: pi,
  globalTimeline: Ot,
  core: {
    PropTween: ii,
    globals: TM,
    Tween: rn,
    Timeline: Hn,
    Animation: xc,
    getCache: xa,
    _removeLinkedListItem: Bd,
    reverting: function() {
      return wn;
    },
    context: function(e) {
      return e && Lt && (Lt.data.push(e), e._ctx = Lt), Lt;
    },
    suppressOverwrites: function(e) {
      return Tg = e;
    }
  }
};
ni("to,from,fromTo,delayedCall,set,killTweensOf", function(i) {
  return Bu[i] = rn[i];
});
_i.add(Hn.updateRoot);
xo = Bu.to({}, {
  duration: 0
});
var QR = function(e, t) {
  for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
    n = n._next;
  return n;
}, JR = function(e, t) {
  var n = e._targets, s, r, a;
  for (s in t)
    for (r = n.length; r--; )
      a = e._ptLookup[r][s], a && (a = a.d) && (a._pt && (a = QR(a, s)), a && a.modifier && a.modifier(t[s], e, n[r], s));
}, Bf = function(e, t) {
  return {
    name: e,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function(s, r, a) {
      a._onInit = function(o) {
        var l, c;
        if (gn(r) && (l = {}, ni(r, function(h) {
          return l[h] = 1;
        }), r = l), t) {
          l = {};
          for (c in r)
            l[c] = t(r[c]);
          r = l;
        }
        JR(o, r);
      };
    }
  };
}, ri = Bu.registerPlugin({
  name: "attr",
  init: function(e, t, n, s, r) {
    var a, o, l;
    this.tween = n;
    for (a in t)
      l = e.getAttribute(a) || "", o = this.add(e, "setAttribute", (l || 0) + "", t[a], s, r, 0, 0, a), o.op = a, o.b = l, this._props.push(a);
  },
  render: function(e, t) {
    for (var n = t._pt; n; )
      wn ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), n = n._next;
  }
}, {
  name: "endArray",
  init: function(e, t) {
    for (var n = t.length; n--; )
      this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1);
  }
}, Bf("roundProps", Jp), Bf("modifiers"), Bf("snap", BM)) || Bu;
rn.version = Hn.version = ri.version = "3.12.7";
SM = 1;
Ag() && $o();
ut.Power0;
ut.Power1;
ut.Power2;
ut.Power3;
ut.Power4;
ut.Linear;
ut.Quad;
ut.Cubic;
ut.Quart;
ut.Quint;
ut.Strong;
ut.Elastic;
ut.Back;
ut.SteppedEase;
ut.Bounce;
ut.Sine;
ut.Expo;
ut.Circ;
/*!
 * CSSPlugin 3.12.7
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Qv, dr, Po, Bg, va, Jv, kg, eP = function() {
  return typeof window < "u";
}, qs = {}, ha = 180 / Math.PI, Lo = Math.PI / 180, lo = Math.atan2, e_ = 1e8, zg = /([A-Z])/g, tP = /(left|right|width|margin|padding|x)/i, nP = /[\s,\(]\S/, ds = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
}, nm = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, iP = function(e, t) {
  return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, sP = function(e, t) {
  return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t);
}, rP = function(e, t) {
  var n = t.s + t.c * e;
  t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
}, rb = function(e, t) {
  return t.set(t.t, t.p, e ? t.e : t.b, t);
}, ab = function(e, t) {
  return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
}, aP = function(e, t, n) {
  return e.style[t] = n;
}, oP = function(e, t, n) {
  return e.style.setProperty(t, n);
}, lP = function(e, t, n) {
  return e._gsap[t] = n;
}, cP = function(e, t, n) {
  return e._gsap.scaleX = e._gsap.scaleY = n;
}, hP = function(e, t, n, s, r) {
  var a = e._gsap;
  a.scaleX = a.scaleY = n, a.renderTransform(r, a);
}, uP = function(e, t, n, s, r) {
  var a = e._gsap;
  a[t] = n, a.renderTransform(r, a);
}, Ft = "transform", si = Ft + "Origin", dP = function i(e, t) {
  var n = this, s = this.target, r = s.style, a = s._gsap;
  if (e in qs && r) {
    if (this.tfm = this.tfm || {}, e !== "transform")
      e = ds[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(o) {
        return n.tfm[o] = Os(s, o);
      }) : this.tfm[e] = a.x ? a[e] : Os(s, e), e === si && (this.tfm.zOrigin = a.zOrigin);
    else
      return ds.transform.split(",").forEach(function(o) {
        return i.call(n, o, t);
      });
    if (this.props.indexOf(Ft) >= 0)
      return;
    a.svg && (this.svgo = s.getAttribute("data-svg-origin"), this.props.push(si, t, "")), e = Ft;
  }
  (r || t) && this.props.push(e, t, r[e]);
}, ob = function(e) {
  e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"));
}, fP = function() {
  var e = this.props, t = this.target, n = t.style, s = t._gsap, r, a;
  for (r = 0; r < e.length; r += 3)
    e[r + 1] ? e[r + 1] === 2 ? t[e[r]](e[r + 2]) : t[e[r]] = e[r + 2] : e[r + 2] ? n[e[r]] = e[r + 2] : n.removeProperty(e[r].substr(0, 2) === "--" ? e[r] : e[r].replace(zg, "-$1").toLowerCase());
  if (this.tfm) {
    for (a in this.tfm)
      s[a] = this.tfm[a];
    s.svg && (s.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), r = kg(), (!r || !r.isStart) && !n[Ft] && (ob(n), s.zOrigin && n[si] && (n[si] += " " + s.zOrigin + "px", s.zOrigin = 0, s.renderTransform()), s.uncache = 1);
  }
}, lb = function(e, t) {
  var n = {
    target: e,
    props: [],
    revert: fP,
    save: dP
  };
  return e._gsap || ri.core.getCache(e), t && e.style && e.nodeType && t.split(",").forEach(function(s) {
    return n.save(s);
  }), n;
}, cb, im = function(e, t) {
  var n = dr.createElementNS ? dr.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : dr.createElement(e);
  return n && n.style ? n : dr.createElement(e);
}, vs = function i(e, t, n) {
  var s = getComputedStyle(e);
  return s[t] || s.getPropertyValue(t.replace(zg, "-$1").toLowerCase()) || s.getPropertyValue(t) || !n && i(e, Ko(t) || t, 1) || "";
}, t_ = "O,Moz,ms,Ms,Webkit".split(","), Ko = function(e, t, n) {
  var s = t || va, r = s.style, a = 5;
  if (e in r && !n)
    return e;
  for (e = e.charAt(0).toUpperCase() + e.substr(1); a-- && !(t_[a] + e in r); )
    ;
  return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? t_[a] : "") + e;
}, sm = function() {
  eP() && window.document && (Qv = window, dr = Qv.document, Po = dr.documentElement, va = im("div") || {
    style: {}
  }, im("div"), Ft = Ko(Ft), si = Ft + "Origin", va.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", cb = !!Ko("perspective"), kg = ri.core.reverting, Bg = 1);
}, n_ = function(e) {
  var t = e.ownerSVGElement, n = im("svg", t && t.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), s = e.cloneNode(!0), r;
  s.style.display = "block", n.appendChild(s), Po.appendChild(n);
  try {
    r = s.getBBox();
  } catch {
  }
  return n.removeChild(s), Po.removeChild(n), r;
}, i_ = function(e, t) {
  for (var n = t.length; n--; )
    if (e.hasAttribute(t[n]))
      return e.getAttribute(t[n]);
}, hb = function(e) {
  var t, n;
  try {
    t = e.getBBox();
  } catch {
    t = n_(e), n = 1;
  }
  return t && (t.width || t.height) || n || (t = n_(e)), t && !t.width && !t.x && !t.y ? {
    x: +i_(e, ["x", "cx", "x1"]) || 0,
    y: +i_(e, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : t;
}, ub = function(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && hb(e));
}, La = function(e, t) {
  if (t) {
    var n = e.style, s;
    t in qs && t !== si && (t = Ft), n.removeProperty ? (s = t.substr(0, 2), (s === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), n.removeProperty(s === "--" ? t : t.replace(zg, "-$1").toLowerCase())) : n.removeAttribute(t);
  }
}, fr = function(e, t, n, s, r, a) {
  var o = new ii(e._pt, t, n, 0, 1, a ? ab : rb);
  return e._pt = o, o.b = s, o.e = r, e._props.push(n), o;
}, s_ = {
  deg: 1,
  rad: 1,
  turn: 1
}, pP = {
  grid: 1,
  flex: 1
}, Ir = function i(e, t, n, s) {
  var r = parseFloat(n) || 0, a = (n + "").trim().substr((r + "").length) || "px", o = va.style, l = tP.test(t), c = e.tagName.toLowerCase() === "svg", h = (c ? "client" : "offset") + (l ? "Width" : "Height"), u = 100, d = s === "px", f = s === "%", m, g, p, v;
  if (s === a || !r || s_[s] || s_[a])
    return r;
  if (a !== "px" && !d && (r = i(e, t, n, "px")), v = e.getCTM && ub(e), (f || a === "%") && (qs[t] || ~t.indexOf("adius")))
    return m = v ? e.getBBox()[l ? "width" : "height"] : e[h], jt(f ? r / m * u : r / 100 * m);
  if (o[l ? "width" : "height"] = u + (d ? a : s), g = s !== "rem" && ~t.indexOf("adius") || s === "em" && e.appendChild && !c ? e : e.parentNode, v && (g = (e.ownerSVGElement || {}).parentNode), (!g || g === dr || !g.appendChild) && (g = dr.body), p = g._gsap, p && f && p.width && l && p.time === _i.time && !p.uncache)
    return jt(r / p.width * u);
  if (f && (t === "height" || t === "width")) {
    var y = e.style[t];
    e.style[t] = u + s, m = e[h], y ? e.style[t] = y : La(e, t);
  } else
    (f || a === "%") && !pP[vs(g, "display")] && (o.position = vs(e, "position")), g === e && (o.position = "static"), g.appendChild(va), m = va[h], g.removeChild(va), o.position = "absolute";
  return l && f && (p = xa(g), p.time = _i.time, p.width = g[h]), jt(d ? m * r / u : m && r ? u / m * r : 0);
}, Os = function(e, t, n, s) {
  var r;
  return Bg || sm(), t in ds && t !== "transform" && (t = ds[t], ~t.indexOf(",") && (t = t.split(",")[0])), qs[t] && t !== "transform" ? (r = bc(e, s), r = t !== "transformOrigin" ? r[t] : r.svg ? r.origin : zu(vs(e, si)) + " " + r.zOrigin + "px") : (r = e.style[t], (!r || r === "auto" || s || ~(r + "").indexOf("calc(")) && (r = ku[t] && ku[t](e, t, n) || vs(e, t) || AM(e, t) || (t === "opacity" ? 1 : 0))), n && !~(r + "").trim().indexOf(" ") ? Ir(e, t, r, n) + n : r;
}, mP = function(e, t, n, s) {
  if (!n || n === "none") {
    var r = Ko(t, e, 1), a = r && vs(e, r, 1);
    a && a !== n ? (t = r, n = a) : t === "borderColor" && (n = vs(e, "borderTopColor"));
  }
  var o = new ii(this._pt, e.style, t, 0, 1, nb), l = 0, c = 0, h, u, d, f, m, g, p, v, y, _, x, M;
  if (o.b = n, o.e = s, n += "", s += "", s === "auto" && (g = e.style[t], e.style[t] = s, s = vs(e, t) || s, g ? e.style[t] = g : La(e, t)), h = [n, s], qM(h), n = h[0], s = h[1], d = n.match(yo) || [], M = s.match(yo) || [], M.length) {
    for (; u = yo.exec(s); )
      p = u[0], y = s.substring(l, u.index), m ? m = (m + 1) % 5 : (y.substr(-5) === "rgba(" || y.substr(-5) === "hsla(") && (m = 1), p !== (g = d[c++] || "") && (f = parseFloat(g) || 0, x = g.substr((f + "").length), p.charAt(1) === "=" && (p = Ro(f, p) + x), v = parseFloat(p), _ = p.substr((v + "").length), l = yo.lastIndex - _.length, _ || (_ = _ || Mi.units[t] || x, l === s.length && (s += _, o.e += _)), x !== _ && (f = Ir(e, t, g, _) || 0), o._pt = {
        _next: o._pt,
        p: y || c === 1 ? y : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: f,
        c: v - f,
        m: m && m < 4 || t === "zIndex" ? Math.round : 0
      });
    o.c = l < s.length ? s.substring(l, s.length) : "";
  } else
    o.r = t === "display" && s === "none" ? ab : rb;
  return MM.test(s) && (o.e = 0), this._pt = o, o;
}, r_ = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
}, gP = function(e) {
  var t = e.split(" "), n = t[0], s = t[1] || "50%";
  return (n === "top" || n === "bottom" || s === "left" || s === "right") && (e = n, n = s, s = e), t[0] = r_[n] || n, t[1] = r_[s] || s, t.join(" ");
}, vP = function(e, t) {
  if (t.tween && t.tween._time === t.tween._dur) {
    var n = t.t, s = n.style, r = t.u, a = n._gsap, o, l, c;
    if (r === "all" || r === !0)
      s.cssText = "", l = 1;
    else
      for (r = r.split(","), c = r.length; --c > -1; )
        o = r[c], qs[o] && (l = 1, o = o === "transformOrigin" ? si : Ft), La(n, o);
    l && (La(n, Ft), a && (a.svg && n.removeAttribute("transform"), s.scale = s.rotate = s.translate = "none", bc(n, 1), a.uncache = 1, ob(s)));
  }
}, ku = {
  clearProps: function(e, t, n, s, r) {
    if (r.data !== "isFromStart") {
      var a = e._pt = new ii(e._pt, t, n, 0, 0, vP);
      return a.u = s, a.pr = -10, a.tween = r, e._props.push(n), 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */
}, Mc = [1, 0, 0, 1, 0, 0], db = {}, fb = function(e) {
  return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
}, a_ = function(e) {
  var t = vs(e, Ft);
  return fb(t) ? Mc : t.substr(7).match(xM).map(jt);
}, Hg = function(e, t) {
  var n = e._gsap || xa(e), s = e.style, r = a_(e), a, o, l, c;
  return n.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, r = [l.a, l.b, l.c, l.d, l.e, l.f], r.join(",") === "1,0,0,1,0,0" ? Mc : r) : (r === Mc && !e.offsetParent && e !== Po && !n.svg && (l = s.display, s.display = "block", a = e.parentNode, (!a || !e.offsetParent && !e.getBoundingClientRect().width) && (c = 1, o = e.nextElementSibling, Po.appendChild(e)), r = a_(e), l ? s.display = l : La(e, "display"), c && (o ? a.insertBefore(e, o) : a ? a.appendChild(e) : Po.removeChild(e))), t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r);
}, rm = function(e, t, n, s, r, a) {
  var o = e._gsap, l = r || Hg(e, !0), c = o.xOrigin || 0, h = o.yOrigin || 0, u = o.xOffset || 0, d = o.yOffset || 0, f = l[0], m = l[1], g = l[2], p = l[3], v = l[4], y = l[5], _ = t.split(" "), x = parseFloat(_[0]) || 0, M = parseFloat(_[1]) || 0, S, w, E, b;
  n ? l !== Mc && (w = f * p - m * g) && (E = x * (p / w) + M * (-g / w) + (g * y - p * v) / w, b = x * (-m / w) + M * (f / w) - (f * y - m * v) / w, x = E, M = b) : (S = hb(e), x = S.x + (~_[0].indexOf("%") ? x / 100 * S.width : x), M = S.y + (~(_[1] || _[0]).indexOf("%") ? M / 100 * S.height : M)), s || s !== !1 && o.smooth ? (v = x - c, y = M - h, o.xOffset = u + (v * f + y * g) - v, o.yOffset = d + (v * m + y * p) - y) : o.xOffset = o.yOffset = 0, o.xOrigin = x, o.yOrigin = M, o.smooth = !!s, o.origin = t, o.originIsAbsolute = !!n, e.style[si] = "0px 0px", a && (fr(a, o, "xOrigin", c, x), fr(a, o, "yOrigin", h, M), fr(a, o, "xOffset", u, o.xOffset), fr(a, o, "yOffset", d, o.yOffset)), e.setAttribute("data-svg-origin", x + " " + M);
}, bc = function(e, t) {
  var n = e._gsap || new $M(e);
  if ("x" in n && !t && !n.uncache)
    return n;
  var s = e.style, r = n.scaleX < 0, a = "px", o = "deg", l = getComputedStyle(e), c = vs(e, si) || "0", h, u, d, f, m, g, p, v, y, _, x, M, S, w, E, b, A, D, B, X, L, F, H, G, te, j, J, N, q, ge, de, be;
  return h = u = d = g = p = v = y = _ = x = 0, f = m = 1, n.svg = !!(e.getCTM && ub(e)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (s[Ft] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[Ft] !== "none" ? l[Ft] : "")), s.scale = s.rotate = s.translate = "none"), w = Hg(e, n.svg), n.svg && (n.uncache ? (te = e.getBBox(), c = n.xOrigin - te.x + "px " + (n.yOrigin - te.y) + "px", G = "") : G = !t && e.getAttribute("data-svg-origin"), rm(e, G || c, !!G || n.originIsAbsolute, n.smooth !== !1, w)), M = n.xOrigin || 0, S = n.yOrigin || 0, w !== Mc && (D = w[0], B = w[1], X = w[2], L = w[3], h = F = w[4], u = H = w[5], w.length === 6 ? (f = Math.sqrt(D * D + B * B), m = Math.sqrt(L * L + X * X), g = D || B ? lo(B, D) * ha : 0, y = X || L ? lo(X, L) * ha + g : 0, y && (m *= Math.abs(Math.cos(y * Lo))), n.svg && (h -= M - (M * D + S * X), u -= S - (M * B + S * L))) : (be = w[6], ge = w[7], J = w[8], N = w[9], q = w[10], de = w[11], h = w[12], u = w[13], d = w[14], E = lo(be, q), p = E * ha, E && (b = Math.cos(-E), A = Math.sin(-E), G = F * b + J * A, te = H * b + N * A, j = be * b + q * A, J = F * -A + J * b, N = H * -A + N * b, q = be * -A + q * b, de = ge * -A + de * b, F = G, H = te, be = j), E = lo(-X, q), v = E * ha, E && (b = Math.cos(-E), A = Math.sin(-E), G = D * b - J * A, te = B * b - N * A, j = X * b - q * A, de = L * A + de * b, D = G, B = te, X = j), E = lo(B, D), g = E * ha, E && (b = Math.cos(E), A = Math.sin(E), G = D * b + B * A, te = F * b + H * A, B = B * b - D * A, H = H * b - F * A, D = G, F = te), p && Math.abs(p) + Math.abs(g) > 359.9 && (p = g = 0, v = 180 - v), f = jt(Math.sqrt(D * D + B * B + X * X)), m = jt(Math.sqrt(H * H + be * be)), E = lo(F, H), y = Math.abs(E) > 2e-4 ? E * ha : 0, x = de ? 1 / (de < 0 ? -de : de) : 0), n.svg && (G = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !fb(vs(e, Ft)), G && e.setAttribute("transform", G))), Math.abs(y) > 90 && Math.abs(y) < 270 && (r ? (f *= -1, y += g <= 0 ? 180 : -180, g += g <= 0 ? 180 : -180) : (m *= -1, y += y <= 0 ? 180 : -180)), t = t || n.uncache, n.x = h - ((n.xPercent = h && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-h) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + a, n.y = u - ((n.yPercent = u && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-u) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + a, n.z = d + a, n.scaleX = jt(f), n.scaleY = jt(m), n.rotation = jt(g) + o, n.rotationX = jt(p) + o, n.rotationY = jt(v) + o, n.skewX = y + o, n.skewY = _ + o, n.transformPerspective = x + a, (n.zOrigin = parseFloat(c.split(" ")[2]) || !t && n.zOrigin || 0) && (s[si] = zu(c)), n.xOffset = n.yOffset = 0, n.force3D = Mi.force3D, n.renderTransform = n.svg ? yP : cb ? pb : _P, n.uncache = 0, n;
}, zu = function(e) {
  return (e = e.split(" "))[0] + " " + e[1];
}, kf = function(e, t, n) {
  var s = Ln(t);
  return jt(parseFloat(t) + parseFloat(Ir(e, "x", n + "px", s))) + s;
}, _P = function(e, t) {
  t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, pb(e, t);
}, na = "0deg", bl = "0px", ia = ") ", pb = function(e, t) {
  var n = t || this, s = n.xPercent, r = n.yPercent, a = n.x, o = n.y, l = n.z, c = n.rotation, h = n.rotationY, u = n.rotationX, d = n.skewX, f = n.skewY, m = n.scaleX, g = n.scaleY, p = n.transformPerspective, v = n.force3D, y = n.target, _ = n.zOrigin, x = "", M = v === "auto" && e && e !== 1 || v === !0;
  if (_ && (u !== na || h !== na)) {
    var S = parseFloat(h) * Lo, w = Math.sin(S), E = Math.cos(S), b;
    S = parseFloat(u) * Lo, b = Math.cos(S), a = kf(y, a, w * b * -_), o = kf(y, o, -Math.sin(S) * -_), l = kf(y, l, E * b * -_ + _);
  }
  p !== bl && (x += "perspective(" + p + ia), (s || r) && (x += "translate(" + s + "%, " + r + "%) "), (M || a !== bl || o !== bl || l !== bl) && (x += l !== bl || M ? "translate3d(" + a + ", " + o + ", " + l + ") " : "translate(" + a + ", " + o + ia), c !== na && (x += "rotate(" + c + ia), h !== na && (x += "rotateY(" + h + ia), u !== na && (x += "rotateX(" + u + ia), (d !== na || f !== na) && (x += "skew(" + d + ", " + f + ia), (m !== 1 || g !== 1) && (x += "scale(" + m + ", " + g + ia), y.style[Ft] = x || "translate(0, 0)";
}, yP = function(e, t) {
  var n = t || this, s = n.xPercent, r = n.yPercent, a = n.x, o = n.y, l = n.rotation, c = n.skewX, h = n.skewY, u = n.scaleX, d = n.scaleY, f = n.target, m = n.xOrigin, g = n.yOrigin, p = n.xOffset, v = n.yOffset, y = n.forceCSS, _ = parseFloat(a), x = parseFloat(o), M, S, w, E, b;
  l = parseFloat(l), c = parseFloat(c), h = parseFloat(h), h && (h = parseFloat(h), c += h, l += h), l || c ? (l *= Lo, c *= Lo, M = Math.cos(l) * u, S = Math.sin(l) * u, w = Math.sin(l - c) * -d, E = Math.cos(l - c) * d, c && (h *= Lo, b = Math.tan(c - h), b = Math.sqrt(1 + b * b), w *= b, E *= b, h && (b = Math.tan(h), b = Math.sqrt(1 + b * b), M *= b, S *= b)), M = jt(M), S = jt(S), w = jt(w), E = jt(E)) : (M = u, E = d, S = w = 0), (_ && !~(a + "").indexOf("px") || x && !~(o + "").indexOf("px")) && (_ = Ir(f, "x", a, "px"), x = Ir(f, "y", o, "px")), (m || g || p || v) && (_ = jt(_ + m - (m * M + g * w) + p), x = jt(x + g - (m * S + g * E) + v)), (s || r) && (b = f.getBBox(), _ = jt(_ + s / 100 * b.width), x = jt(x + r / 100 * b.height)), b = "matrix(" + M + "," + S + "," + w + "," + E + "," + _ + "," + x + ")", f.setAttribute("transform", b), y && (f.style[Ft] = b);
}, xP = function(e, t, n, s, r) {
  var a = 360, o = gn(r), l = parseFloat(r) * (o && ~r.indexOf("rad") ? ha : 1), c = l - s, h = s + c + "deg", u, d;
  return o && (u = r.split("_")[1], u === "short" && (c %= a, c !== c % (a / 2) && (c += c < 0 ? a : -360)), u === "cw" && c < 0 ? c = (c + a * e_) % a - ~~(c / a) * a : u === "ccw" && c > 0 && (c = (c - a * e_) % a - ~~(c / a) * a)), e._pt = d = new ii(e._pt, t, n, s, c, iP), d.e = h, d.u = "deg", e._props.push(n), d;
}, o_ = function(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}, MP = function(e, t, n) {
  var s = o_({}, n._gsap), r = "perspective,force3D,transformOrigin,svgOrigin", a = n.style, o, l, c, h, u, d, f, m;
  s.svg ? (c = n.getAttribute("transform"), n.setAttribute("transform", ""), a[Ft] = t, o = bc(n, 1), La(n, Ft), n.setAttribute("transform", c)) : (c = getComputedStyle(n)[Ft], a[Ft] = t, o = bc(n, 1), a[Ft] = c);
  for (l in qs)
    c = s[l], h = o[l], c !== h && r.indexOf(l) < 0 && (f = Ln(c), m = Ln(h), u = f !== m ? Ir(n, l, c, m) : parseFloat(c), d = parseFloat(h), e._pt = new ii(e._pt, o, l, u, d - u, nm), e._pt.u = m || 0, e._props.push(l));
  o_(o, s);
};
ni("padding,margin,Width,Radius", function(i, e) {
  var t = "Top", n = "Right", s = "Bottom", r = "Left", a = (e < 3 ? [t, n, s, r] : [t + r, t + n, s + n, s + r]).map(function(o) {
    return e < 2 ? i + o : "border" + o + i;
  });
  ku[e > 1 ? "border" + i : i] = function(o, l, c, h, u) {
    var d, f;
    if (arguments.length < 4)
      return d = a.map(function(m) {
        return Os(o, m, c);
      }), f = d.join(" "), f.split(d[0]).length === 5 ? d[0] : f;
    d = (h + "").split(" "), f = {}, a.forEach(function(m, g) {
      return f[m] = d[g] = d[g] || d[(g - 1) / 2 | 0];
    }), o.init(l, f, u);
  };
});
var mb = {
  name: "css",
  register: sm,
  targetTest: function(e) {
    return e.style && e.nodeType;
  },
  init: function(e, t, n, s, r) {
    var a = this._props, o = e.style, l = n.vars.startAt, c, h, u, d, f, m, g, p, v, y, _, x, M, S, w, E;
    Bg || sm(), this.styles = this.styles || lb(e), E = this.styles.props, this.tween = n;
    for (g in t)
      if (g !== "autoRound" && (h = t[g], !(pi[g] && KM(g, t, n, s, e, r)))) {
        if (f = typeof h, m = ku[g], f === "function" && (h = h.call(n, s, e, r), f = typeof h), f === "string" && ~h.indexOf("random(") && (h = _c(h)), m)
          m(this, e, g, h, n) && (w = 1);
        else if (g.substr(0, 2) === "--")
          c = (getComputedStyle(e).getPropertyValue(g) + "").trim(), h += "", Mr.lastIndex = 0, Mr.test(c) || (p = Ln(c), v = Ln(h)), v ? p !== v && (c = Ir(e, g, c, v) + v) : p && (h += p), this.add(o, "setProperty", c, h, s, r, 0, 0, g), a.push(g), E.push(g, 0, o[g]);
        else if (f !== "undefined") {
          if (l && g in l ? (c = typeof l[g] == "function" ? l[g].call(n, s, e, r) : l[g], gn(c) && ~c.indexOf("random(") && (c = _c(c)), Ln(c + "") || c === "auto" || (c += Mi.units[g] || Ln(Os(e, g)) || ""), (c + "").charAt(1) === "=" && (c = Os(e, g))) : c = Os(e, g), d = parseFloat(c), y = f === "string" && h.charAt(1) === "=" && h.substr(0, 2), y && (h = h.substr(2)), u = parseFloat(h), g in ds && (g === "autoAlpha" && (d === 1 && Os(e, "visibility") === "hidden" && u && (d = 0), E.push("visibility", 0, o.visibility), fr(this, o, "visibility", d ? "inherit" : "hidden", u ? "inherit" : "hidden", !u)), g !== "scale" && g !== "transform" && (g = ds[g], ~g.indexOf(",") && (g = g.split(",")[0]))), _ = g in qs, _) {
            if (this.styles.save(g), x || (M = e._gsap, M.renderTransform && !t.parseTransform || bc(e, t.parseTransform), S = t.smoothOrigin !== !1 && M.smooth, x = this._pt = new ii(this._pt, o, Ft, 0, 1, M.renderTransform, M, 0, -1), x.dep = 1), g === "scale")
              this._pt = new ii(this._pt, M, "scaleY", M.scaleY, (y ? Ro(M.scaleY, y + u) : u) - M.scaleY || 0, nm), this._pt.u = 0, a.push("scaleY", g), g += "X";
            else if (g === "transformOrigin") {
              E.push(si, 0, o[si]), h = gP(h), M.svg ? rm(e, h, 0, S, 0, this) : (v = parseFloat(h.split(" ")[2]) || 0, v !== M.zOrigin && fr(this, M, "zOrigin", M.zOrigin, v), fr(this, o, g, zu(c), zu(h)));
              continue;
            } else if (g === "svgOrigin") {
              rm(e, h, 1, S, 0, this);
              continue;
            } else if (g in db) {
              xP(this, M, g, d, y ? Ro(d, y + h) : h);
              continue;
            } else if (g === "smoothOrigin") {
              fr(this, M, "smooth", M.smooth, h);
              continue;
            } else if (g === "force3D") {
              M[g] = h;
              continue;
            } else if (g === "transform") {
              MP(this, h, e);
              continue;
            }
          } else g in o || (g = Ko(g) || g);
          if (_ || (u || u === 0) && (d || d === 0) && !nP.test(h) && g in o)
            p = (c + "").substr((d + "").length), u || (u = 0), v = Ln(h) || (g in Mi.units ? Mi.units[g] : p), p !== v && (d = Ir(e, g, c, v)), this._pt = new ii(this._pt, _ ? M : o, g, d, (y ? Ro(d, y + u) : u) - d, !_ && (v === "px" || g === "zIndex") && t.autoRound !== !1 ? rP : nm), this._pt.u = v || 0, p !== v && v !== "%" && (this._pt.b = c, this._pt.r = sP);
          else if (g in o)
            mP.call(this, e, g, c, y ? y + h : h);
          else if (g in e)
            this.add(e, g, c || e[g], y ? y + h : h, s, r);
          else if (g !== "parseTransform") {
            Rg(g, h);
            continue;
          }
          _ || (g in o ? E.push(g, 0, o[g]) : typeof e[g] == "function" ? E.push(g, 2, e[g]()) : E.push(g, 1, c || e[g])), a.push(g);
        }
      }
    w && ib(this);
  },
  render: function(e, t) {
    if (t.tween._time || !kg())
      for (var n = t._pt; n; )
        n.r(e, n.d), n = n._next;
    else
      t.styles.revert();
  },
  get: Os,
  aliases: ds,
  getSetter: function(e, t, n) {
    var s = ds[t];
    return s && s.indexOf(",") < 0 && (t = s), t in qs && t !== si && (e._gsap.x || Os(e, "x")) ? n && Jv === n ? t === "scale" ? cP : lP : (Jv = n || {}) && (t === "scale" ? hP : uP) : e.style && !Eg(e.style[t]) ? aP : ~t.indexOf("-") ? oP : Ug(e, t);
  },
  core: {
    _removeProperty: La,
    _getMatrix: Hg
  }
};
ri.utils.checkPrefix = Ko;
ri.core.getStyleSaver = lb;
(function(i, e, t, n) {
  var s = ni(i + "," + e + "," + t, function(r) {
    qs[r] = 1;
  });
  ni(e, function(r) {
    Mi.units[r] = "deg", db[r] = 1;
  }), ds[s[13]] = i + "," + e, ni(n, function(r) {
    var a = r.split(":");
    ds[a[1]] = s[a[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
ni("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(i) {
  Mi.units[i] = "px";
});
ri.registerPlugin(mb);
var Hd = ri.registerPlugin(mb) || ri;
Hd.core.Tween;
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var l_ = function(i) {
  return URL.createObjectURL(new Blob([i], { type: "text/javascript" }));
};
try {
  URL.revokeObjectURL(l_(""));
} catch {
  l_ = function(e) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(e);
  };
}
var Ii = Uint8Array, pr = Uint16Array, am = Uint32Array, gb = new Ii([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), vb = new Ii([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), bP = new Ii([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), _b = function(i, e) {
  for (var t = new pr(31), n = 0; n < 31; ++n)
    t[n] = e += 1 << i[n - 1];
  for (var s = new am(t[30]), n = 1; n < 30; ++n)
    for (var r = t[n]; r < t[n + 1]; ++r)
      s[r] = r - t[n] << 5 | n;
  return [t, s];
}, yb = _b(gb, 2), xb = yb[0], SP = yb[1];
xb[28] = 258, SP[258] = 28;
var wP = _b(vb, 0), TP = wP[0], om = new pr(32768);
for (var Et = 0; Et < 32768; ++Et) {
  var ir = (Et & 43690) >>> 1 | (Et & 21845) << 1;
  ir = (ir & 52428) >>> 2 | (ir & 13107) << 2, ir = (ir & 61680) >>> 4 | (ir & 3855) << 4, om[Et] = ((ir & 65280) >>> 8 | (ir & 255) << 8) >>> 1;
}
var ql = function(i, e, t) {
  for (var n = i.length, s = 0, r = new pr(e); s < n; ++s)
    ++r[i[s] - 1];
  var a = new pr(e);
  for (s = 0; s < e; ++s)
    a[s] = a[s - 1] + r[s - 1] << 1;
  var o;
  if (t) {
    o = new pr(1 << e);
    var l = 15 - e;
    for (s = 0; s < n; ++s)
      if (i[s])
        for (var c = s << 4 | i[s], h = e - i[s], u = a[i[s] - 1]++ << h, d = u | (1 << h) - 1; u <= d; ++u)
          o[om[u] >>> l] = c;
  } else
    for (o = new pr(n), s = 0; s < n; ++s)
      i[s] && (o[s] = om[a[i[s] - 1]++] >>> 15 - i[s]);
  return o;
}, jc = new Ii(288);
for (var Et = 0; Et < 144; ++Et)
  jc[Et] = 8;
for (var Et = 144; Et < 256; ++Et)
  jc[Et] = 9;
for (var Et = 256; Et < 280; ++Et)
  jc[Et] = 7;
for (var Et = 280; Et < 288; ++Et)
  jc[Et] = 8;
var Mb = new Ii(32);
for (var Et = 0; Et < 32; ++Et)
  Mb[Et] = 5;
var EP = /* @__PURE__ */ ql(jc, 9, 1), AP = /* @__PURE__ */ ql(Mb, 5, 1), zf = function(i) {
  for (var e = i[0], t = 1; t < i.length; ++t)
    i[t] > e && (e = i[t]);
  return e;
}, ki = function(i, e, t) {
  var n = e / 8 | 0;
  return (i[n] | i[n + 1] << 8) >> (e & 7) & t;
}, Hf = function(i, e) {
  var t = e / 8 | 0;
  return (i[t] | i[t + 1] << 8 | i[t + 2] << 16) >> (e & 7);
}, CP = function(i) {
  return (i / 8 | 0) + (i & 7 && 1);
}, RP = function(i, e, t) {
  (t == null || t > i.length) && (t = i.length);
  var n = new (i instanceof pr ? pr : i instanceof am ? am : Ii)(t - e);
  return n.set(i.subarray(e, t)), n;
}, PP = function(i, e, t) {
  var n = i.length;
  if (!n || t && !t.l && n < 5)
    return e || new Ii(0);
  var s = !e || t, r = !t || t.i;
  t || (t = {}), e || (e = new Ii(n * 3));
  var a = function(Fe) {
    var ze = e.length;
    if (Fe > ze) {
      var Ne = new Ii(Math.max(ze * 2, Fe));
      Ne.set(e), e = Ne;
    }
  }, o = t.f || 0, l = t.p || 0, c = t.b || 0, h = t.l, u = t.d, d = t.m, f = t.n, m = n * 8;
  do {
    if (!h) {
      t.f = o = ki(i, l, 1);
      var g = ki(i, l + 1, 3);
      if (l += 3, g)
        if (g == 1)
          h = EP, u = AP, d = 9, f = 5;
        else if (g == 2) {
          var _ = ki(i, l, 31) + 257, x = ki(i, l + 10, 15) + 4, M = _ + ki(i, l + 5, 31) + 1;
          l += 14;
          for (var S = new Ii(M), w = new Ii(19), E = 0; E < x; ++E)
            w[bP[E]] = ki(i, l + E * 3, 7);
          l += x * 3;
          for (var b = zf(w), A = (1 << b) - 1, D = ql(w, b, 1), E = 0; E < M; ) {
            var B = D[ki(i, l, A)];
            l += B & 15;
            var p = B >>> 4;
            if (p < 16)
              S[E++] = p;
            else {
              var X = 0, L = 0;
              for (p == 16 ? (L = 3 + ki(i, l, 3), l += 2, X = S[E - 1]) : p == 17 ? (L = 3 + ki(i, l, 7), l += 3) : p == 18 && (L = 11 + ki(i, l, 127), l += 7); L--; )
                S[E++] = X;
            }
          }
          var F = S.subarray(0, _), H = S.subarray(_);
          d = zf(F), f = zf(H), h = ql(F, d, 1), u = ql(H, f, 1);
        } else
          throw "invalid block type";
      else {
        var p = CP(l) + 4, v = i[p - 4] | i[p - 3] << 8, y = p + v;
        if (y > n) {
          if (r)
            throw "unexpected EOF";
          break;
        }
        s && a(c + v), e.set(i.subarray(p, y), c), t.b = c += v, t.p = l = y * 8;
        continue;
      }
      if (l > m) {
        if (r)
          throw "unexpected EOF";
        break;
      }
    }
    s && a(c + 131072);
    for (var G = (1 << d) - 1, te = (1 << f) - 1, j = l; ; j = l) {
      var X = h[Hf(i, l) & G], J = X >>> 4;
      if (l += X & 15, l > m) {
        if (r)
          throw "unexpected EOF";
        break;
      }
      if (!X)
        throw "invalid length/literal";
      if (J < 256)
        e[c++] = J;
      else if (J == 256) {
        j = l, h = null;
        break;
      } else {
        var N = J - 254;
        if (J > 264) {
          var E = J - 257, q = gb[E];
          N = ki(i, l, (1 << q) - 1) + xb[E], l += q;
        }
        var ge = u[Hf(i, l) & te], de = ge >>> 4;
        if (!ge)
          throw "invalid distance";
        l += ge & 15;
        var H = TP[de];
        if (de > 3) {
          var q = vb[de];
          H += Hf(i, l) & (1 << q) - 1, l += q;
        }
        if (l > m) {
          if (r)
            throw "unexpected EOF";
          break;
        }
        s && a(c + 131072);
        for (var be = c + N; c < be; c += 4)
          e[c] = e[c - H], e[c + 1] = e[c + 1 - H], e[c + 2] = e[c + 2 - H], e[c + 3] = e[c + 3 - H];
        c = be;
      }
    }
    t.l = h, t.p = j, t.b = c, h && (o = 1, t.m = d, t.d = u, t.n = f);
  } while (!o);
  return c == e.length ? e : RP(e, 0, c);
}, LP = /* @__PURE__ */ new Ii(0), IP = function(i) {
  if ((i[0] & 15) != 8 || i[0] >>> 4 > 7 || (i[0] << 8 | i[1]) % 31)
    throw "invalid zlib data";
  if (i[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function DP(i, e) {
  return PP((IP(i), i.subarray(2, -4)), e);
}
var OP = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), NP = 0;
try {
  OP.decode(LP, { stream: !0 }), NP = 1;
} catch {
}
function bb(i, e, t) {
  const n = t.length - i - 1;
  if (e >= t[n])
    return n - 1;
  if (e <= t[i])
    return i;
  let s = i, r = n, a = Math.floor((s + r) / 2);
  for (; e < t[a] || e >= t[a + 1]; )
    e < t[a] ? r = a : s = a, a = Math.floor((s + r) / 2);
  return a;
}
function UP(i, e, t, n) {
  const s = [], r = [], a = [];
  s[0] = 1;
  for (let o = 1; o <= t; ++o) {
    r[o] = e - n[i + 1 - o], a[o] = n[i + o] - e;
    let l = 0;
    for (let c = 0; c < o; ++c) {
      const h = a[c + 1], u = r[o - c], d = s[c] / (h + u);
      s[c] = l + h * d, l = u * d;
    }
    s[o] = l;
  }
  return s;
}
function FP(i, e, t, n) {
  const s = bb(i, n, e), r = UP(s, n, i, e), a = new tt(0, 0, 0, 0);
  for (let o = 0; o <= i; ++o) {
    const l = t[s - i + o], c = r[o], h = l.w * c;
    a.x += l.x * h, a.y += l.y * h, a.z += l.z * h, a.w += l.w * c;
  }
  return a;
}
function BP(i, e, t, n, s) {
  const r = [];
  for (let u = 0; u <= t; ++u)
    r[u] = 0;
  const a = [];
  for (let u = 0; u <= n; ++u)
    a[u] = r.slice(0);
  const o = [];
  for (let u = 0; u <= t; ++u)
    o[u] = r.slice(0);
  o[0][0] = 1;
  const l = r.slice(0), c = r.slice(0);
  for (let u = 1; u <= t; ++u) {
    l[u] = e - s[i + 1 - u], c[u] = s[i + u] - e;
    let d = 0;
    for (let f = 0; f < u; ++f) {
      const m = c[f + 1], g = l[u - f];
      o[u][f] = m + g;
      const p = o[f][u - 1] / o[u][f];
      o[f][u] = d + m * p, d = g * p;
    }
    o[u][u] = d;
  }
  for (let u = 0; u <= t; ++u)
    a[0][u] = o[u][t];
  for (let u = 0; u <= t; ++u) {
    let d = 0, f = 1;
    const m = [];
    for (let g = 0; g <= t; ++g)
      m[g] = r.slice(0);
    m[0][0] = 1;
    for (let g = 1; g <= n; ++g) {
      let p = 0;
      const v = u - g, y = t - g;
      u >= g && (m[f][0] = m[d][0] / o[y + 1][v], p = m[f][0] * o[v][y]);
      const _ = v >= -1 ? 1 : -v, x = u - 1 <= y ? g - 1 : t - u;
      for (let S = _; S <= x; ++S)
        m[f][S] = (m[d][S] - m[d][S - 1]) / o[y + 1][v + S], p += m[f][S] * o[v + S][y];
      u <= y && (m[f][g] = -m[d][g - 1] / o[y + 1][u], p += m[f][g] * o[u][y]), a[g][u] = p;
      const M = d;
      d = f, f = M;
    }
  }
  let h = t;
  for (let u = 1; u <= n; ++u) {
    for (let d = 0; d <= t; ++d)
      a[u][d] *= h;
    h *= t - u;
  }
  return a;
}
function kP(i, e, t, n, s) {
  const r = s < i ? s : i, a = [], o = bb(i, n, e), l = BP(o, n, i, r, e), c = [];
  for (let h = 0; h < t.length; ++h) {
    const u = t[h].clone(), d = u.w;
    u.x *= d, u.y *= d, u.z *= d, c[h] = u;
  }
  for (let h = 0; h <= r; ++h) {
    const u = c[o - i].clone().multiplyScalar(l[h][0]);
    for (let d = 1; d <= i; ++d)
      u.add(c[o - i + d].clone().multiplyScalar(l[h][d]));
    a[h] = u;
  }
  for (let h = r + 1; h <= s + 1; ++h)
    a[h] = new tt(0, 0, 0);
  return a;
}
function zP(i, e) {
  let t = 1;
  for (let s = 2; s <= i; ++s)
    t *= s;
  let n = 1;
  for (let s = 2; s <= e; ++s)
    n *= s;
  for (let s = 2; s <= i - e; ++s)
    n *= s;
  return t / n;
}
function HP(i) {
  const e = i.length, t = [], n = [];
  for (let r = 0; r < e; ++r) {
    const a = i[r];
    t[r] = new T(a.x, a.y, a.z), n[r] = a.w;
  }
  const s = [];
  for (let r = 0; r < e; ++r) {
    const a = t[r].clone();
    for (let o = 1; o <= r; ++o)
      a.sub(s[r - o].clone().multiplyScalar(zP(r, o) * n[o]));
    s[r] = a.divideScalar(n[0]);
  }
  return s;
}
function GP(i, e, t, n, s) {
  const r = kP(i, e, t, n, s);
  return HP(r);
}
class VP extends Oi {
  constructor(e, t, n, s, r) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = s || 0, this.endKnot = r || this.knots.length - 1;
    for (let a = 0; a < n.length; ++a) {
      const o = n[a];
      this.controlPoints[a] = new tt(o.x, o.y, o.z, o.w);
    }
  }
  getPoint(e, t = new T()) {
    const n = t, s = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), r = FP(this.degree, this.knots, this.controlPoints, s);
    return r.w !== 1 && r.divideScalar(r.w), n.set(r.x, r.y, r.z);
  }
  getTangent(e, t = new T()) {
    const n = t, s = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), r = GP(this.degree, this.knots, this.controlPoints, s, 1);
    return n.copy(r[1]).normalize(), n;
  }
}
let st, Yt, Yn;
class WP extends Vt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const r = this, a = r.path === "" ? Pr.extractUrlBase(e) : r.path, o = new En(this.manager);
    o.setPath(r.path), o.setResponseType("arraybuffer"), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(e, function(l) {
      try {
        t(r.parse(l, a));
      } catch (c) {
        s ? s(c) : console.error(c), r.manager.itemError(e);
      }
    }, n, s);
  }
  parse(e, t) {
    if ($P(e))
      st = new ZP().parse(e);
    else {
      const s = Eb(e);
      if (!KP(s))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (h_(s) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + h_(s));
      st = new jP().parse(s);
    }
    const n = new Ys(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new XP(n, this.manager).parse(st);
  }
}
class XP {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    Yt = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), n = this.parseMaterials(t), s = this.parseDeformers(), r = new qP().parse(s);
    return this.parseScene(s, r, n), Yn;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in st && st.Connections.connections.forEach(function(n) {
      const s = n[0], r = n[1], a = n[2];
      e.has(s) || e.set(s, {
        parents: [],
        children: []
      });
      const o = { ID: r, relationship: a };
      e.get(s).parents.push(o), e.has(r) || e.set(r, {
        parents: [],
        children: []
      });
      const l = { ID: s, relationship: a };
      e.get(r).children.push(l);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in st.Objects) {
      const n = st.Objects.Video;
      for (const s in n) {
        const r = n[s], a = parseInt(s);
        if (e[a] = r.RelativeFilename || r.Filename, "Content" in r) {
          const o = r.Content instanceof ArrayBuffer && r.Content.byteLength > 0, l = typeof r.Content == "string" && r.Content !== "";
          if (o || l) {
            const c = this.parseImage(n[s]);
            t[r.RelativeFilename || r.Filename] = c;
          }
        }
      }
    }
    for (const n in e) {
      const s = e[n];
      t[s] !== void 0 ? e[n] = t[s] : e[n] = e[n].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, n = e.RelativeFilename || e.Filename, s = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
    let r;
    switch (s) {
      case "bmp":
        r = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        r = "image/jpeg";
        break;
      case "png":
        r = "image/png";
        break;
      case "tif":
        r = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", n), r = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + s + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + r + ";base64," + t;
    {
      const a = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([a], { type: r }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in st.Objects) {
      const n = st.Objects.Texture;
      for (const s in n) {
        const r = this.parseTexture(n[s], e);
        t.set(parseInt(s), r);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const n = this.loadTexture(e, t);
    n.ID = e.id, n.name = e.attrName;
    const s = e.WrapModeU, r = e.WrapModeV, a = s !== void 0 ? s.value : 0, o = r !== void 0 ? r.value : 0;
    if (n.wrapS = a === 0 ? Tn : Kt, n.wrapT = o === 0 ? Tn : Kt, "Scaling" in e) {
      const l = e.Scaling.value;
      n.repeat.x = l[0], n.repeat.y = l[1];
    }
    if ("Translation" in e) {
      const l = e.Translation.value;
      n.offset.x = l[0], n.offset.y = l[1];
    }
    return n;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    let n;
    const s = this.textureLoader.path, r = Yt.get(e.id).children;
    r !== void 0 && r.length > 0 && t[r[0].ID] !== void 0 && (n = t[r[0].ID], (n.indexOf("blob:") === 0 || n.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
    let a;
    const o = e.FileName.slice(-3).toLowerCase();
    if (o === "tga") {
      const l = this.manager.getHandler(".tga");
      l === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), a = new At()) : (l.setPath(this.textureLoader.path), a = l.load(n));
    } else o === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), a = new At()) : a = this.textureLoader.load(n);
    return this.textureLoader.setPath(s), a;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in st.Objects) {
      const n = st.Objects.Material;
      for (const s in n) {
        const r = this.parseMaterial(n[s], e);
        r !== null && t.set(parseInt(s), r);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const n = e.id, s = e.attrName;
    let r = e.ShadingModel;
    if (typeof r == "object" && (r = r.value), !Yt.has(n)) return null;
    const a = this.parseParameters(e, t, n);
    let o;
    switch (r.toLowerCase()) {
      case "phong":
        o = new yr();
        break;
      case "lambert":
        o = new Od();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', r), o = new yr();
        break;
    }
    return o.setValues(a), o.name = s, o;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, n) {
    const s = {};
    e.BumpFactor && (s.bumpScale = e.BumpFactor.value), e.Diffuse ? s.color = new Q().fromArray(e.Diffuse.value).convertSRGBToLinear() : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (s.color = new Q().fromArray(e.DiffuseColor.value).convertSRGBToLinear()), e.DisplacementFactor && (s.displacementScale = e.DisplacementFactor.value), e.Emissive ? s.emissive = new Q().fromArray(e.Emissive.value).convertSRGBToLinear() : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (s.emissive = new Q().fromArray(e.EmissiveColor.value).convertSRGBToLinear()), e.EmissiveFactor && (s.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (s.opacity = parseFloat(e.Opacity.value)), s.opacity < 1 && (s.transparent = !0), e.ReflectionFactor && (s.reflectivity = e.ReflectionFactor.value), e.Shininess && (s.shininess = e.Shininess.value), e.Specular ? s.specular = new Q().fromArray(e.Specular.value).convertSRGBToLinear() : e.SpecularColor && e.SpecularColor.type === "Color" && (s.specular = new Q().fromArray(e.SpecularColor.value).convertSRGBToLinear());
    const r = this;
    return Yt.get(n).children.forEach(function(a) {
      const o = a.relationship;
      switch (o) {
        case "Bump":
          s.bumpMap = r.getTexture(t, a.ID);
          break;
        case "Maya|TEX_ao_map":
          s.aoMap = r.getTexture(t, a.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          s.map = r.getTexture(t, a.ID), s.map !== void 0 && (s.map.colorSpace = ft);
          break;
        case "DisplacementColor":
          s.displacementMap = r.getTexture(t, a.ID);
          break;
        case "EmissiveColor":
          s.emissiveMap = r.getTexture(t, a.ID), s.emissiveMap !== void 0 && (s.emissiveMap.colorSpace = ft);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          s.normalMap = r.getTexture(t, a.ID);
          break;
        case "ReflectionColor":
          s.envMap = r.getTexture(t, a.ID), s.envMap !== void 0 && (s.envMap.mapping = ko, s.envMap.colorSpace = ft);
          break;
        case "SpecularColor":
          s.specularMap = r.getTexture(t, a.ID), s.specularMap !== void 0 && (s.specularMap.colorSpace = ft);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          s.alphaMap = r.getTexture(t, a.ID), s.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", o);
          break;
      }
    }), s;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in st.Objects && t in st.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = Yt.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in st.Objects) {
      const n = st.Objects.Deformer;
      for (const s in n) {
        const r = n[s], a = Yt.get(parseInt(s));
        if (r.attrType === "Skin") {
          const o = this.parseSkeleton(a, n);
          o.ID = s, a.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), o.geometryID = a.parents[0].ID, e[s] = o;
        } else if (r.attrType === "BlendShape") {
          const o = {
            id: s
          };
          o.rawTargets = this.parseMorphTargets(a, n), o.id = s, a.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[s] = o;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const n = [];
    return e.children.forEach(function(s) {
      const r = t[s.ID];
      if (r.attrType !== "Cluster") return;
      const a = {
        ID: s.ID,
        indices: [],
        weights: [],
        transformLink: new _e().fromArray(r.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in r && (a.indices = r.Indexes.a, a.weights = r.Weights.a), n.push(a);
    }), {
      rawBones: n,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const n = [];
    for (let s = 0; s < e.children.length; s++) {
      const r = e.children[s], a = t[r.ID], o = {
        name: a.attrName,
        initialWeight: a.DeformPercent,
        id: a.id,
        fullWeights: a.FullWeights.a
      };
      if (a.attrType !== "BlendShapeChannel") return;
      o.geoID = Yt.get(parseInt(r.ID)).children.filter(function(l) {
        return l.relationship === void 0;
      })[0].ID, n.push(o);
    }
    return n;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, n) {
    Yn = new Gn();
    const s = this.parseModels(e.skeletons, t, n), r = st.Objects.Model, a = this;
    s.forEach(function(l) {
      const c = r[l.ID];
      a.setLookAtProperties(l, c), Yt.get(l.ID).parents.forEach(function(u) {
        const d = s.get(u.ID);
        d !== void 0 && d.add(l);
      }), l.parent === null && Yn.add(l);
    }), this.bindSkeleton(e.skeletons, t, s), this.createAmbientLight(), Yn.traverse(function(l) {
      if (l.userData.transformData) {
        l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix, l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);
        const c = wb(l.userData.transformData);
        l.applyMatrix4(c), l.updateWorldMatrix();
      }
    });
    const o = new YP().parse();
    Yn.children.length === 1 && Yn.children[0].isGroup && (Yn.children[0].animations = o, Yn = Yn.children[0]), Yn.animations = o;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, n) {
    const s = /* @__PURE__ */ new Map(), r = st.Objects.Model;
    for (const a in r) {
      const o = parseInt(a), l = r[a], c = Yt.get(o);
      let h = this.buildSkeleton(c, e, o, l.attrName);
      if (!h) {
        switch (l.attrType) {
          case "Camera":
            h = this.createCamera(c);
            break;
          case "Light":
            h = this.createLight(c);
            break;
          case "Mesh":
            h = this.createMesh(c, t, n);
            break;
          case "NurbsCurve":
            h = this.createCurve(c, t);
            break;
          case "LimbNode":
          case "Root":
            h = new Vo();
            break;
          case "Null":
          default:
            h = new Gn();
            break;
        }
        h.name = l.attrName ? it.sanitizeNodeName(l.attrName) : "", h.userData.originalName = l.attrName, h.ID = o;
      }
      this.getTransformData(h, l), s.set(o, h);
    }
    return s;
  }
  buildSkeleton(e, t, n, s) {
    let r = null;
    return e.parents.forEach(function(a) {
      for (const o in t) {
        const l = t[o];
        l.rawBones.forEach(function(c, h) {
          if (c.ID === a.ID) {
            const u = r;
            r = new Vo(), r.matrixWorld.copy(c.transformLink), r.name = s ? it.sanitizeNodeName(s) : "", r.userData.originalName = s, r.ID = n, l.bones[h] = r, u !== null && r.add(u);
          }
        });
      }
    }), r;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, n;
    if (e.children.forEach(function(s) {
      const r = st.Objects.NodeAttribute[s.ID];
      r !== void 0 && (n = r);
    }), n === void 0)
      t = new Ze();
    else {
      let s = 0;
      n.CameraProjectionType !== void 0 && n.CameraProjectionType.value === 1 && (s = 1);
      let r = 1;
      n.NearPlane !== void 0 && (r = n.NearPlane.value / 1e3);
      let a = 1e3;
      n.FarPlane !== void 0 && (a = n.FarPlane.value / 1e3);
      let o = window.innerWidth, l = window.innerHeight;
      n.AspectWidth !== void 0 && n.AspectHeight !== void 0 && (o = n.AspectWidth.value, l = n.AspectHeight.value);
      const c = o / l;
      let h = 45;
      n.FieldOfView !== void 0 && (h = n.FieldOfView.value);
      const u = n.FocalLength ? n.FocalLength.value : null;
      switch (s) {
        case 0:
          t = new Zt(h, c, r, a), u !== null && t.setFocalLength(u);
          break;
        case 1:
          t = new Na(-o / 2, o / 2, l / 2, -l / 2, r, a);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + s + "."), t = new Ze();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, n;
    if (e.children.forEach(function(s) {
      const r = st.Objects.NodeAttribute[s.ID];
      r !== void 0 && (n = r);
    }), n === void 0)
      t = new Ze();
    else {
      let s;
      n.LightType === void 0 ? s = 0 : s = n.LightType.value;
      let r = 16777215;
      n.Color !== void 0 && (r = new Q().fromArray(n.Color.value).convertSRGBToLinear());
      let a = n.Intensity === void 0 ? 1 : n.Intensity.value / 100;
      n.CastLightOnObject !== void 0 && n.CastLightOnObject.value === 0 && (a = 0);
      let o = 0;
      n.FarAttenuationEnd !== void 0 && (n.EnableFarAttenuation !== void 0 && n.EnableFarAttenuation.value === 0 ? o = 0 : o = n.FarAttenuationEnd.value);
      const l = 1;
      switch (s) {
        case 0:
          t = new Xo(r, a, o, l);
          break;
        case 1:
          t = new Xc(r, a);
          break;
        case 2:
          let c = Math.PI / 3;
          n.InnerAngle !== void 0 && (c = Kn.degToRad(n.InnerAngle.value));
          let h = 0;
          n.OuterAngle !== void 0 && (h = Kn.degToRad(n.OuterAngle.value), h = Math.max(h, 1)), t = new Wc(r, a, o, c, h, l);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."), t = new Xo(r, a);
          break;
      }
      n.CastShadows !== void 0 && n.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, n) {
    let s, r = null, a = null;
    const o = [];
    return e.children.forEach(function(l) {
      t.has(l.ID) && (r = t.get(l.ID)), n.has(l.ID) && o.push(n.get(l.ID));
    }), o.length > 1 ? a = o : o.length > 0 ? a = o[0] : (a = new yr({
      name: Vt.DEFAULT_MATERIAL_NAME,
      color: 13421772
    }), o.push(a)), "color" in r.attributes && o.forEach(function(l) {
      l.vertexColors = !0;
    }), r.FBX_Deformer ? (s = new Sd(r, a), s.normalizeSkinWeights()) : s = new le(r, a), s;
  }
  createCurve(e, t) {
    const n = e.children.reduce(function(r, a) {
      return t.has(a.ID) && (r = t.get(a.ID)), r;
    }, null), s = new Jt({
      name: Vt.DEFAULT_MATERIAL_NAME,
      color: 3342591,
      linewidth: 1
    });
    return new pn(n, s);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const n = {};
    "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? n.eulerOrder = Tb(t.RotationOrder.value) : n.eulerOrder = "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && Yt.get(e.ID).children.forEach(function(s) {
      if (s.relationship === "LookAtProperty") {
        const r = st.Objects.Model[s.ID];
        if ("Lcl_Translation" in r) {
          const a = r.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(a), Yn.add(e.target)) : e.lookAt(new T().fromArray(a));
        }
      }
    });
  }
  bindSkeleton(e, t, n) {
    const s = this.parsePoseNodes();
    for (const r in e) {
      const a = e[r];
      Yt.get(parseInt(a.ID)).parents.forEach(function(l) {
        if (t.has(l.ID)) {
          const c = l.ID;
          Yt.get(c).parents.forEach(function(u) {
            n.has(u.ID) && n.get(u.ID).bind(new rl(a.bones), s[u.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in st.Objects) {
      const t = st.Objects.Pose;
      for (const n in t)
        if (t[n].attrType === "BindPose" && t[n].NbPoseNodes > 0) {
          const s = t[n].PoseNode;
          Array.isArray(s) ? s.forEach(function(r) {
            e[r.Node] = new _e().fromArray(r.Matrix.a);
          }) : e[s.Node] = new _e().fromArray(s.Matrix.a);
        }
    }
    return e;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in st && "AmbientColor" in st.GlobalSettings) {
      const e = st.GlobalSettings.AmbientColor.value, t = e[0], n = e[1], s = e[2];
      if (t !== 0 || n !== 0 || s !== 0) {
        const r = new Q(t, n, s).convertSRGBToLinear();
        Yn.add(new Nd(r, 1));
      }
    }
  }
}
class qP {
  constructor() {
    this.negativeMaterialIndices = !1;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in st.Objects) {
      const n = st.Objects.Geometry;
      for (const s in n) {
        const r = Yt.get(parseInt(s)), a = this.parseGeometry(r, n[s], e);
        t.set(parseInt(s), a);
      }
    }
    return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, n) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, n);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, n) {
    const s = n.skeletons, r = [], a = e.parents.map(function(u) {
      return st.Objects.Model[u.ID];
    });
    if (a.length === 0) return;
    const o = e.children.reduce(function(u, d) {
      return s[d.ID] !== void 0 && (u = s[d.ID]), u;
    }, null);
    e.children.forEach(function(u) {
      n.morphTargets[u.ID] !== void 0 && r.push(n.morphTargets[u.ID]);
    });
    const l = a[0], c = {};
    "RotationOrder" in l && (c.eulerOrder = Tb(l.RotationOrder.value)), "InheritType" in l && (c.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (c.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (c.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (c.scale = l.GeometricScaling.value);
    const h = wb(c);
    return this.genGeometry(t, o, r, h);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, n, s) {
    const r = new Be();
    e.attrName && (r.name = e.attrName);
    const a = this.parseGeoNode(e, t), o = this.genBuffers(a), l = new ye(o.vertex, 3);
    if (l.applyMatrix4(s), r.setAttribute("position", l), o.colors.length > 0 && r.setAttribute("color", new ye(o.colors, 3)), t && (r.setAttribute("skinIndex", new vd(o.weightsIndices, 4)), r.setAttribute("skinWeight", new ye(o.vertexWeights, 4)), r.FBX_Deformer = t), o.normal.length > 0) {
      const c = new Qe().getNormalMatrix(s), h = new ye(o.normal, 3);
      h.applyNormalMatrix(c), r.setAttribute("normal", h);
    }
    if (o.uvs.forEach(function(c, h) {
      const u = h === 0 ? "uv" : `uv${h}`;
      r.setAttribute(u, new ye(o.uvs[h], 2));
    }), a.material && a.material.mappingType !== "AllSame") {
      let c = o.materialIndex[0], h = 0;
      if (o.materialIndex.forEach(function(u, d) {
        u !== c && (r.addGroup(h, d - h, c), c = u, h = d);
      }), r.groups.length > 0) {
        const u = r.groups[r.groups.length - 1], d = u.start + u.count;
        d !== o.materialIndex.length && r.addGroup(d, o.materialIndex.length - d, c);
      }
      r.groups.length === 0 && r.addGroup(0, o.materialIndex.length, o.materialIndex[0]);
    }
    return this.addMorphTargets(r, e, n, s), r;
  }
  parseGeoNode(e, t) {
    const n = {};
    if (n.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], n.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      n.uv = [];
      let s = 0;
      for (; e.LayerElementUV[s]; )
        e.LayerElementUV[s].UV && n.uv.push(this.parseUVs(e.LayerElementUV[s])), s++;
    }
    return n.weightTable = {}, t !== null && (n.skeleton = t, t.rawBones.forEach(function(s, r) {
      s.indices.forEach(function(a, o) {
        n.weightTable[a] === void 0 && (n.weightTable[a] = []), n.weightTable[a].push({
          id: r,
          weight: s.weights[o]
        });
      });
    })), n;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let n = 0, s = 0, r = !1, a = [], o = [], l = [], c = [], h = [], u = [];
    const d = this;
    return e.vertexIndices.forEach(function(f, m) {
      let g, p = !1;
      f < 0 && (f = f ^ -1, p = !0);
      let v = [], y = [];
      if (a.push(f * 3, f * 3 + 1, f * 3 + 2), e.color) {
        const _ = Zh(m, n, f, e.color);
        l.push(_[0], _[1], _[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[f] !== void 0 && e.weightTable[f].forEach(function(_) {
          y.push(_.weight), v.push(_.id);
        }), y.length > 4) {
          r || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), r = !0);
          const _ = [0, 0, 0, 0], x = [0, 0, 0, 0];
          y.forEach(function(M, S) {
            let w = M, E = v[S];
            x.forEach(function(b, A, D) {
              if (w > b) {
                D[A] = w, w = b;
                const B = _[A];
                _[A] = E, E = B;
              }
            });
          }), v = _, y = x;
        }
        for (; y.length < 4; )
          y.push(0), v.push(0);
        for (let _ = 0; _ < 4; ++_)
          h.push(y[_]), u.push(v[_]);
      }
      if (e.normal) {
        const _ = Zh(m, n, f, e.normal);
        o.push(_[0], _[1], _[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (g = Zh(m, n, f, e.material)[0], g < 0 && (d.negativeMaterialIndices = !0, g = 0)), e.uv && e.uv.forEach(function(_, x) {
        const M = Zh(m, n, f, _);
        c[x] === void 0 && (c[x] = []), c[x].push(M[0]), c[x].push(M[1]);
      }), s++, p && (s > 4 && console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."), d.genFace(t, e, a, g, o, l, c, h, u, s), n++, s = 0, a = [], o = [], l = [], c = [], h = [], u = []);
    }), t;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, n, s, r, a, o, l, c, h) {
    for (let u = 2; u < h; u++)
      e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[(u - 1) * 3]]), e.vertex.push(t.vertexPositions[n[(u - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[n[(u - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[n[u * 3]]), e.vertex.push(t.vertexPositions[n[u * 3 + 1]]), e.vertex.push(t.vertexPositions[n[u * 3 + 2]]), t.skeleton && (e.vertexWeights.push(l[0]), e.vertexWeights.push(l[1]), e.vertexWeights.push(l[2]), e.vertexWeights.push(l[3]), e.vertexWeights.push(l[(u - 1) * 4]), e.vertexWeights.push(l[(u - 1) * 4 + 1]), e.vertexWeights.push(l[(u - 1) * 4 + 2]), e.vertexWeights.push(l[(u - 1) * 4 + 3]), e.vertexWeights.push(l[u * 4]), e.vertexWeights.push(l[u * 4 + 1]), e.vertexWeights.push(l[u * 4 + 2]), e.vertexWeights.push(l[u * 4 + 3]), e.weightsIndices.push(c[0]), e.weightsIndices.push(c[1]), e.weightsIndices.push(c[2]), e.weightsIndices.push(c[3]), e.weightsIndices.push(c[(u - 1) * 4]), e.weightsIndices.push(c[(u - 1) * 4 + 1]), e.weightsIndices.push(c[(u - 1) * 4 + 2]), e.weightsIndices.push(c[(u - 1) * 4 + 3]), e.weightsIndices.push(c[u * 4]), e.weightsIndices.push(c[u * 4 + 1]), e.weightsIndices.push(c[u * 4 + 2]), e.weightsIndices.push(c[u * 4 + 3])), t.color && (e.colors.push(a[0]), e.colors.push(a[1]), e.colors.push(a[2]), e.colors.push(a[(u - 1) * 3]), e.colors.push(a[(u - 1) * 3 + 1]), e.colors.push(a[(u - 1) * 3 + 2]), e.colors.push(a[u * 3]), e.colors.push(a[u * 3 + 1]), e.colors.push(a[u * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(s), e.materialIndex.push(s), e.materialIndex.push(s)), t.normal && (e.normal.push(r[0]), e.normal.push(r[1]), e.normal.push(r[2]), e.normal.push(r[(u - 1) * 3]), e.normal.push(r[(u - 1) * 3 + 1]), e.normal.push(r[(u - 1) * 3 + 2]), e.normal.push(r[u * 3]), e.normal.push(r[u * 3 + 1]), e.normal.push(r[u * 3 + 2])), t.uv && t.uv.forEach(function(d, f) {
        e.uvs[f] === void 0 && (e.uvs[f] = []), e.uvs[f].push(o[f][0]), e.uvs[f].push(o[f][1]), e.uvs[f].push(o[f][(u - 1) * 2]), e.uvs[f].push(o[f][(u - 1) * 2 + 1]), e.uvs[f].push(o[f][u * 2]), e.uvs[f].push(o[f][u * 2 + 1]);
      });
  }
  addMorphTargets(e, t, n, s) {
    if (n.length === 0) return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const r = this;
    n.forEach(function(a) {
      a.rawTargets.forEach(function(o) {
        const l = st.Objects.Geometry[o.geoID];
        l !== void 0 && r.genMorphGeometry(e, t, l, s, o.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, n, s, r) {
    const a = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], o = n.Vertices !== void 0 ? n.Vertices.a : [], l = n.Indexes !== void 0 ? n.Indexes.a : [], c = e.attributes.position.count * 3, h = new Float32Array(c);
    for (let m = 0; m < l.length; m++) {
      const g = l[m] * 3;
      h[g] = o[m * 3], h[g + 1] = o[m * 3 + 1], h[g + 2] = o[m * 3 + 2];
    }
    const u = {
      vertexIndices: a,
      vertexPositions: h
    }, d = this.genBuffers(u), f = new ye(d.vertex, 3);
    f.name = r || n.attrName, f.applyMatrix4(s), e.morphAttributes.position.push(f);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.Normals.a;
    let r = [];
    return n === "IndexToDirect" && ("NormalIndex" in e ? r = e.NormalIndex.a : "NormalsIndex" in e && (r = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: s,
      indices: r,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.UV.a;
    let r = [];
    return n === "IndexToDirect" && (r = e.UVIndex.a), {
      dataSize: 2,
      buffer: s,
      indices: r,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.Colors.a;
    let r = [];
    n === "IndexToDirect" && (r = e.ColorIndex.a);
    for (let a = 0, o = new Q(); a < s.length; a += 4)
      o.fromArray(s, a).convertSRGBToLinear().toArray(s, a);
    return {
      dataSize: 4,
      buffer: s,
      indices: r,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: n
      };
    const s = e.Materials.a, r = [];
    for (let a = 0; a < s.length; ++a)
      r.push(a);
    return {
      dataSize: 1,
      buffer: s,
      indices: r,
      mappingType: t,
      referenceType: n
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new Be();
    const n = t - 1, s = e.KnotVector.a, r = [], a = e.Points.a;
    for (let u = 0, d = a.length; u < d; u += 4)
      r.push(new tt().fromArray(a, u));
    let o, l;
    if (e.Form === "Closed")
      r.push(r[0]);
    else if (e.Form === "Periodic") {
      o = n, l = s.length - 1 - o;
      for (let u = 0; u < n; ++u)
        r.push(r[u]);
    }
    const h = new VP(n, s, r, o, l).getPoints(r.length * 12);
    return new Be().setFromPoints(h);
  }
}
class YP {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const n in t) {
        const s = t[n], r = this.addClip(s);
        e.push(r);
      }
    return e;
  }
  parseClips() {
    if (st.Objects.AnimationCurve === void 0) return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = st.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const n in e) {
      const s = e[n];
      if (s.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const r = {
          id: s.id,
          attr: s.attrName,
          curves: {}
        };
        t.set(r.id, r);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = st.Objects.AnimationCurve;
    for (const n in t) {
      const s = {
        id: t[n].id,
        times: t[n].KeyTime.a.map(QP),
        values: t[n].KeyValueFloat.a
      }, r = Yt.get(s.id);
      if (r !== void 0) {
        const a = r.parents[0].ID, o = r.parents[0].relationship;
        o.match(/X/) ? e.get(a).curves.x = s : o.match(/Y/) ? e.get(a).curves.y = s : o.match(/Z/) ? e.get(a).curves.z = s : o.match(/DeformPercent/) && e.has(a) && (e.get(a).curves.morph = s);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = st.Objects.AnimationLayer, n = /* @__PURE__ */ new Map();
    for (const s in t) {
      const r = [], a = Yt.get(parseInt(s));
      a !== void 0 && (a.children.forEach(function(l, c) {
        if (e.has(l.ID)) {
          const h = e.get(l.ID);
          if (h.curves.x !== void 0 || h.curves.y !== void 0 || h.curves.z !== void 0) {
            if (r[c] === void 0) {
              const u = Yt.get(l.ID).parents.filter(function(d) {
                return d.relationship !== void 0;
              })[0].ID;
              if (u !== void 0) {
                const d = st.Objects.Model[u.toString()];
                if (d === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", l);
                  return;
                }
                const f = {
                  modelName: d.attrName ? it.sanitizeNodeName(d.attrName) : "",
                  ID: d.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                Yn.traverse(function(m) {
                  m.ID === d.id && (f.transform = m.matrix, m.userData.transformData && (f.eulerOrder = m.userData.transformData.eulerOrder));
                }), f.transform || (f.transform = new _e()), "PreRotation" in d && (f.preRotation = d.PreRotation.value), "PostRotation" in d && (f.postRotation = d.PostRotation.value), r[c] = f;
              }
            }
            r[c] && (r[c][h.attr] = h);
          } else if (h.curves.morph !== void 0) {
            if (r[c] === void 0) {
              const u = Yt.get(l.ID).parents.filter(function(v) {
                return v.relationship !== void 0;
              })[0].ID, d = Yt.get(u).parents[0].ID, f = Yt.get(d).parents[0].ID, m = Yt.get(f).parents[0].ID, g = st.Objects.Model[m], p = {
                modelName: g.attrName ? it.sanitizeNodeName(g.attrName) : "",
                morphName: st.Objects.Deformer[u].attrName
              };
              r[c] = p;
            }
            r[c][h.attr] = h;
          }
        }
      }), n.set(parseInt(s), r));
    }
    return n;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = st.Objects.AnimationStack, n = {};
    for (const s in t) {
      const r = Yt.get(parseInt(s)).children;
      r.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      const a = e.get(r[0].ID);
      n[s] = {
        name: t[s].attrName,
        layer: a
      };
    }
    return n;
  }
  addClip(e) {
    let t = [];
    const n = this;
    return e.layer.forEach(function(s) {
      t = t.concat(n.generateTracks(s));
    }), new Ra(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let n = new T(), s = new pt(), r = new T();
    if (e.transform && e.transform.decompose(n, s, r), n = n.toArray(), s = new Jn().setFromQuaternion(s, e.eulerOrder).toArray(), r = r.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const a = this.generateVectorTrack(e.modelName, e.T.curves, n, "position");
      a !== void 0 && t.push(a);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const a = this.generateRotationTrack(e.modelName, e.R.curves, s, e.preRotation, e.postRotation, e.eulerOrder);
      a !== void 0 && t.push(a);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const a = this.generateVectorTrack(e.modelName, e.S.curves, r, "scale");
      a !== void 0 && t.push(a);
    }
    if (e.DeformPercent !== void 0) {
      const a = this.generateMorphTrack(e);
      a !== void 0 && t.push(a);
    }
    return t;
  }
  generateVectorTrack(e, t, n, s) {
    const r = this.getTimesForAllAxes(t), a = this.getKeyframeTrackValues(r, t, n);
    return new Rr(e + "." + s, r, a);
  }
  generateRotationTrack(e, t, n, s, r, a) {
    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(Kn.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(Kn.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(Kn.degToRad));
    const o = this.getTimesForAllAxes(t), l = this.getKeyframeTrackValues(o, t, n);
    s !== void 0 && (s = s.map(Kn.degToRad), s.push(a), s = new Jn().fromArray(s), s = new pt().setFromEuler(s)), r !== void 0 && (r = r.map(Kn.degToRad), r.push(a), r = new Jn().fromArray(r), r = new pt().setFromEuler(r).invert());
    const c = new pt(), h = new Jn(), u = [];
    for (let d = 0; d < l.length; d += 3)
      h.set(l[d], l[d + 1], l[d + 2], a), c.setFromEuler(h), s !== void 0 && c.premultiply(s), r !== void 0 && c.multiply(r), c.toArray(u, d / 3 * 4);
    return new Ws(e + ".quaternion", o, u);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, n = t.values.map(function(r) {
      return r / 100;
    }), s = Yn.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new Cr(e.modelName + ".morphTargetInfluences[" + s + "]", t.times, n);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(n, s) {
      return n - s;
    }), t.length > 1) {
      let n = 1, s = t[0];
      for (let r = 1; r < t.length; r++) {
        const a = t[r];
        a !== s && (t[n] = a, s = a, n++);
      }
      t = t.slice(0, n);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, n) {
    const s = n, r = [];
    let a = -1, o = -1, l = -1;
    return e.forEach(function(c) {
      if (t.x && (a = t.x.times.indexOf(c)), t.y && (o = t.y.times.indexOf(c)), t.z && (l = t.z.times.indexOf(c)), a !== -1) {
        const h = t.x.values[a];
        r.push(h), s[0] = h;
      } else
        r.push(s[0]);
      if (o !== -1) {
        const h = t.y.values[o];
        r.push(h), s[1] = h;
      } else
        r.push(s[1]);
      if (l !== -1) {
        const h = t.z.values[l];
        r.push(h), s[2] = h;
      } else
        r.push(s[2]);
    }), r;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e) {
    for (let t = 1; t < e.values.length; t++) {
      const n = e.values[t - 1], s = e.values[t] - n, r = Math.abs(s);
      if (r >= 180) {
        const a = r / 180, o = s / a;
        let l = n + o;
        const c = e.times[t - 1], u = (e.times[t] - c) / a;
        let d = c + u;
        const f = [], m = [];
        for (; d < e.times[t]; )
          f.push(d), d += u, m.push(l), l += o;
        e.times = u_(e.times, t, f), e.values = u_(e.values, t, m);
      }
    }
  }
}
class jP {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new Sb(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, n = e.split(/[\r\n]+/);
    return n.forEach(function(s, r) {
      const a = s.match(/^[\s\t]*;/), o = s.match(/^[\s\t]*$/);
      if (a || o) return;
      const l = s.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), c = s.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), h = s.match("^\\t{" + (t.currentIndent - 1) + "}}");
      l ? t.parseNodeBegin(s, l) : c ? t.parseNodeProperty(s, c, n[++r]) : h ? t.popStack() : s.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(s);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""), s = t[2].split(",").map(function(l) {
      return l.trim().replace(/^"/, "").replace(/"$/, "");
    }), r = { name: n }, a = this.parseNodeAttr(s), o = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(n, r) : n in o ? (n === "PoseNode" ? o.PoseNode.push(r) : o[n].id !== void 0 && (o[n] = {}, o[n][o[n].id] = o[n]), a.id !== "" && (o[n][a.id] = r)) : typeof a.id == "number" ? (o[n] = {}, o[n][a.id] = r) : n !== "Properties70" && (n === "PoseNode" ? o[n] = [r] : o[n] = r), typeof a.id == "number" && (r.id = a.id), a.name !== "" && (r.attrName = a.name), a.type !== "" && (r.attrType = a.type), this.pushStack(r);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let n = "", s = "";
    return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), s = e[2]), { id: t, name: n, type: s };
  }
  parseNodeProperty(e, t, n) {
    let s = t[1].replace(/^"/, "").replace(/"$/, "").trim(), r = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    s === "Content" && r === "," && (r = n.replace(/"/g, "").replace(/,$/, "").trim());
    const a = this.getCurrentNode();
    if (a.name === "Properties70") {
      this.parseNodeSpecialProperty(e, s, r);
      return;
    }
    if (s === "C") {
      const l = r.split(",").slice(1), c = parseInt(l[0]), h = parseInt(l[1]);
      let u = r.split(",").slice(3);
      u = u.map(function(d) {
        return d.trim().replace(/^"/, "");
      }), s = "connections", r = [c, h], e3(r, u), a[s] === void 0 && (a[s] = []);
    }
    s === "Node" && (a.id = r), s in a && Array.isArray(a[s]) ? a[s].push(r) : s !== "a" ? a[s] = r : a.a = r, this.setCurrentProp(a, s), s === "a" && r.slice(-1) !== "," && (a.a = Vf(r));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = Vf(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, n) {
    const s = n.split('",').map(function(h) {
      return h.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), r = s[0], a = s[1], o = s[2], l = s[3];
    let c = s[4];
    switch (a) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        c = parseFloat(c);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        c = Vf(c);
        break;
    }
    this.getPrevNode()[r] = {
      type: a,
      type2: o,
      flag: l,
      value: c
    }, this.setCurrentProp(this.getPrevNode(), r);
  }
}
class ZP {
  parse(e) {
    const t = new c_(e);
    t.skip(23);
    const n = t.getUint32();
    if (n < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
    const s = new Sb();
    for (; !this.endOfContent(t); ) {
      const r = this.parseNode(t, n);
      r !== null && s.add(r.name, r);
    }
    return s;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const n = {}, s = t >= 7500 ? e.getUint64() : e.getUint32(), r = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const a = e.getUint8(), o = e.getString(a);
    if (s === 0) return null;
    const l = [];
    for (let d = 0; d < r; d++)
      l.push(this.parseProperty(e));
    const c = l.length > 0 ? l[0] : "", h = l.length > 1 ? l[1] : "", u = l.length > 2 ? l[2] : "";
    for (n.singleProperty = r === 1 && e.getOffset() === s; s > e.getOffset(); ) {
      const d = this.parseNode(e, t);
      d !== null && this.parseSubNode(o, n, d);
    }
    return n.propertyList = l, typeof c == "number" && (n.id = c), h !== "" && (n.attrName = h), u !== "" && (n.attrType = u), o !== "" && (n.name = o), n;
  }
  parseSubNode(e, t, n) {
    if (n.singleProperty === !0) {
      const s = n.propertyList[0];
      Array.isArray(s) ? (t[n.name] = n, n.a = s) : t[n.name] = s;
    } else if (e === "Connections" && n.name === "C") {
      const s = [];
      n.propertyList.forEach(function(r, a) {
        a !== 0 && s.push(r);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(s);
    } else if (n.name === "Properties70")
      Object.keys(n).forEach(function(r) {
        t[r] = n[r];
      });
    else if (e === "Properties70" && n.name === "P") {
      let s = n.propertyList[0], r = n.propertyList[1];
      const a = n.propertyList[2], o = n.propertyList[3];
      let l;
      s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")), r.indexOf("Lcl ") === 0 && (r = r.replace("Lcl ", "Lcl_")), r === "Color" || r === "ColorRGB" || r === "Vector" || r === "Vector3D" || r.indexOf("Lcl_") === 0 ? l = [
        n.propertyList[4],
        n.propertyList[5],
        n.propertyList[6]
      ] : l = n.propertyList[4], t[s] = {
        type: r,
        type2: a,
        flag: o,
        value: l
      };
    } else t[n.name] === void 0 ? typeof n.id == "number" ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : n.name === "PoseNode" ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : t[n.name][n.id] === void 0 && (t[n.name][n.id] = n);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let n;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return n = e.getUint32(), e.getArrayBuffer(n);
      case "S":
        return n = e.getUint32(), e.getString(n);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const s = e.getUint32(), r = e.getUint32(), a = e.getUint32();
        if (r === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(s);
            case "d":
              return e.getFloat64Array(s);
            case "f":
              return e.getFloat32Array(s);
            case "i":
              return e.getInt32Array(s);
            case "l":
              return e.getInt64Array(s);
          }
        const o = DP(new Uint8Array(e.getArrayBuffer(a))), l = new c_(o.buffer);
        switch (t) {
          case "b":
          case "c":
            return l.getBooleanArray(s);
          case "d":
            return l.getFloat64Array(s);
          case "f":
            return l.getFloat32Array(s);
          case "i":
            return l.getInt32Array(s);
          case "l":
            return l.getInt64Array(s);
        }
        break;
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class c_ {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0, this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    const t = this.offset;
    let n = new Uint8Array(this.dv.buffer, t, e);
    this.skip(e);
    const s = n.indexOf(0);
    return s >= 0 && (n = new Uint8Array(this.dv.buffer, t, s)), this._textDecoder.decode(n);
  }
}
class Sb {
  add(e, t) {
    this[e] = t;
  }
}
function $P(i) {
  const e = "Kaydara FBX Binary  \0";
  return i.byteLength >= e.length && e === Eb(i, 0, e.length);
}
function KP(i) {
  const e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let t = 0;
  function n(s) {
    const r = i[s - 1];
    return i = i.slice(t + s), t++, r;
  }
  for (let s = 0; s < e.length; ++s)
    if (n(1) === e[s])
      return !1;
  return !0;
}
function h_(i) {
  const e = /FBXVersion: (\d+)/, t = i.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function QP(i) {
  return i / 46186158e3;
}
const JP = [];
function Zh(i, e, t, n) {
  let s;
  switch (n.mappingType) {
    case "ByPolygonVertex":
      s = i;
      break;
    case "ByPolygon":
      s = e;
      break;
    case "ByVertice":
      s = t;
      break;
    case "AllSame":
      s = n.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + n.mappingType);
  }
  n.referenceType === "IndexToDirect" && (s = n.indices[s]);
  const r = s * n.dataSize, a = r + n.dataSize;
  return t3(JP, n.buffer, r, a);
}
const Gf = new Jn(), co = new T();
function wb(i) {
  const e = new _e(), t = new _e(), n = new _e(), s = new _e(), r = new _e(), a = new _e(), o = new _e(), l = new _e(), c = new _e(), h = new _e(), u = new _e(), d = new _e(), f = i.inheritType ? i.inheritType : 0;
  if (i.translation && e.setPosition(co.fromArray(i.translation)), i.preRotation) {
    const A = i.preRotation.map(Kn.degToRad);
    A.push(i.eulerOrder || Jn.DEFAULT_ORDER), t.makeRotationFromEuler(Gf.fromArray(A));
  }
  if (i.rotation) {
    const A = i.rotation.map(Kn.degToRad);
    A.push(i.eulerOrder || Jn.DEFAULT_ORDER), n.makeRotationFromEuler(Gf.fromArray(A));
  }
  if (i.postRotation) {
    const A = i.postRotation.map(Kn.degToRad);
    A.push(i.eulerOrder || Jn.DEFAULT_ORDER), s.makeRotationFromEuler(Gf.fromArray(A)), s.invert();
  }
  i.scale && r.scale(co.fromArray(i.scale)), i.scalingOffset && o.setPosition(co.fromArray(i.scalingOffset)), i.scalingPivot && a.setPosition(co.fromArray(i.scalingPivot)), i.rotationOffset && l.setPosition(co.fromArray(i.rotationOffset)), i.rotationPivot && c.setPosition(co.fromArray(i.rotationPivot)), i.parentMatrixWorld && (u.copy(i.parentMatrix), h.copy(i.parentMatrixWorld));
  const m = t.clone().multiply(n).multiply(s), g = new _e();
  g.extractRotation(h);
  const p = new _e();
  p.copyPosition(h);
  const v = p.clone().invert().multiply(h), y = g.clone().invert().multiply(v), _ = r, x = new _e();
  if (f === 0)
    x.copy(g).multiply(m).multiply(y).multiply(_);
  else if (f === 1)
    x.copy(g).multiply(y).multiply(m).multiply(_);
  else {
    const D = new _e().scale(new T().setFromMatrixScale(u)).clone().invert(), B = y.clone().multiply(D);
    x.copy(g).multiply(m).multiply(B).multiply(_);
  }
  const M = c.clone().invert(), S = a.clone().invert();
  let w = e.clone().multiply(l).multiply(c).multiply(t).multiply(n).multiply(s).multiply(M).multiply(o).multiply(a).multiply(r).multiply(S);
  const E = new _e().copyPosition(w), b = h.clone().multiply(E);
  return d.copyPosition(b), w = d.clone().multiply(x), w.premultiply(h.invert()), w;
}
function Tb(i) {
  i = i || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return i === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[i];
}
function Vf(i) {
  return i.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function Eb(i, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = i.byteLength), new TextDecoder().decode(new Uint8Array(i, e, t));
}
function e3(i, e) {
  for (let t = 0, n = i.length, s = e.length; t < s; t++, n++)
    i[n] = e[t];
}
function t3(i, e, t, n) {
  for (let s = t, r = 0; s < n; s++, r++)
    i[r] = e[s];
  return i;
}
function u_(i, e, t) {
  return i.slice(0, e).concat(t).concat(i.slice(e));
}
function d_(i, e) {
  if (e === dx)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), i;
  if (e === Ru || e === zm) {
    let t = i.getIndex();
    if (t === null) {
      const a = [], o = i.getAttribute("position");
      if (o !== void 0) {
        for (let l = 0; l < o.count; l++)
          a.push(l);
        i.setIndex(a), t = i.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), i;
    }
    const n = t.count - 2, s = [];
    if (e === Ru)
      for (let a = 1; a <= n; a++)
        s.push(t.getX(0)), s.push(t.getX(a)), s.push(t.getX(a + 1));
    else
      for (let a = 0; a < n; a++)
        a % 2 === 0 ? (s.push(t.getX(a)), s.push(t.getX(a + 1)), s.push(t.getX(a + 2))) : (s.push(t.getX(a + 2)), s.push(t.getX(a + 1)), s.push(t.getX(a)));
    s.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const r = i.clone();
    return r.setIndex(s), r.clearGroups(), r;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), i;
}
class n3 extends Vt {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new o3(t);
    }), this.register(function(t) {
      return new m3(t);
    }), this.register(function(t) {
      return new g3(t);
    }), this.register(function(t) {
      return new v3(t);
    }), this.register(function(t) {
      return new c3(t);
    }), this.register(function(t) {
      return new h3(t);
    }), this.register(function(t) {
      return new u3(t);
    }), this.register(function(t) {
      return new d3(t);
    }), this.register(function(t) {
      return new a3(t);
    }), this.register(function(t) {
      return new f3(t);
    }), this.register(function(t) {
      return new l3(t);
    }), this.register(function(t) {
      return new p3(t);
    }), this.register(function(t) {
      return new s3(t);
    }), this.register(function(t) {
      return new _3(t);
    }), this.register(function(t) {
      return new y3(t);
    });
  }
  load(e, t, n, s) {
    const r = this;
    let a;
    this.resourcePath !== "" ? a = this.resourcePath : this.path !== "" ? a = this.path : a = Pr.extractUrlBase(e), this.manager.itemStart(e);
    const o = function(c) {
      s ? s(c) : console.error(c), r.manager.itemError(e), r.manager.itemEnd(e);
    }, l = new En(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
      try {
        r.parse(c, a, function(h) {
          t(h), r.manager.itemEnd(e);
        }, o);
      } catch (h) {
        o(h);
      }
    }, n, o);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, n, s) {
    let r;
    const a = {}, o = {}, l = new TextDecoder();
    if (typeof e == "string")
      r = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === Ab) {
        try {
          a[ht.KHR_BINARY_GLTF] = new x3(e);
        } catch (u) {
          s && s(u);
          return;
        }
        r = JSON.parse(a[ht.KHR_BINARY_GLTF].content);
      } else
        r = JSON.parse(l.decode(e));
    else
      r = e;
    if (r.asset === void 0 || r.asset.version[0] < 2) {
      s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const c = new D3(r, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const u = this.pluginCallbacks[h](c);
      u.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[u.name] = u, a[u.name] = !0;
    }
    if (r.extensionsUsed)
      for (let h = 0; h < r.extensionsUsed.length; ++h) {
        const u = r.extensionsUsed[h], d = r.extensionsRequired || [];
        switch (u) {
          case ht.KHR_MATERIALS_UNLIT:
            a[u] = new r3();
            break;
          case ht.KHR_DRACO_MESH_COMPRESSION:
            a[u] = new M3(r, this.dracoLoader);
            break;
          case ht.KHR_TEXTURE_TRANSFORM:
            a[u] = new b3();
            break;
          case ht.KHR_MESH_QUANTIZATION:
            a[u] = new S3();
            break;
          default:
            d.indexOf(u) >= 0 && o[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
        }
      }
    c.setExtensions(a), c.setPlugins(o), c.parse(n, s);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(s, r) {
      n.parse(e, t, s, r);
    });
  }
}
function i3() {
  let i = {};
  return {
    get: function(e) {
      return i[e];
    },
    add: function(e, t) {
      i[e] = t;
    },
    remove: function(e) {
      delete i[e];
    },
    removeAll: function() {
      i = {};
    }
  };
}
const ht = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class s3 {
  constructor(e) {
    this.parser = e, this.name = ht.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, s = t.length; n < s; n++) {
      const r = t[n];
      r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, n = "light:" + e;
    let s = t.cache.get(n);
    if (s) return s;
    const r = t.json, l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
    let c;
    const h = new Q(16777215);
    l.color !== void 0 && h.setRGB(l.color[0], l.color[1], l.color[2], en);
    const u = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        c = new Xc(h), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new Xo(h), c.distance = u;
        break;
      case "spot":
        c = new Wc(h), c.distance = u, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, lr(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), s = Promise.resolve(c), t.cache.add(n, s), s;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, r = n.json.nodes[e], o = (r.extensions && r.extensions[this.name] || {}).light;
    return o === void 0 ? null : this._loadLight(o).then(function(l) {
      return n._getNodeRef(t.cache, o, l);
    });
  }
}
class r3 {
  constructor() {
    this.name = ht.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return on;
  }
  extendParams(e, t, n) {
    const s = [];
    e.color = new Q(1, 1, 1), e.opacity = 1;
    const r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const a = r.baseColorFactor;
        e.color.setRGB(a[0], a[1], a[2], en), e.opacity = a[3];
      }
      r.baseColorTexture !== void 0 && s.push(n.assignTexture(e, "map", r.baseColorTexture, ft));
    }
    return Promise.all(s);
  }
}
class a3 {
  constructor(e) {
    this.parser = e, this.name = ht.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = s.extensions[this.name].emissiveStrength;
    return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
  }
}
class o3 {
  constructor(e) {
    this.parser = e, this.name = ht.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Xi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [], a = s.extensions[this.name];
    if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (r.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
      const o = a.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new k(o, o);
    }
    return Promise.all(r);
  }
}
class l3 {
  constructor(e) {
    this.parser = e, this.name = ht.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Xi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [], a = s.extensions[this.name];
    return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(r);
  }
}
class c3 {
  constructor(e) {
    this.parser = e, this.name = ht.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Xi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [];
    t.sheenColor = new Q(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const a = s.extensions[this.name];
    if (a.sheenColorFactor !== void 0) {
      const o = a.sheenColorFactor;
      t.sheenColor.setRGB(o[0], o[1], o[2], en);
    }
    return a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && r.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, ft)), a.sheenRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(r);
  }
}
class h3 {
  constructor(e) {
    this.parser = e, this.name = ht.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Xi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [], a = s.extensions[this.name];
    return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && r.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(r);
  }
}
class u3 {
  constructor(e) {
    this.parser = e, this.name = ht.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Xi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [], a = s.extensions[this.name];
    t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && r.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
    const o = a.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new Q().setRGB(o[0], o[1], o[2], en), Promise.all(r);
  }
}
class d3 {
  constructor(e) {
    this.parser = e, this.name = ht.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Xi;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = s.extensions[this.name];
    return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
  }
}
class f3 {
  constructor(e) {
    this.parser = e, this.name = ht.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Xi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [], a = s.extensions[this.name];
    t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && r.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
    const o = a.specularColorFactor || [1, 1, 1];
    return t.specularColor = new Q().setRGB(o[0], o[1], o[2], en), a.specularColorTexture !== void 0 && r.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, ft)), Promise.all(r);
  }
}
class p3 {
  constructor(e) {
    this.parser = e, this.name = ht.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Xi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [], a = s.extensions[this.name];
    return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && r.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(r);
  }
}
class m3 {
  constructor(e) {
    this.parser = e, this.name = ht.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, n = t.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[this.name])
      return null;
    const r = s.extensions[this.name], a = t.options.ktx2Loader;
    if (!a) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, r.source, a);
  }
}
class g3 {
  constructor(e) {
    this.parser = e, this.name = ht.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, s = n.json, r = s.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const a = r.extensions[t], o = s.images[a.source];
    let l = n.textureLoader;
    if (o.uri) {
      const c = n.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return n.loadTextureImage(e, a.source, l);
      if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class v3 {
  constructor(e) {
    this.parser = e, this.name = ht.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, s = n.json, r = s.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const a = r.extensions[t], o = s.images[a.source];
    let l = n.textureLoader;
    if (o.uri) {
      const c = n.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return n.loadTextureImage(e, a.source, l);
      if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class _3 {
  constructor(e) {
    this.name = ht.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const s = n.extensions[this.name], r = this.parser.getDependency("buffer", s.buffer), a = this.parser.options.meshoptDecoder;
      if (!a || !a.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return r.then(function(o) {
        const l = s.byteOffset || 0, c = s.byteLength || 0, h = s.count, u = s.byteStride, d = new Uint8Array(o, l, c);
        return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(h, u, d, s.mode, s.filter).then(function(f) {
          return f.buffer;
        }) : a.ready.then(function() {
          const f = new ArrayBuffer(h * u);
          return a.decodeGltfBuffer(new Uint8Array(f), h, u, d, s.mode, s.filter), f;
        });
      });
    } else
      return null;
  }
}
class y3 {
  constructor(e) {
    this.name = ht.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const s = t.meshes[n.mesh];
    for (const c of s.primitives)
      if (c.mode !== Pi.TRIANGLES && c.mode !== Pi.TRIANGLE_STRIP && c.mode !== Pi.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const a = n.extensions[this.name].attributes, o = [], l = {};
    for (const c in a)
      o.push(this.parser.getDependency("accessor", a[c]).then((h) => (l[c] = h, l[c])));
    return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then((c) => {
      const h = c.pop(), u = h.isGroup ? h.children : [h], d = c[0].count, f = [];
      for (const m of u) {
        const g = new _e(), p = new T(), v = new pt(), y = new T(1, 1, 1), _ = new Qm(m.geometry, m.material, d);
        for (let x = 0; x < d; x++)
          l.TRANSLATION && p.fromBufferAttribute(l.TRANSLATION, x), l.ROTATION && v.fromBufferAttribute(l.ROTATION, x), l.SCALE && y.fromBufferAttribute(l.SCALE, x), _.setMatrixAt(x, g.compose(p, v, y));
        for (const x in l)
          if (x === "_COLOR_0") {
            const M = l[x];
            _.instanceColor = new Aa(M.array, M.itemSize, M.normalized);
          } else x !== "TRANSLATION" && x !== "ROTATION" && x !== "SCALE" && m.geometry.setAttribute(x, l[x]);
        Ze.prototype.copy.call(_, m), this.parser.assignFinalMaterial(_), f.push(_);
      }
      return h.isGroup ? (h.clear(), h.add(...f), h) : f[0];
    }));
  }
}
const Ab = "glTF", Sl = 12, f_ = { JSON: 1313821514, BIN: 5130562 };
class x3 {
  constructor(e) {
    this.name = ht.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, Sl), n = new TextDecoder();
    if (this.header = {
      magic: n.decode(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== Ab)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const s = this.header.length - Sl, r = new DataView(e, Sl);
    let a = 0;
    for (; a < s; ) {
      const o = r.getUint32(a, !0);
      a += 4;
      const l = r.getUint32(a, !0);
      if (a += 4, l === f_.JSON) {
        const c = new Uint8Array(e, Sl + a, o);
        this.content = n.decode(c);
      } else if (l === f_.BIN) {
        const c = Sl + a;
        this.body = e.slice(c, c + o);
      }
      a += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class M3 {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = ht.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json, s = this.dracoLoader, r = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, l = {}, c = {};
    for (const h in a) {
      const u = lm[h] || h.toLowerCase();
      o[u] = a[h];
    }
    for (const h in e.attributes) {
      const u = lm[h] || h.toLowerCase();
      if (a[h] !== void 0) {
        const d = n.accessors[e.attributes[h]], f = Io[d.componentType];
        c[u] = f.name, l[u] = d.normalized === !0;
      }
    }
    return t.getDependency("bufferView", r).then(function(h) {
      return new Promise(function(u) {
        s.decodeDracoFile(h, function(d) {
          for (const f in d.attributes) {
            const m = d.attributes[f], g = l[f];
            g !== void 0 && (m.normalized = g);
          }
          u(d);
        }, o, c);
      });
    });
  }
}
class b3 {
  constructor() {
    this.name = ht.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class S3 {
  constructor() {
    this.name = ht.KHR_MESH_QUANTIZATION;
  }
}
class Cb extends ol {
  constructor(e, t, n, s) {
    super(e, t, n, s);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, s = this.valueSize, r = e * s * 3 + s;
    for (let a = 0; a !== s; a++)
      t[a] = n[r + a];
    return t;
  }
  interpolate_(e, t, n, s) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = o * 2, c = o * 3, h = s - t, u = (n - t) / h, d = u * u, f = d * u, m = e * c, g = m - c, p = -2 * f + 3 * d, v = f - d, y = 1 - p, _ = v - d + u;
    for (let x = 0; x !== o; x++) {
      const M = a[g + x + o], S = a[g + x + l] * h, w = a[m + x + o], E = a[m + x] * h;
      r[x] = y * M + _ * S + p * w + v * E;
    }
    return r;
  }
}
const w3 = new pt();
class T3 extends Cb {
  interpolate_(e, t, n, s) {
    const r = super.interpolate_(e, t, n, s);
    return w3.fromArray(r).normalize().toArray(r), r;
  }
}
const Pi = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
}, Io = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, p_ = {
  9728: lt,
  9729: Nt,
  9984: sc,
  9985: dd,
  9986: Eo,
  9987: ys
}, m_ = {
  33071: Kt,
  33648: Er,
  10497: Tn
}, Wf = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, lm = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, sr = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, E3 = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: Ea,
  STEP: zo
}, Xf = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function A3(i) {
  return i.DefaultMaterial === void 0 && (i.DefaultMaterial = new al({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: Wi
  })), i.DefaultMaterial;
}
function sa(i, e, t) {
  for (const n in t.extensions)
    i[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
}
function lr(i, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(i.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function C3(i, e, t) {
  let n = !1, s = !1, r = !1;
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (u.POSITION !== void 0 && (n = !0), u.NORMAL !== void 0 && (s = !0), u.COLOR_0 !== void 0 && (r = !0), n && s && r) break;
  }
  if (!n && !s && !r) return Promise.resolve(i);
  const a = [], o = [], l = [];
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (n) {
      const d = u.POSITION !== void 0 ? t.getDependency("accessor", u.POSITION) : i.attributes.position;
      a.push(d);
    }
    if (s) {
      const d = u.NORMAL !== void 0 ? t.getDependency("accessor", u.NORMAL) : i.attributes.normal;
      o.push(d);
    }
    if (r) {
      const d = u.COLOR_0 !== void 0 ? t.getDependency("accessor", u.COLOR_0) : i.attributes.color;
      l.push(d);
    }
  }
  return Promise.all([
    Promise.all(a),
    Promise.all(o),
    Promise.all(l)
  ]).then(function(c) {
    const h = c[0], u = c[1], d = c[2];
    return n && (i.morphAttributes.position = h), s && (i.morphAttributes.normal = u), r && (i.morphAttributes.color = d), i.morphTargetsRelative = !0, i;
  });
}
function R3(i, e) {
  if (i.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, n = e.weights.length; t < n; t++)
      i.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (i.morphTargetInfluences.length === t.length) {
      i.morphTargetDictionary = {};
      for (let n = 0, s = t.length; n < s; n++)
        i.morphTargetDictionary[t[n]] = n;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function P3(i) {
  let e;
  const t = i.extensions && i.extensions[ht.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + qf(t.attributes) : e = i.indices + ":" + qf(i.attributes) + ":" + i.mode, i.targets !== void 0)
    for (let n = 0, s = i.targets.length; n < s; n++)
      e += ":" + qf(i.targets[n]);
  return e;
}
function qf(i) {
  let e = "";
  const t = Object.keys(i).sort();
  for (let n = 0, s = t.length; n < s; n++)
    e += t[n] + ":" + i[t[n]] + ";";
  return e;
}
function cm(i) {
  switch (i) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function L3(i) {
  return i.search(/\.jpe?g($|\?)/i) > 0 || i.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : i.search(/\.webp($|\?)/i) > 0 || i.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const I3 = new _e();
class D3 {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new i3(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let n = !1, s = !1, r = -1;
    typeof navigator < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, s = navigator.userAgent.indexOf("Firefox") > -1, r = s ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || s && r < 98 ? this.textureLoader = new Ys(this.options.manager) : this.textureLoader = new lM(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new En(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this, s = this.json, r = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
      return a._markDefs && a._markDefs();
    }), Promise.all(this._invokeAll(function(a) {
      return a.beforeRoot && a.beforeRoot();
    })).then(function() {
      return Promise.all([
        n.getDependencies("scene"),
        n.getDependencies("animation"),
        n.getDependencies("camera")
      ]);
    }).then(function(a) {
      const o = {
        scene: a[0][s.scene || 0],
        scenes: a[0],
        animations: a[1],
        cameras: a[2],
        asset: s.asset,
        parser: n,
        userData: {}
      };
      return sa(r, o, s), lr(o, s), Promise.all(n._invokeAll(function(l) {
        return l.afterRoot && l.afterRoot(o);
      })).then(function() {
        e(o);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
    for (let s = 0, r = t.length; s < r; s++) {
      const a = t[s].joints;
      for (let o = 0, l = a.length; o < l; o++)
        e[a[o]].isBone = !0;
    }
    for (let s = 0, r = e.length; s < r; s++) {
      const a = e[s];
      a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1) return n;
    const s = n.clone(), r = (a, o) => {
      const l = this.associations.get(a);
      l != null && this.associations.set(o, l);
      for (const [c, h] of a.children.entries())
        r(h, o.children[c]);
    };
    return r(n, s), s.name += "_instance_" + e.uses[t]++, s;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const s = e(t[n]);
      if (s) return s;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let s = 0; s < t.length; s++) {
      const r = e(t[s]);
      r && n.push(r);
    }
    return n;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const n = e + ":" + t;
    let s = this.cache.get(n);
    if (!s) {
      switch (e) {
        case "scene":
          s = this.loadScene(t);
          break;
        case "node":
          s = this._invokeOne(function(r) {
            return r.loadNode && r.loadNode(t);
          });
          break;
        case "mesh":
          s = this._invokeOne(function(r) {
            return r.loadMesh && r.loadMesh(t);
          });
          break;
        case "accessor":
          s = this.loadAccessor(t);
          break;
        case "bufferView":
          s = this._invokeOne(function(r) {
            return r.loadBufferView && r.loadBufferView(t);
          });
          break;
        case "buffer":
          s = this.loadBuffer(t);
          break;
        case "material":
          s = this._invokeOne(function(r) {
            return r.loadMaterial && r.loadMaterial(t);
          });
          break;
        case "texture":
          s = this._invokeOne(function(r) {
            return r.loadTexture && r.loadTexture(t);
          });
          break;
        case "skin":
          s = this.loadSkin(t);
          break;
        case "animation":
          s = this._invokeOne(function(r) {
            return r.loadAnimation && r.loadAnimation(t);
          });
          break;
        case "camera":
          s = this.loadCamera(t);
          break;
        default:
          if (s = this._invokeOne(function(r) {
            return r != this && r.getDependency && r.getDependency(e, t);
          }), !s)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, s);
    }
    return s;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this, s = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(s.map(function(r, a) {
        return n.getDependency(e, a);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[ht.KHR_BINARY_GLTF].body);
    const s = this.options;
    return new Promise(function(r, a) {
      n.load(Pr.resolveURL(t.uri, s.path), r, void 0, function() {
        a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(n) {
      const s = t.byteLength || 0, r = t.byteOffset || 0;
      return n.slice(r, r + s);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, n = this.json, s = this.json.accessors[e];
    if (s.bufferView === void 0 && s.sparse === void 0) {
      const a = Wf[s.type], o = Io[s.componentType], l = s.normalized === !0, c = new o(s.count * a);
      return Promise.resolve(new dt(c, a, l));
    }
    const r = [];
    return s.bufferView !== void 0 ? r.push(this.getDependency("bufferView", s.bufferView)) : r.push(null), s.sparse !== void 0 && (r.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", s.sparse.values.bufferView))), Promise.all(r).then(function(a) {
      const o = a[0], l = Wf[s.type], c = Io[s.componentType], h = c.BYTES_PER_ELEMENT, u = h * l, d = s.byteOffset || 0, f = s.bufferView !== void 0 ? n.bufferViews[s.bufferView].byteStride : void 0, m = s.normalized === !0;
      let g, p;
      if (f && f !== u) {
        const v = Math.floor(d / f), y = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + v + ":" + s.count;
        let _ = t.cache.get(y);
        _ || (g = new c(o, v * f, s.count * f / h), _ = new Bc(g, f / h), t.cache.add(y, _)), p = new ei(_, l, d % f / h, m);
      } else
        o === null ? g = new c(s.count * l) : g = new c(o, d, s.count * l), p = new dt(g, l, m);
      if (s.sparse !== void 0) {
        const v = Wf.SCALAR, y = Io[s.sparse.indices.componentType], _ = s.sparse.indices.byteOffset || 0, x = s.sparse.values.byteOffset || 0, M = new y(a[1], _, s.sparse.count * v), S = new c(a[2], x, s.sparse.count * l);
        o !== null && (p = new dt(p.array.slice(), p.itemSize, p.normalized));
        for (let w = 0, E = M.length; w < E; w++) {
          const b = M[w];
          if (p.setX(b, S[w * l]), l >= 2 && p.setY(b, S[w * l + 1]), l >= 3 && p.setZ(b, S[w * l + 2]), l >= 4 && p.setW(b, S[w * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return p;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, n = this.options, r = t.textures[e].source, a = t.images[r];
    let o = this.textureLoader;
    if (a.uri) {
      const l = n.manager.getHandler(a.uri);
      l !== null && (o = l);
    }
    return this.loadTextureImage(e, r, o);
  }
  loadTextureImage(e, t, n) {
    const s = this, r = this.json, a = r.textures[e], o = r.images[t], l = (o.uri || o.bufferView) + ":" + a.sampler;
    if (this.textureCache[l])
      return this.textureCache[l];
    const c = this.loadImageSource(t, n).then(function(h) {
      h.flipY = !1, h.name = a.name || o.name || "", h.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === !1 && (h.name = o.uri);
      const d = (r.samplers || {})[a.sampler] || {};
      return h.magFilter = p_[d.magFilter] || Nt, h.minFilter = p_[d.minFilter] || ys, h.wrapS = m_[d.wrapS] || Tn, h.wrapT = m_[d.wrapT] || Tn, s.associations.set(h, { textures: e }), h;
    }).catch(function() {
      return null;
    });
    return this.textureCache[l] = c, c;
  }
  loadImageSource(e, t) {
    const n = this, s = this.json, r = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((u) => u.clone());
    const a = s.images[e], o = self.URL || self.webkitURL;
    let l = a.uri || "", c = !1;
    if (a.bufferView !== void 0)
      l = n.getDependency("bufferView", a.bufferView).then(function(u) {
        c = !0;
        const d = new Blob([u], { type: a.mimeType });
        return l = o.createObjectURL(d), l;
      });
    else if (a.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const h = Promise.resolve(l).then(function(u) {
      return new Promise(function(d, f) {
        let m = d;
        t.isImageBitmapLoader === !0 && (m = function(g) {
          const p = new At(g);
          p.needsUpdate = !0, d(p);
        }), t.load(Pr.resolveURL(u, r.path), m, void 0, f);
      });
    }).then(function(u) {
      return c === !0 && o.revokeObjectURL(l), u.userData.mimeType = a.mimeType || L3(a.uri), u;
    }).catch(function(u) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", l), u;
    });
    return this.sourceCache[e] = h, h;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, n, s) {
    const r = this;
    return this.getDependency("texture", n.index).then(function(a) {
      if (!a) return null;
      if (n.texCoord !== void 0 && n.texCoord > 0 && (a = a.clone(), a.channel = n.texCoord), r.extensions[ht.KHR_TEXTURE_TRANSFORM]) {
        const o = n.extensions !== void 0 ? n.extensions[ht.KHR_TEXTURE_TRANSFORM] : void 0;
        if (o) {
          const l = r.associations.get(a);
          a = r.extensions[ht.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), r.associations.set(a, l);
        }
      }
      return s !== void 0 && (a.colorSpace = s), e[t] = a, a;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const s = t.attributes.tangent === void 0, r = t.attributes.color !== void 0, a = t.attributes.normal === void 0;
    if (e.isPoints) {
      const o = "PointsMaterial:" + n.uuid;
      let l = this.cache.get(o);
      l || (l = new hr(), Qt.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(o, l)), n = l;
    } else if (e.isLine) {
      const o = "LineBasicMaterial:" + n.uuid;
      let l = this.cache.get(o);
      l || (l = new Jt(), Qt.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(o, l)), n = l;
    }
    if (s || r || a) {
      let o = "ClonedMaterial:" + n.uuid + ":";
      s && (o += "derivative-tangents:"), r && (o += "vertex-colors:"), a && (o += "flat-shading:");
      let l = this.cache.get(o);
      l || (l = n.clone(), r && (l.vertexColors = !0), a && (l.flatShading = !0), s && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(o, l), this.associations.set(l, this.associations.get(n))), n = l;
    }
    e.material = n;
  }
  getMaterialType() {
    return al;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, n = this.json, s = this.extensions, r = n.materials[e];
    let a;
    const o = {}, l = r.extensions || {}, c = [];
    if (l[ht.KHR_MATERIALS_UNLIT]) {
      const u = s[ht.KHR_MATERIALS_UNLIT];
      a = u.getMaterialType(), c.push(u.extendParams(o, r, t));
    } else {
      const u = r.pbrMetallicRoughness || {};
      if (o.color = new Q(1, 1, 1), o.opacity = 1, Array.isArray(u.baseColorFactor)) {
        const d = u.baseColorFactor;
        o.color.setRGB(d[0], d[1], d[2], en), o.opacity = d[3];
      }
      u.baseColorTexture !== void 0 && c.push(t.assignTexture(o, "map", u.baseColorTexture, ft)), o.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1, o.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1, u.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(o, "metalnessMap", u.metallicRoughnessTexture)), c.push(t.assignTexture(o, "roughnessMap", u.metallicRoughnessTexture))), a = this._invokeOne(function(d) {
        return d.getMaterialType && d.getMaterialType(e);
      }), c.push(Promise.all(this._invokeAll(function(d) {
        return d.extendMaterialParams && d.extendMaterialParams(e, o);
      })));
    }
    r.doubleSided === !0 && (o.side = $t);
    const h = r.alphaMode || Xf.OPAQUE;
    if (h === Xf.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, h === Xf.MASK && (o.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)), r.normalTexture !== void 0 && a !== on && (c.push(t.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new k(1, 1), r.normalTexture.scale !== void 0)) {
      const u = r.normalTexture.scale;
      o.normalScale.set(u, u);
    }
    if (r.occlusionTexture !== void 0 && a !== on && (c.push(t.assignTexture(o, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && a !== on) {
      const u = r.emissiveFactor;
      o.emissive = new Q().setRGB(u[0], u[1], u[2], en);
    }
    return r.emissiveTexture !== void 0 && a !== on && c.push(t.assignTexture(o, "emissiveMap", r.emissiveTexture, ft)), Promise.all(c).then(function() {
      const u = new a(o);
      return r.name && (u.name = r.name), lr(u, r), t.associations.set(u, { materials: e }), r.extensions && sa(s, u, r), u;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = it.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, n = this.extensions, s = this.primitiveCache;
    function r(o) {
      return n[ht.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(l) {
        return g_(l, o, t);
      });
    }
    const a = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o], h = P3(c), u = s[h];
      if (u)
        a.push(u.promise);
      else {
        let d;
        c.extensions && c.extensions[ht.KHR_DRACO_MESH_COMPRESSION] ? d = r(c) : d = g_(new Be(), c, t), s[h] = { primitive: c, promise: d }, a.push(d);
      }
    }
    return Promise.all(a);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, n = this.json, s = this.extensions, r = n.meshes[e], a = r.primitives, o = [];
    for (let l = 0, c = a.length; l < c; l++) {
      const h = a[l].material === void 0 ? A3(this.cache) : this.getDependency("material", a[l].material);
      o.push(h);
    }
    return o.push(t.loadGeometries(a)), Promise.all(o).then(function(l) {
      const c = l.slice(0, l.length - 1), h = l[l.length - 1], u = [];
      for (let f = 0, m = h.length; f < m; f++) {
        const g = h[f], p = a[f];
        let v;
        const y = c[f];
        if (p.mode === Pi.TRIANGLES || p.mode === Pi.TRIANGLE_STRIP || p.mode === Pi.TRIANGLE_FAN || p.mode === void 0)
          v = r.isSkinnedMesh === !0 ? new Sd(g, y) : new le(g, y), v.isSkinnedMesh === !0 && v.normalizeSkinWeights(), p.mode === Pi.TRIANGLE_STRIP ? v.geometry = d_(v.geometry, zm) : p.mode === Pi.TRIANGLE_FAN && (v.geometry = d_(v.geometry, Ru));
        else if (p.mode === Pi.LINES)
          v = new bi(g, y);
        else if (p.mode === Pi.LINE_STRIP)
          v = new pn(g, y);
        else if (p.mode === Pi.LINE_LOOP)
          v = new Jm(g, y);
        else if (p.mode === Pi.POINTS)
          v = new ya(g, y);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
        Object.keys(v.geometry.morphAttributes).length > 0 && R3(v, r), v.name = t.createUniqueName(r.name || "mesh_" + e), lr(v, r), p.extensions && sa(s, v, p), t.assignFinalMaterial(v), u.push(v);
      }
      for (let f = 0, m = u.length; f < m; f++)
        t.associations.set(u[f], {
          meshes: e,
          primitives: f
        });
      if (u.length === 1)
        return r.extensions && sa(s, u[0], r), u[0];
      const d = new Gn();
      r.extensions && sa(s, d, r), t.associations.set(d, { meshes: e });
      for (let f = 0, m = u.length; f < m; f++)
        d.add(u[f]);
      return d;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e], s = n[n.type];
    if (!s) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return n.type === "perspective" ? t = new Zt(Kn.radToDeg(s.yfov), s.aspectRatio || 1, s.znear || 1, s.zfar || 2e6) : n.type === "orthographic" && (t = new Na(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), n.name && (t.name = this.createUniqueName(n.name)), lr(t, n), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], n = [];
    for (let s = 0, r = t.joints.length; s < r; s++)
      n.push(this._loadNodeShallow(t.joints[s]));
    return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(s) {
      const r = s.pop(), a = s, o = [], l = [];
      for (let c = 0, h = a.length; c < h; c++) {
        const u = a[c];
        if (u) {
          o.push(u);
          const d = new _e();
          r !== null && d.fromArray(r.array, c * 16), l.push(d);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new rl(o, l);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, n = this, s = t.animations[e], r = s.name ? s.name : "animation_" + e, a = [], o = [], l = [], c = [], h = [];
    for (let u = 0, d = s.channels.length; u < d; u++) {
      const f = s.channels[u], m = s.samplers[f.sampler], g = f.target, p = g.node, v = s.parameters !== void 0 ? s.parameters[m.input] : m.input, y = s.parameters !== void 0 ? s.parameters[m.output] : m.output;
      g.node !== void 0 && (a.push(this.getDependency("node", p)), o.push(this.getDependency("accessor", v)), l.push(this.getDependency("accessor", y)), c.push(m), h.push(g));
    }
    return Promise.all([
      Promise.all(a),
      Promise.all(o),
      Promise.all(l),
      Promise.all(c),
      Promise.all(h)
    ]).then(function(u) {
      const d = u[0], f = u[1], m = u[2], g = u[3], p = u[4], v = [];
      for (let y = 0, _ = d.length; y < _; y++) {
        const x = d[y], M = f[y], S = m[y], w = g[y], E = p[y];
        if (x === void 0) continue;
        x.updateMatrix && x.updateMatrix();
        const b = n._createAnimationTracks(x, M, S, w, E);
        if (b)
          for (let A = 0; A < b.length; A++)
            v.push(b[A]);
      }
      return new Ra(r, void 0, v);
    });
  }
  createNodeMesh(e) {
    const t = this.json, n = this, s = t.nodes[e];
    return s.mesh === void 0 ? null : n.getDependency("mesh", s.mesh).then(function(r) {
      const a = n._getNodeRef(n.meshCache, s.mesh, r);
      return s.weights !== void 0 && a.traverse(function(o) {
        if (o.isMesh)
          for (let l = 0, c = s.weights.length; l < c; l++)
            o.morphTargetInfluences[l] = s.weights[l];
      }), a;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, n = this, s = t.nodes[e], r = n._loadNodeShallow(e), a = [], o = s.children || [];
    for (let c = 0, h = o.length; c < h; c++)
      a.push(n.getDependency("node", o[c]));
    const l = s.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", s.skin);
    return Promise.all([
      r,
      Promise.all(a),
      l
    ]).then(function(c) {
      const h = c[0], u = c[1], d = c[2];
      d !== null && h.traverse(function(f) {
        f.isSkinnedMesh && f.bind(d, I3);
      });
      for (let f = 0, m = u.length; f < m; f++)
        h.add(u[f]);
      return h;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, n = this.extensions, s = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const r = t.nodes[e], a = r.name ? s.createUniqueName(r.name) : "", o = [], l = s._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(e);
    });
    return l && o.push(l), r.camera !== void 0 && o.push(s.getDependency("camera", r.camera).then(function(c) {
      return s._getNodeRef(s.cameraCache, r.camera, c);
    })), s._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(e);
    }).forEach(function(c) {
      o.push(c);
    }), this.nodeCache[e] = Promise.all(o).then(function(c) {
      let h;
      if (r.isBone === !0 ? h = new Vo() : c.length > 1 ? h = new Gn() : c.length === 1 ? h = c[0] : h = new Ze(), h !== c[0])
        for (let u = 0, d = c.length; u < d; u++)
          h.add(c[u]);
      if (r.name && (h.userData.name = r.name, h.name = a), lr(h, r), r.extensions && sa(n, h, r), r.matrix !== void 0) {
        const u = new _e();
        u.fromArray(r.matrix), h.applyMatrix4(u);
      } else
        r.translation !== void 0 && h.position.fromArray(r.translation), r.rotation !== void 0 && h.quaternion.fromArray(r.rotation), r.scale !== void 0 && h.scale.fromArray(r.scale);
      return s.associations.has(h) || s.associations.set(h, {}), s.associations.get(h).nodes = e, h;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, n = this.json.scenes[e], s = this, r = new Gn();
    n.name && (r.name = s.createUniqueName(n.name)), lr(r, n), n.extensions && sa(t, r, n);
    const a = n.nodes || [], o = [];
    for (let l = 0, c = a.length; l < c; l++)
      o.push(s.getDependency("node", a[l]));
    return Promise.all(o).then(function(l) {
      for (let h = 0, u = l.length; h < u; h++)
        r.add(l[h]);
      const c = (h) => {
        const u = /* @__PURE__ */ new Map();
        for (const [d, f] of s.associations)
          (d instanceof Qt || d instanceof At) && u.set(d, f);
        return h.traverse((d) => {
          const f = s.associations.get(d);
          f != null && u.set(d, f);
        }), u;
      };
      return s.associations = c(r), r;
    });
  }
  _createAnimationTracks(e, t, n, s, r) {
    const a = [], o = e.name ? e.name : e.uuid, l = [];
    sr[r.path] === sr.weights ? e.traverse(function(d) {
      d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid);
    }) : l.push(o);
    let c;
    switch (sr[r.path]) {
      case sr.weights:
        c = Cr;
        break;
      case sr.rotation:
        c = Ws;
        break;
      case sr.position:
      case sr.scale:
        c = Rr;
        break;
      default:
        switch (n.itemSize) {
          case 1:
            c = Cr;
            break;
          case 2:
          case 3:
          default:
            c = Rr;
            break;
        }
        break;
    }
    const h = s.interpolation !== void 0 ? E3[s.interpolation] : Ea, u = this._getArrayFromAccessor(n);
    for (let d = 0, f = l.length; d < f; d++) {
      const m = new c(
        l[d] + "." + sr[r.path],
        t.array,
        u,
        h
      );
      s.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(m), a.push(m);
    }
    return a;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const n = cm(t.constructor), s = new Float32Array(t.length);
      for (let r = 0, a = t.length; r < a; r++)
        s[r] = t[r] * n;
      t = s;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(n) {
      const s = this instanceof Ws ? T3 : Cb;
      return new s(this.times, this.values, this.getValueSize() / 3, n);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function O3(i, e, t) {
  const n = e.attributes, s = new ln();
  if (n.POSITION !== void 0) {
    const o = t.json.accessors[n.POSITION], l = o.min, c = o.max;
    if (l !== void 0 && c !== void 0) {
      if (s.set(
        new T(l[0], l[1], l[2]),
        new T(c[0], c[1], c[2])
      ), o.normalized) {
        const h = cm(Io[o.componentType]);
        s.min.multiplyScalar(h), s.max.multiplyScalar(h);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const r = e.targets;
  if (r !== void 0) {
    const o = new T(), l = new T();
    for (let c = 0, h = r.length; c < h; c++) {
      const u = r[c];
      if (u.POSITION !== void 0) {
        const d = t.json.accessors[u.POSITION], f = d.min, m = d.max;
        if (f !== void 0 && m !== void 0) {
          if (l.setX(Math.max(Math.abs(f[0]), Math.abs(m[0]))), l.setY(Math.max(Math.abs(f[1]), Math.abs(m[1]))), l.setZ(Math.max(Math.abs(f[2]), Math.abs(m[2]))), d.normalized) {
            const g = cm(Io[d.componentType]);
            l.multiplyScalar(g);
          }
          o.max(l);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    s.expandByVector(o);
  }
  i.boundingBox = s;
  const a = new oi();
  s.getCenter(a.center), a.radius = s.min.distanceTo(s.max) / 2, i.boundingSphere = a;
}
function g_(i, e, t) {
  const n = e.attributes, s = [];
  function r(a, o) {
    return t.getDependency("accessor", a).then(function(l) {
      i.setAttribute(o, l);
    });
  }
  for (const a in n) {
    const o = lm[a] || a.toLowerCase();
    o in i.attributes || s.push(r(n[a], o));
  }
  if (e.indices !== void 0 && !i.index) {
    const a = t.getDependency("accessor", e.indices).then(function(o) {
      i.setIndex(o);
    });
    s.push(a);
  }
  return gt.workingColorSpace !== en && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${gt.workingColorSpace}" not supported.`), lr(i, e), O3(i, e, t), Promise.all(s).then(function() {
    return e.targets !== void 0 ? C3(i, e.targets, t) : i;
  });
}
const Yf = /* @__PURE__ */ new WeakMap();
class N3 extends Vt {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, n, s) {
    const r = new En(this.manager);
    r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, (a) => {
      this.parse(a, t, s);
    }, n, s);
  }
  parse(e, t, n) {
    this.decodeDracoFile(e, t, null, null, ft).catch(n);
  }
  decodeDracoFile(e, t, n, s, r = en) {
    const a = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: s || this.defaultAttributeTypes,
      useUniqueIDs: !!n,
      vertexColorSpace: r
    };
    return this.decodeGeometry(e, a).then(t);
  }
  decodeGeometry(e, t) {
    const n = JSON.stringify(t);
    if (Yf.has(e)) {
      const l = Yf.get(e);
      if (l.key === n)
        return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let s;
    const r = this.workerNextTaskID++, a = e.byteLength, o = this._getWorker(r, a).then((l) => (s = l, new Promise((c, h) => {
      s._callbacks[r] = { resolve: c, reject: h }, s.postMessage({ type: "decode", id: r, taskConfig: t, buffer: e }, [e]);
    }))).then((l) => this._createGeometry(l.geometry));
    return o.catch(() => !0).then(() => {
      s && r && this._releaseTask(s, r);
    }), Yf.set(e, {
      key: n,
      promise: o
    }), o;
  }
  _createGeometry(e) {
    const t = new Be();
    e.index && t.setIndex(new dt(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const s = e.attributes[n], r = s.name, a = s.array, o = s.itemSize, l = new dt(a, o);
      r === "color" && (this._assignVertexColorSpace(l, s.vertexColorSpace), l.normalized = !(a instanceof Float32Array)), t.setAttribute(r, l);
    }
    return t;
  }
  _assignVertexColorSpace(e, t) {
    if (t !== ft) return;
    const n = new Q();
    for (let s = 0, r = e.count; s < r; s++)
      n.fromBufferAttribute(e, s).convertSRGBToLinear(), e.setXYZ(s, n.r, n.g, n.b);
  }
  _loadLibrary(e, t) {
    const n = new En(this.manager);
    return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((s, r) => {
      n.load(e, s, void 0, r);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((n) => {
      const s = n[0];
      e || (this.decoderConfig.wasmBinary = n[1]);
      const r = U3.toString(), a = [
        "/* draco decoder */",
        s,
        "",
        "/* worker */",
        r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([a]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const s = new Worker(this.workerSourceURL);
        s._callbacks = {}, s._taskCosts = {}, s._taskLoad = 0, s.postMessage({ type: "init", decoderConfig: this.decoderConfig }), s.onmessage = function(r) {
          const a = r.data;
          switch (a.type) {
            case "decode":
              s._callbacks[a.id].resolve(a);
              break;
            case "error":
              s._callbacks[a.id].reject(a);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + a.type + '"');
          }
        }, this.workerPool.push(s);
      } else
        this.workerPool.sort(function(s, r) {
          return s._taskLoad > r._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return n._taskCosts[e] = t, n._taskLoad += t, n;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((e) => e._taskLoad));
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
function U3() {
  let i, e;
  onmessage = function(a) {
    const o = a.data;
    switch (o.type) {
      case "init":
        i = o.decoderConfig, e = new Promise(function(h) {
          i.onModuleLoaded = function(u) {
            h({ draco: u });
          }, DracoDecoderModule(i);
        });
        break;
      case "decode":
        const l = o.buffer, c = o.taskConfig;
        e.then((h) => {
          const u = h.draco, d = new u.Decoder();
          try {
            const f = t(u, d, new Int8Array(l), c), m = f.attributes.map((g) => g.array.buffer);
            f.index && m.push(f.index.array.buffer), self.postMessage({ type: "decode", id: o.id, geometry: f }, m);
          } catch (f) {
            console.error(f), self.postMessage({ type: "error", id: o.id, error: f.message });
          } finally {
            u.destroy(d);
          }
        });
        break;
    }
  };
  function t(a, o, l, c) {
    const h = c.attributeIDs, u = c.attributeTypes;
    let d, f;
    const m = o.GetEncodedGeometryType(l);
    if (m === a.TRIANGULAR_MESH)
      d = new a.Mesh(), f = o.DecodeArrayToMesh(l, l.byteLength, d);
    else if (m === a.POINT_CLOUD)
      d = new a.PointCloud(), f = o.DecodeArrayToPointCloud(l, l.byteLength, d);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!f.ok() || d.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg());
    const g = { index: null, attributes: [] };
    for (const p in h) {
      const v = self[u[p]];
      let y, _;
      if (c.useUniqueIDs)
        _ = h[p], y = o.GetAttributeByUniqueId(d, _);
      else {
        if (_ = o.GetAttributeId(d, a[h[p]]), _ === -1) continue;
        y = o.GetAttribute(d, _);
      }
      const x = s(a, o, d, p, v, y);
      p === "color" && (x.vertexColorSpace = c.vertexColorSpace), g.attributes.push(x);
    }
    return m === a.TRIANGULAR_MESH && (g.index = n(a, o, d)), a.destroy(d), g;
  }
  function n(a, o, l) {
    const h = l.num_faces() * 3, u = h * 4, d = a._malloc(u);
    o.GetTrianglesUInt32Array(l, u, d);
    const f = new Uint32Array(a.HEAPF32.buffer, d, h).slice();
    return a._free(d), { array: f, itemSize: 1 };
  }
  function s(a, o, l, c, h, u) {
    const d = u.num_components(), m = l.num_points() * d, g = m * h.BYTES_PER_ELEMENT, p = r(a, h), v = a._malloc(g);
    o.GetAttributeDataArrayForAllPoints(l, u, p, g, v);
    const y = new h(a.HEAPF32.buffer, v, m).slice();
    return a._free(v), {
      name: c,
      array: y,
      itemSize: d
    };
  }
  function r(a, o) {
    switch (o) {
      case Float32Array:
        return a.DT_FLOAT32;
      case Int8Array:
        return a.DT_INT8;
      case Int16Array:
        return a.DT_INT16;
      case Int32Array:
        return a.DT_INT32;
      case Uint8Array:
        return a.DT_UINT8;
      case Uint16Array:
        return a.DT_UINT16;
      case Uint32Array:
        return a.DT_UINT32;
    }
  }
}
const F3 = /^[og]\s*(.+)?/, B3 = /^mtllib /, k3 = /^usemtl /, z3 = /^usemap /, v_ = /\s+/, __ = new T(), jf = new T(), y_ = new T(), x_ = new T(), Ai = new T(), $h = new Q();
function H3() {
  const i = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: function(e, t) {
      if (this.object && this.object.fromDeclaration === !1) {
        this.object.name = e, this.object.fromDeclaration = t !== !1;
        return;
      }
      const n = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0), this.object = {
        name: e || "",
        fromDeclaration: t !== !1,
        geometry: {
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          hasUVIndices: !1
        },
        materials: [],
        smooth: !0,
        startMaterial: function(s, r) {
          const a = this._finalize(!1);
          a && (a.inherited || a.groupCount <= 0) && this.materials.splice(a.index, 1);
          const o = {
            index: this.materials.length,
            name: s || "",
            mtllib: Array.isArray(r) && r.length > 0 ? r[r.length - 1] : "",
            smooth: a !== void 0 ? a.smooth : this.smooth,
            groupStart: a !== void 0 ? a.groupEnd : 0,
            groupEnd: -1,
            groupCount: -1,
            inherited: !1,
            clone: function(l) {
              const c = {
                index: typeof l == "number" ? l : this.index,
                name: this.name,
                mtllib: this.mtllib,
                smooth: this.smooth,
                groupStart: 0,
                groupEnd: -1,
                groupCount: -1,
                inherited: !1
              };
              return c.clone = this.clone.bind(c), c;
            }
          };
          return this.materials.push(o), o;
        },
        currentMaterial: function() {
          if (this.materials.length > 0)
            return this.materials[this.materials.length - 1];
        },
        _finalize: function(s) {
          const r = this.currentMaterial();
          if (r && r.groupEnd === -1 && (r.groupEnd = this.geometry.vertices.length / 3, r.groupCount = r.groupEnd - r.groupStart, r.inherited = !1), s && this.materials.length > 1)
            for (let a = this.materials.length - 1; a >= 0; a--)
              this.materials[a].groupCount <= 0 && this.materials.splice(a, 1);
          return s && this.materials.length === 0 && this.materials.push({
            name: "",
            smooth: this.smooth
          }), r;
        }
      }, n && n.name && typeof n.clone == "function") {
        const s = n.clone(0);
        s.inherited = !0, this.object.materials.push(s);
      }
      this.objects.push(this.object);
    },
    finalize: function() {
      this.object && typeof this.object._finalize == "function" && this.object._finalize(!0);
    },
    parseVertexIndex: function(e, t) {
      const n = parseInt(e, 10);
      return (n >= 0 ? n - 1 : n + t / 3) * 3;
    },
    parseNormalIndex: function(e, t) {
      const n = parseInt(e, 10);
      return (n >= 0 ? n - 1 : n + t / 3) * 3;
    },
    parseUVIndex: function(e, t) {
      const n = parseInt(e, 10);
      return (n >= 0 ? n - 1 : n + t / 2) * 2;
    },
    addVertex: function(e, t, n) {
      const s = this.vertices, r = this.object.geometry.vertices;
      r.push(s[e + 0], s[e + 1], s[e + 2]), r.push(s[t + 0], s[t + 1], s[t + 2]), r.push(s[n + 0], s[n + 1], s[n + 2]);
    },
    addVertexPoint: function(e) {
      const t = this.vertices;
      this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
    },
    addVertexLine: function(e) {
      const t = this.vertices;
      this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
    },
    addNormal: function(e, t, n) {
      const s = this.normals, r = this.object.geometry.normals;
      r.push(s[e + 0], s[e + 1], s[e + 2]), r.push(s[t + 0], s[t + 1], s[t + 2]), r.push(s[n + 0], s[n + 1], s[n + 2]);
    },
    addFaceNormal: function(e, t, n) {
      const s = this.vertices, r = this.object.geometry.normals;
      __.fromArray(s, e), jf.fromArray(s, t), y_.fromArray(s, n), Ai.subVectors(y_, jf), x_.subVectors(__, jf), Ai.cross(x_), Ai.normalize(), r.push(Ai.x, Ai.y, Ai.z), r.push(Ai.x, Ai.y, Ai.z), r.push(Ai.x, Ai.y, Ai.z);
    },
    addColor: function(e, t, n) {
      const s = this.colors, r = this.object.geometry.colors;
      s[e] !== void 0 && r.push(s[e + 0], s[e + 1], s[e + 2]), s[t] !== void 0 && r.push(s[t + 0], s[t + 1], s[t + 2]), s[n] !== void 0 && r.push(s[n + 0], s[n + 1], s[n + 2]);
    },
    addUV: function(e, t, n) {
      const s = this.uvs, r = this.object.geometry.uvs;
      r.push(s[e + 0], s[e + 1]), r.push(s[t + 0], s[t + 1]), r.push(s[n + 0], s[n + 1]);
    },
    addDefaultUV: function() {
      const e = this.object.geometry.uvs;
      e.push(0, 0), e.push(0, 0), e.push(0, 0);
    },
    addUVLine: function(e) {
      const t = this.uvs;
      this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
    },
    addFace: function(e, t, n, s, r, a, o, l, c) {
      const h = this.vertices.length;
      let u = this.parseVertexIndex(e, h), d = this.parseVertexIndex(t, h), f = this.parseVertexIndex(n, h);
      if (this.addVertex(u, d, f), this.addColor(u, d, f), o !== void 0 && o !== "") {
        const m = this.normals.length;
        u = this.parseNormalIndex(o, m), d = this.parseNormalIndex(l, m), f = this.parseNormalIndex(c, m), this.addNormal(u, d, f);
      } else
        this.addFaceNormal(u, d, f);
      if (s !== void 0 && s !== "") {
        const m = this.uvs.length;
        u = this.parseUVIndex(s, m), d = this.parseUVIndex(r, m), f = this.parseUVIndex(a, m), this.addUV(u, d, f), this.object.geometry.hasUVIndices = !0;
      } else
        this.addDefaultUV();
    },
    addPointGeometry: function(e) {
      this.object.geometry.type = "Points";
      const t = this.vertices.length;
      for (let n = 0, s = e.length; n < s; n++) {
        const r = this.parseVertexIndex(e[n], t);
        this.addVertexPoint(r), this.addColor(r);
      }
    },
    addLineGeometry: function(e, t) {
      this.object.geometry.type = "Line";
      const n = this.vertices.length, s = this.uvs.length;
      for (let r = 0, a = e.length; r < a; r++)
        this.addVertexLine(this.parseVertexIndex(e[r], n));
      for (let r = 0, a = t.length; r < a; r++)
        this.addUVLine(this.parseUVIndex(t[r], s));
    }
  };
  return i.startObject("", !1), i;
}
class G3 extends Vt {
  constructor(e) {
    super(e), this.materials = null;
  }
  load(e, t, n, s) {
    const r = this, a = new En(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(o));
      } catch (l) {
        s ? s(l) : console.error(l), r.manager.itemError(e);
      }
    }, n, s);
  }
  setMaterials(e) {
    return this.materials = e, this;
  }
  parse(e) {
    const t = new H3();
    e.indexOf(`\r
`) !== -1 && (e = e.replace(/\r\n/g, `
`)), e.indexOf(`\\
`) !== -1 && (e = e.replace(/\\\n/g, ""));
    const n = e.split(`
`);
    let s = [];
    for (let o = 0, l = n.length; o < l; o++) {
      const c = n[o].trimStart();
      if (c.length === 0) continue;
      const h = c.charAt(0);
      if (h !== "#")
        if (h === "v") {
          const u = c.split(v_);
          switch (u[0]) {
            case "v":
              t.vertices.push(
                parseFloat(u[1]),
                parseFloat(u[2]),
                parseFloat(u[3])
              ), u.length >= 7 ? ($h.setRGB(
                parseFloat(u[4]),
                parseFloat(u[5]),
                parseFloat(u[6])
              ).convertSRGBToLinear(), t.colors.push($h.r, $h.g, $h.b)) : t.colors.push(void 0, void 0, void 0);
              break;
            case "vn":
              t.normals.push(
                parseFloat(u[1]),
                parseFloat(u[2]),
                parseFloat(u[3])
              );
              break;
            case "vt":
              t.uvs.push(
                parseFloat(u[1]),
                parseFloat(u[2])
              );
              break;
          }
        } else if (h === "f") {
          const d = c.slice(1).trim().split(v_), f = [];
          for (let g = 0, p = d.length; g < p; g++) {
            const v = d[g];
            if (v.length > 0) {
              const y = v.split("/");
              f.push(y);
            }
          }
          const m = f[0];
          for (let g = 1, p = f.length - 1; g < p; g++) {
            const v = f[g], y = f[g + 1];
            t.addFace(
              m[0],
              v[0],
              y[0],
              m[1],
              v[1],
              y[1],
              m[2],
              v[2],
              y[2]
            );
          }
        } else if (h === "l") {
          const u = c.substring(1).trim().split(" ");
          let d = [];
          const f = [];
          if (c.indexOf("/") === -1)
            d = u;
          else
            for (let m = 0, g = u.length; m < g; m++) {
              const p = u[m].split("/");
              p[0] !== "" && d.push(p[0]), p[1] !== "" && f.push(p[1]);
            }
          t.addLineGeometry(d, f);
        } else if (h === "p") {
          const d = c.slice(1).trim().split(" ");
          t.addPointGeometry(d);
        } else if ((s = F3.exec(c)) !== null) {
          const u = (" " + s[0].slice(1).trim()).slice(1);
          t.startObject(u);
        } else if (k3.test(c))
          t.object.startMaterial(c.substring(7).trim(), t.materialLibraries);
        else if (B3.test(c))
          t.materialLibraries.push(c.substring(7).trim());
        else if (z3.test(c))
          console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
        else if (h === "s") {
          if (s = c.split(" "), s.length > 1) {
            const d = s[1].trim().toLowerCase();
            t.object.smooth = d !== "0" && d !== "off";
          } else
            t.object.smooth = !0;
          const u = t.object.currentMaterial();
          u && (u.smooth = t.object.smooth);
        } else {
          if (c === "\0") continue;
          console.warn('THREE.OBJLoader: Unexpected line: "' + c + '"');
        }
    }
    t.finalize();
    const r = new Gn();
    if (r.materialLibraries = [].concat(t.materialLibraries), !(t.objects.length === 1 && t.objects[0].geometry.vertices.length === 0) === !0)
      for (let o = 0, l = t.objects.length; o < l; o++) {
        const c = t.objects[o], h = c.geometry, u = c.materials, d = h.type === "Line", f = h.type === "Points";
        let m = !1;
        if (h.vertices.length === 0) continue;
        const g = new Be();
        g.setAttribute("position", new ye(h.vertices, 3)), h.normals.length > 0 && g.setAttribute("normal", new ye(h.normals, 3)), h.colors.length > 0 && (m = !0, g.setAttribute("color", new ye(h.colors, 3))), h.hasUVIndices === !0 && g.setAttribute("uv", new ye(h.uvs, 2));
        const p = [];
        for (let y = 0, _ = u.length; y < _; y++) {
          const x = u[y], M = x.name + "_" + x.smooth + "_" + m;
          let S = t.materials[M];
          if (this.materials !== null) {
            if (S = this.materials.create(x.name), d && S && !(S instanceof Jt)) {
              const w = new Jt();
              Qt.prototype.copy.call(w, S), w.color.copy(S.color), S = w;
            } else if (f && S && !(S instanceof hr)) {
              const w = new hr({ size: 10, sizeAttenuation: !1 });
              Qt.prototype.copy.call(w, S), w.color.copy(S.color), w.map = S.map, S = w;
            }
          }
          S === void 0 && (d ? S = new Jt() : f ? S = new hr({ size: 1, sizeAttenuation: !1 }) : S = new yr(), S.name = x.name, S.flatShading = !x.smooth, S.vertexColors = m, t.materials[M] = S), p.push(S);
        }
        let v;
        if (p.length > 1) {
          for (let y = 0, _ = u.length; y < _; y++) {
            const x = u[y];
            g.addGroup(x.groupStart, x.groupCount, y);
          }
          d ? v = new bi(g, p) : f ? v = new ya(g, p) : v = new le(g, p);
        } else
          d ? v = new bi(g, p[0]) : f ? v = new ya(g, p[0]) : v = new le(g, p[0]);
        v.name = c.name, r.add(v);
      }
    else if (t.vertices.length > 0) {
      const o = new hr({ size: 1, sizeAttenuation: !1 }), l = new Be();
      l.setAttribute("position", new ye(t.vertices, 3)), t.colors.length > 0 && t.colors[0] !== void 0 && (l.setAttribute("color", new ye(t.colors, 3)), o.vertexColors = !0);
      const c = new ya(l, o);
      r.add(c);
    }
    return r;
  }
}
class V3 extends Vt {
  constructor(e) {
    super(e);
  }
  /**
   * Loads and parses a MTL asset from a URL.
   *
   * @param {String} url - URL to the MTL file.
   * @param {Function} [onLoad] - Callback invoked with the loaded object.
   * @param {Function} [onProgress] - Callback for download progress.
   * @param {Function} [onError] - Callback for download errors.
   *
   * @see setPath setResourcePath
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setResourcePath() explicitly prior to load.
   */
  load(e, t, n, s) {
    const r = this, a = this.path === "" ? Pr.extractUrlBase(e) : this.path, o = new En(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(l) {
      try {
        t(r.parse(l, a));
      } catch (c) {
        s ? s(c) : console.error(c), r.manager.itemError(e);
      }
    }, n, s);
  }
  setMaterialOptions(e) {
    return this.materialOptions = e, this;
  }
  /**
   * Parses a MTL file.
   *
   * @param {String} text - Content of MTL file
   * @return {MaterialCreator}
   *
   * @see setPath setResourcePath
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setResourcePath() explicitly prior to parse.
   */
  parse(e, t) {
    const n = e.split(`
`);
    let s = {};
    const r = /\s+/, a = {};
    for (let l = 0; l < n.length; l++) {
      let c = n[l];
      if (c = c.trim(), c.length === 0 || c.charAt(0) === "#")
        continue;
      const h = c.indexOf(" ");
      let u = h >= 0 ? c.substring(0, h) : c;
      u = u.toLowerCase();
      let d = h >= 0 ? c.substring(h + 1) : "";
      if (d = d.trim(), u === "newmtl")
        s = { name: d }, a[d] = s;
      else if (u === "ka" || u === "kd" || u === "ks" || u === "ke") {
        const f = d.split(r, 3);
        s[u] = [parseFloat(f[0]), parseFloat(f[1]), parseFloat(f[2])];
      } else
        s[u] = d;
    }
    const o = new W3(this.resourcePath || t, this.materialOptions);
    return o.setCrossOrigin(this.crossOrigin), o.setManager(this.manager), o.setMaterials(a), o;
  }
}
class W3 {
  constructor(e = "", t = {}) {
    this.baseUrl = e, this.options = t, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = this.options.side !== void 0 ? this.options.side : Wi, this.wrap = this.options.wrap !== void 0 ? this.options.wrap : Tn;
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setManager(e) {
    this.manager = e;
  }
  setMaterials(e) {
    this.materialsInfo = this.convert(e), this.materials = {}, this.materialsArray = [], this.nameLookup = {};
  }
  convert(e) {
    if (!this.options) return e;
    const t = {};
    for (const n in e) {
      const s = e[n], r = {};
      t[n] = r;
      for (const a in s) {
        let o = !0, l = s[a];
        const c = a.toLowerCase();
        switch (c) {
          case "kd":
          case "ka":
          case "ks":
            this.options && this.options.normalizeRGB && (l = [l[0] / 255, l[1] / 255, l[2] / 255]), this.options && this.options.ignoreZeroRGBs && l[0] === 0 && l[1] === 0 && l[2] === 0 && (o = !1);
            break;
        }
        o && (r[c] = l);
      }
    }
    return t;
  }
  preload() {
    for (const e in this.materialsInfo)
      this.create(e);
  }
  getIndex(e) {
    return this.nameLookup[e];
  }
  getAsArray() {
    let e = 0;
    for (const t in this.materialsInfo)
      this.materialsArray[e] = this.create(t), this.nameLookup[t] = e, e++;
    return this.materialsArray;
  }
  create(e) {
    return this.materials[e] === void 0 && this.createMaterial_(e), this.materials[e];
  }
  createMaterial_(e) {
    const t = this, n = this.materialsInfo[e], s = {
      name: e,
      side: this.side
    };
    function r(o, l) {
      return typeof l != "string" || l === "" ? "" : /^https?:\/\//i.test(l) ? l : o + l;
    }
    function a(o, l) {
      if (s[o]) return;
      const c = t.getTextureParams(l, s), h = t.loadTexture(r(t.baseUrl, c.url));
      h.repeat.copy(c.scale), h.offset.copy(c.offset), h.wrapS = t.wrap, h.wrapT = t.wrap, (o === "map" || o === "emissiveMap") && (h.colorSpace = ft), s[o] = h;
    }
    for (const o in n) {
      const l = n[o];
      let c;
      if (l !== "")
        switch (o.toLowerCase()) {
          case "kd":
            s.color = new Q().fromArray(l).convertSRGBToLinear();
            break;
          case "ks":
            s.specular = new Q().fromArray(l).convertSRGBToLinear();
            break;
          case "ke":
            s.emissive = new Q().fromArray(l).convertSRGBToLinear();
            break;
          case "map_kd":
            a("map", l);
            break;
          case "map_ks":
            a("specularMap", l);
            break;
          case "map_ke":
            a("emissiveMap", l);
            break;
          case "norm":
            a("normalMap", l);
            break;
          case "map_bump":
          case "bump":
            a("bumpMap", l);
            break;
          case "map_d":
            a("alphaMap", l), s.transparent = !0;
            break;
          case "ns":
            s.shininess = parseFloat(l);
            break;
          case "d":
            c = parseFloat(l), c < 1 && (s.opacity = c, s.transparent = !0);
            break;
          case "tr":
            c = parseFloat(l), this.options && this.options.invertTrProperty && (c = 1 - c), c > 0 && (s.opacity = 1 - c, s.transparent = !0);
            break;
        }
    }
    return this.materials[e] = new yr(s), this.materials[e];
  }
  getTextureParams(e, t) {
    const n = {
      scale: new k(1, 1),
      offset: new k(0, 0)
    }, s = e.split(/\s+/);
    let r;
    return r = s.indexOf("-bm"), r >= 0 && (t.bumpScale = parseFloat(s[r + 1]), s.splice(r, 2)), r = s.indexOf("-s"), r >= 0 && (n.scale.set(parseFloat(s[r + 1]), parseFloat(s[r + 2])), s.splice(r, 4)), r = s.indexOf("-o"), r >= 0 && (n.offset.set(parseFloat(s[r + 1]), parseFloat(s[r + 2])), s.splice(r, 4)), n.url = s.join(" ").trim(), n;
  }
  loadTexture(e, t, n, s, r) {
    const a = this.manager !== void 0 ? this.manager : fg;
    let o = a.getHandler(e);
    o === null && (o = new Ys(a)), o.setCrossOrigin && o.setCrossOrigin(this.crossOrigin);
    const l = o.load(e, n, s, r);
    return t !== void 0 && (l.mapping = t), l;
  }
}
class X3 extends Vt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const r = this, a = new En(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
      const l = r.parse(JSON.parse(o));
      t && t(l);
    }, n, s);
  }
  parse(e) {
    return new q3(e);
  }
}
class q3 {
  constructor(e) {
    this.isFont = !0, this.type = "Font", this.data = e;
  }
  generateShapes(e, t = 100) {
    const n = [], s = Y3(e, t, this.data);
    for (let r = 0, a = s.length; r < a; r++)
      n.push(...s[r].toShapes());
    return n;
  }
}
function Y3(i, e, t) {
  const n = Array.from(i), s = e / t.resolution, r = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * s, a = [];
  let o = 0, l = 0;
  for (let c = 0; c < n.length; c++) {
    const h = n[c];
    if (h === `
`)
      o = 0, l -= r;
    else {
      const u = j3(h, s, o, l, t);
      o += u.offsetX, a.push(u.path);
    }
  }
  return a;
}
function j3(i, e, t, n, s) {
  const r = s.glyphs[i] || s.glyphs["?"];
  if (!r) {
    console.error('THREE.Font: character "' + i + '" does not exists in font family ' + s.familyName + ".");
    return;
  }
  const a = new gM();
  let o, l, c, h, u, d, f, m;
  if (r.o) {
    const g = r._cachedOutline || (r._cachedOutline = r.o.split(" "));
    for (let p = 0, v = g.length; p < v; )
      switch (g[p++]) {
        case "m":
          o = g[p++] * e + t, l = g[p++] * e + n, a.moveTo(o, l);
          break;
        case "l":
          o = g[p++] * e + t, l = g[p++] * e + n, a.lineTo(o, l);
          break;
        case "q":
          c = g[p++] * e + t, h = g[p++] * e + n, u = g[p++] * e + t, d = g[p++] * e + n, a.quadraticCurveTo(u, d, c, h);
          break;
        case "b":
          c = g[p++] * e + t, h = g[p++] * e + n, u = g[p++] * e + t, d = g[p++] * e + n, f = g[p++] * e + t, m = g[p++] * e + n, a.bezierCurveTo(u, d, f, m, c, h);
          break;
      }
  }
  return { offsetX: r.ha * e, path: a };
}
const M_ = { type: "change" }, Zf = { type: "start" }, b_ = { type: "end" }, Kh = new Oa(), S_ = new as(), Z3 = Math.cos(70 * Kn.DEG2RAD);
class $3 extends bs {
  constructor(e, t) {
    super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new T(), this.cursor = new T(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: aa.ROTATE, MIDDLE: aa.DOLLY, RIGHT: aa.PAN }, this.touches = { ONE: oa.ROTATE, TWO: oa.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
      return o.phi;
    }, this.getAzimuthalAngle = function() {
      return o.theta;
    }, this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    }, this.listenToKeyEvents = function(O) {
      O.addEventListener("keydown", C), this._domElementKeyEvents = O;
    }, this.stopListenToKeyEvents = function() {
      this._domElementKeyEvents.removeEventListener("keydown", C), this._domElementKeyEvents = null;
    }, this.saveState = function() {
      n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
    }, this.reset = function() {
      n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(M_), n.update(), r = s.NONE;
    }, this.update = function() {
      const O = new T(), me = new pt().setFromUnitVectors(e.up, new T(0, 1, 0)), ie = me.clone().invert(), Ve = new T(), Ie = new pt(), ke = new T(), Le = 2 * Math.PI;
      return function(rt = null) {
        const U = n.object.position;
        O.copy(U).sub(n.target), O.applyQuaternion(me), o.setFromVector3(O), n.autoRotate && r === s.NONE && D(b(rt)), n.enableDamping ? (o.theta += l.theta * n.dampingFactor, o.phi += l.phi * n.dampingFactor) : (o.theta += l.theta, o.phi += l.phi);
        let Me = n.minAzimuthAngle, oe = n.maxAzimuthAngle;
        isFinite(Me) && isFinite(oe) && (Me < -Math.PI ? Me += Le : Me > Math.PI && (Me -= Le), oe < -Math.PI ? oe += Le : oe > Math.PI && (oe -= Le), Me <= oe ? o.theta = Math.max(Me, Math.min(oe, o.theta)) : o.theta = o.theta > (Me + oe) / 2 ? Math.max(Me, o.theta) : Math.min(oe, o.theta)), o.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, o.phi)), o.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(h, n.dampingFactor) : n.target.add(h), n.target.sub(n.cursor), n.target.clampLength(n.minTargetRadius, n.maxTargetRadius), n.target.add(n.cursor), n.zoomToCursor && S || n.object.isOrthographicCamera ? o.radius = j(o.radius) : o.radius = j(o.radius * c), O.setFromSpherical(o), O.applyQuaternion(ie), U.copy(n.target).add(O), n.object.lookAt(n.target), n.enableDamping === !0 ? (l.theta *= 1 - n.dampingFactor, l.phi *= 1 - n.dampingFactor, h.multiplyScalar(1 - n.dampingFactor)) : (l.set(0, 0, 0), h.set(0, 0, 0));
        let K = !1;
        if (n.zoomToCursor && S) {
          let fe = null;
          if (n.object.isPerspectiveCamera) {
            const Ue = O.length();
            fe = j(Ue * c);
            const at = Ue - fe;
            n.object.position.addScaledVector(x, at), n.object.updateMatrixWorld();
          } else if (n.object.isOrthographicCamera) {
            const Ue = new T(M.x, M.y, 0);
            Ue.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / c)), n.object.updateProjectionMatrix(), K = !0;
            const at = new T(M.x, M.y, 0);
            at.unproject(n.object), n.object.position.sub(at).add(Ue), n.object.updateMatrixWorld(), fe = O.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
          fe !== null && (this.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(fe).add(n.object.position) : (Kh.origin.copy(n.object.position), Kh.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(Kh.direction)) < Z3 ? e.lookAt(n.target) : (S_.setFromNormalAndCoplanarPoint(n.object.up, n.target), Kh.intersectPlane(S_, n.target))));
        } else n.object.isOrthographicCamera && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / c)), n.object.updateProjectionMatrix(), K = !0);
        return c = 1, S = !1, K || Ve.distanceToSquared(n.object.position) > a || 8 * (1 - Ie.dot(n.object.quaternion)) > a || ke.distanceToSquared(n.target) > 0 ? (n.dispatchEvent(M_), Ve.copy(n.object.position), Ie.copy(n.object.quaternion), ke.copy(n.target), K = !1, !0) : !1;
      };
    }(), this.dispose = function() {
      n.domElement.removeEventListener("contextmenu", ae), n.domElement.removeEventListener("pointerdown", Ee), n.domElement.removeEventListener("pointercancel", Ge), n.domElement.removeEventListener("wheel", P), n.domElement.removeEventListener("pointermove", Re), n.domElement.removeEventListener("pointerup", Ge), n._domElementKeyEvents !== null && (n._domElementKeyEvents.removeEventListener("keydown", C), n._domElementKeyEvents = null);
    };
    const n = this, s = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let r = s.NONE;
    const a = 1e-6, o = new Wp(), l = new Wp();
    let c = 1;
    const h = new T(), u = new k(), d = new k(), f = new k(), m = new k(), g = new k(), p = new k(), v = new k(), y = new k(), _ = new k(), x = new T(), M = new k();
    let S = !1;
    const w = [], E = {};
    function b(O) {
      return O !== null ? 2 * Math.PI / 60 * n.autoRotateSpeed * O : 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
    }
    function A() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function D(O) {
      l.theta -= O;
    }
    function B(O) {
      l.phi -= O;
    }
    const X = function() {
      const O = new T();
      return function(ie, Ve) {
        O.setFromMatrixColumn(Ve, 0), O.multiplyScalar(-ie), h.add(O);
      };
    }(), L = function() {
      const O = new T();
      return function(ie, Ve) {
        n.screenSpacePanning === !0 ? O.setFromMatrixColumn(Ve, 1) : (O.setFromMatrixColumn(Ve, 0), O.crossVectors(n.object.up, O)), O.multiplyScalar(ie), h.add(O);
      };
    }(), F = function() {
      const O = new T();
      return function(ie, Ve) {
        const Ie = n.domElement;
        if (n.object.isPerspectiveCamera) {
          const ke = n.object.position;
          O.copy(ke).sub(n.target);
          let Le = O.length();
          Le *= Math.tan(n.object.fov / 2 * Math.PI / 180), X(2 * ie * Le / Ie.clientHeight, n.object.matrix), L(2 * Ve * Le / Ie.clientHeight, n.object.matrix);
        } else n.object.isOrthographicCamera ? (X(ie * (n.object.right - n.object.left) / n.object.zoom / Ie.clientWidth, n.object.matrix), L(Ve * (n.object.top - n.object.bottom) / n.object.zoom / Ie.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
      };
    }();
    function H(O) {
      n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? c /= O : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function G(O) {
      n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? c *= O : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function te(O) {
      if (!n.zoomToCursor)
        return;
      S = !0;
      const me = n.domElement.getBoundingClientRect(), ie = O.clientX - me.left, Ve = O.clientY - me.top, Ie = me.width, ke = me.height;
      M.x = ie / Ie * 2 - 1, M.y = -(Ve / ke) * 2 + 1, x.set(M.x, M.y, 1).unproject(n.object).sub(n.object.position).normalize();
    }
    function j(O) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, O));
    }
    function J(O) {
      u.set(O.clientX, O.clientY);
    }
    function N(O) {
      te(O), v.set(O.clientX, O.clientY);
    }
    function q(O) {
      m.set(O.clientX, O.clientY);
    }
    function ge(O) {
      d.set(O.clientX, O.clientY), f.subVectors(d, u).multiplyScalar(n.rotateSpeed);
      const me = n.domElement;
      D(2 * Math.PI * f.x / me.clientHeight), B(2 * Math.PI * f.y / me.clientHeight), u.copy(d), n.update();
    }
    function de(O) {
      y.set(O.clientX, O.clientY), _.subVectors(y, v), _.y > 0 ? H(A()) : _.y < 0 && G(A()), v.copy(y), n.update();
    }
    function be(O) {
      g.set(O.clientX, O.clientY), p.subVectors(g, m).multiplyScalar(n.panSpeed), F(p.x, p.y), m.copy(g), n.update();
    }
    function Fe(O) {
      te(O), O.deltaY < 0 ? G(A()) : O.deltaY > 0 && H(A()), n.update();
    }
    function ze(O) {
      let me = !1;
      switch (O.code) {
        case n.keys.UP:
          O.ctrlKey || O.metaKey || O.shiftKey ? B(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : F(0, n.keyPanSpeed), me = !0;
          break;
        case n.keys.BOTTOM:
          O.ctrlKey || O.metaKey || O.shiftKey ? B(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : F(0, -n.keyPanSpeed), me = !0;
          break;
        case n.keys.LEFT:
          O.ctrlKey || O.metaKey || O.shiftKey ? D(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : F(n.keyPanSpeed, 0), me = !0;
          break;
        case n.keys.RIGHT:
          O.ctrlKey || O.metaKey || O.shiftKey ? D(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : F(-n.keyPanSpeed, 0), me = !0;
          break;
      }
      me && (O.preventDefault(), n.update());
    }
    function Ne() {
      if (w.length === 1)
        u.set(w[0].pageX, w[0].pageY);
      else {
        const O = 0.5 * (w[0].pageX + w[1].pageX), me = 0.5 * (w[0].pageY + w[1].pageY);
        u.set(O, me);
      }
    }
    function Xe() {
      if (w.length === 1)
        m.set(w[0].pageX, w[0].pageY);
      else {
        const O = 0.5 * (w[0].pageX + w[1].pageX), me = 0.5 * (w[0].pageY + w[1].pageY);
        m.set(O, me);
      }
    }
    function ct() {
      const O = w[0].pageX - w[1].pageX, me = w[0].pageY - w[1].pageY, ie = Math.sqrt(O * O + me * me);
      v.set(0, ie);
    }
    function He() {
      n.enableZoom && ct(), n.enablePan && Xe();
    }
    function I() {
      n.enableZoom && ct(), n.enableRotate && Ne();
    }
    function xe(O) {
      if (w.length == 1)
        d.set(O.pageX, O.pageY);
      else {
        const ie = we(O), Ve = 0.5 * (O.pageX + ie.x), Ie = 0.5 * (O.pageY + ie.y);
        d.set(Ve, Ie);
      }
      f.subVectors(d, u).multiplyScalar(n.rotateSpeed);
      const me = n.domElement;
      D(2 * Math.PI * f.x / me.clientHeight), B(2 * Math.PI * f.y / me.clientHeight), u.copy(d);
    }
    function ee(O) {
      if (w.length === 1)
        g.set(O.pageX, O.pageY);
      else {
        const me = we(O), ie = 0.5 * (O.pageX + me.x), Ve = 0.5 * (O.pageY + me.y);
        g.set(ie, Ve);
      }
      p.subVectors(g, m).multiplyScalar(n.panSpeed), F(p.x, p.y), m.copy(g);
    }
    function ce(O) {
      const me = we(O), ie = O.pageX - me.x, Ve = O.pageY - me.y, Ie = Math.sqrt(ie * ie + Ve * Ve);
      y.set(0, Ie), _.set(0, Math.pow(y.y / v.y, n.zoomSpeed)), H(_.y), v.copy(y);
    }
    function se(O) {
      n.enableZoom && ce(O), n.enablePan && ee(O);
    }
    function De(O) {
      n.enableZoom && ce(O), n.enableRotate && xe(O);
    }
    function Ee(O) {
      n.enabled !== !1 && (w.length === 0 && (n.domElement.setPointerCapture(O.pointerId), n.domElement.addEventListener("pointermove", Re), n.domElement.addEventListener("pointerup", Ge)), ue(O), O.pointerType === "touch" ? W(O) : nt(O));
    }
    function Re(O) {
      n.enabled !== !1 && (O.pointerType === "touch" ? he(O) : Ct(O));
    }
    function Ge(O) {
      Pe(O), w.length === 0 && (n.domElement.releasePointerCapture(O.pointerId), n.domElement.removeEventListener("pointermove", Re), n.domElement.removeEventListener("pointerup", Ge)), n.dispatchEvent(b_), r = s.NONE;
    }
    function nt(O) {
      let me;
      switch (O.button) {
        case 0:
          me = n.mouseButtons.LEFT;
          break;
        case 1:
          me = n.mouseButtons.MIDDLE;
          break;
        case 2:
          me = n.mouseButtons.RIGHT;
          break;
        default:
          me = -1;
      }
      switch (me) {
        case aa.DOLLY:
          if (n.enableZoom === !1) return;
          N(O), r = s.DOLLY;
          break;
        case aa.ROTATE:
          if (O.ctrlKey || O.metaKey || O.shiftKey) {
            if (n.enablePan === !1) return;
            q(O), r = s.PAN;
          } else {
            if (n.enableRotate === !1) return;
            J(O), r = s.ROTATE;
          }
          break;
        case aa.PAN:
          if (O.ctrlKey || O.metaKey || O.shiftKey) {
            if (n.enableRotate === !1) return;
            J(O), r = s.ROTATE;
          } else {
            if (n.enablePan === !1) return;
            q(O), r = s.PAN;
          }
          break;
        default:
          r = s.NONE;
      }
      r !== s.NONE && n.dispatchEvent(Zf);
    }
    function Ct(O) {
      switch (r) {
        case s.ROTATE:
          if (n.enableRotate === !1) return;
          ge(O);
          break;
        case s.DOLLY:
          if (n.enableZoom === !1) return;
          de(O);
          break;
        case s.PAN:
          if (n.enablePan === !1) return;
          be(O);
          break;
      }
    }
    function P(O) {
      n.enabled === !1 || n.enableZoom === !1 || r !== s.NONE || (O.preventDefault(), n.dispatchEvent(Zf), Fe(O), n.dispatchEvent(b_));
    }
    function C(O) {
      n.enabled === !1 || n.enablePan === !1 || ze(O);
    }
    function W(O) {
      switch (pe(O), w.length) {
        case 1:
          switch (n.touches.ONE) {
            case oa.ROTATE:
              if (n.enableRotate === !1) return;
              Ne(), r = s.TOUCH_ROTATE;
              break;
            case oa.PAN:
              if (n.enablePan === !1) return;
              Xe(), r = s.TOUCH_PAN;
              break;
            default:
              r = s.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case oa.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1) return;
              He(), r = s.TOUCH_DOLLY_PAN;
              break;
            case oa.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1) return;
              I(), r = s.TOUCH_DOLLY_ROTATE;
              break;
            default:
              r = s.NONE;
          }
          break;
        default:
          r = s.NONE;
      }
      r !== s.NONE && n.dispatchEvent(Zf);
    }
    function he(O) {
      switch (pe(O), r) {
        case s.TOUCH_ROTATE:
          if (n.enableRotate === !1) return;
          xe(O), n.update();
          break;
        case s.TOUCH_PAN:
          if (n.enablePan === !1) return;
          ee(O), n.update();
          break;
        case s.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1) return;
          se(O), n.update();
          break;
        case s.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1) return;
          De(O), n.update();
          break;
        default:
          r = s.NONE;
      }
    }
    function ae(O) {
      n.enabled !== !1 && O.preventDefault();
    }
    function ue(O) {
      w.push(O);
    }
    function Pe(O) {
      delete E[O.pointerId];
      for (let me = 0; me < w.length; me++)
        if (w[me].pointerId == O.pointerId) {
          w.splice(me, 1);
          return;
        }
    }
    function pe(O) {
      let me = E[O.pointerId];
      me === void 0 && (me = new k(), E[O.pointerId] = me), me.set(O.pageX, O.pageY);
    }
    function we(O) {
      const me = O.pointerId === w[0].pointerId ? w[1] : w[0];
      return E[me.pointerId];
    }
    n.domElement.addEventListener("contextmenu", ae), n.domElement.addEventListener("pointerdown", Ee), n.domElement.addEventListener("pointercancel", Ge), n.domElement.addEventListener("wheel", P, { passive: !1 }), this.update();
  }
}
const ra = new Fd(), Rn = new T(), rr = new T(), Rt = new pt(), w_ = {
  X: new T(1, 0, 0),
  Y: new T(0, 1, 0),
  Z: new T(0, 0, 1)
}, $f = { type: "change" }, T_ = { type: "mouseDown" }, E_ = { type: "mouseUp", mode: null }, A_ = { type: "objectChange" };
class K3 extends Ze {
  constructor(e, t) {
    super(), t === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = !0, this.visible = !1, this.domElement = t, this.domElement.style.touchAction = "none";
    const n = new iL();
    this._gizmo = n, this.add(n);
    const s = new sL();
    this._plane = s, this.add(s);
    const r = this;
    function a(y, _) {
      let x = _;
      Object.defineProperty(r, y, {
        get: function() {
          return x !== void 0 ? x : _;
        },
        set: function(M) {
          x !== M && (x = M, s[y] = M, n[y] = M, r.dispatchEvent({ type: y + "-changed", value: M }), r.dispatchEvent($f));
        }
      }), r[y] = _, s[y] = _, n[y] = _;
    }
    a("camera", e), a("object", void 0), a("enabled", !0), a("axis", null), a("mode", "translate"), a("translationSnap", null), a("rotationSnap", null), a("scaleSnap", null), a("space", "world"), a("size", 1), a("dragging", !1), a("showX", !0), a("showY", !0), a("showZ", !0);
    const o = new T(), l = new T(), c = new pt(), h = new pt(), u = new T(), d = new pt(), f = new T(), m = new T(), g = new T(), p = 0, v = new T();
    a("worldPosition", o), a("worldPositionStart", l), a("worldQuaternion", c), a("worldQuaternionStart", h), a("cameraPosition", u), a("cameraQuaternion", d), a("pointStart", f), a("pointEnd", m), a("rotationAxis", g), a("rotationAngle", p), a("eye", v), this._offset = new T(), this._startNorm = new T(), this._endNorm = new T(), this._cameraScale = new T(), this._parentPosition = new T(), this._parentQuaternion = new pt(), this._parentQuaternionInv = new pt(), this._parentScale = new T(), this._worldScaleStart = new T(), this._worldQuaternionInv = new pt(), this._worldScale = new T(), this._positionStart = new T(), this._quaternionStart = new pt(), this._scaleStart = new T(), this._getPointer = Q3.bind(this), this._onPointerDown = eL.bind(this), this._onPointerHover = J3.bind(this), this._onPointerMove = tL.bind(this), this._onPointerUp = nL.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld  updates key transformation variables
  updateMatrixWorld() {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0) return;
    ra.setFromCamera(e, this.camera);
    const t = Kf(this._gizmo.picker[this.mode], ra);
    t ? this.axis = t.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e.button !== 0) && this.axis !== null) {
      ra.setFromCamera(e, this.camera);
      const t = Kf(this._plane, ra, !0);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, T_.mode = this.mode, this.dispatchEvent(T_);
    }
  }
  pointerMove(e) {
    const t = this.axis, n = this.mode, s = this.object;
    let r = this.space;
    if (n === "scale" ? r = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (r = "world"), s === void 0 || t === null || this.dragging === !1 || e.button !== -1) return;
    ra.setFromCamera(e, this.camera);
    const a = Kf(this._plane, ra, !0);
    if (a) {
      if (this.pointEnd.copy(a.point).sub(this.worldPositionStart), n === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), r === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), r === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), s.position.copy(this._offset).add(this._positionStart), this.translationSnap && (r === "local" && (s.position.applyQuaternion(Rt.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (s.position.x = Math.round(s.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (s.position.y = Math.round(s.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (s.position.z = Math.round(s.position.z / this.translationSnap) * this.translationSnap), s.position.applyQuaternion(this._quaternionStart)), r === "world" && (s.parent && s.position.add(Rn.setFromMatrixPosition(s.parent.matrixWorld)), t.search("X") !== -1 && (s.position.x = Math.round(s.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (s.position.y = Math.round(s.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (s.position.z = Math.round(s.position.z / this.translationSnap) * this.translationSnap), s.parent && s.position.sub(Rn.setFromMatrixPosition(s.parent.matrixWorld))));
      else if (n === "scale") {
        if (t.search("XYZ") !== -1) {
          let o = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), rr.set(o, o, o);
        } else
          Rn.copy(this.pointStart), rr.copy(this.pointEnd), Rn.applyQuaternion(this._worldQuaternionInv), rr.applyQuaternion(this._worldQuaternionInv), rr.divide(Rn), t.search("X") === -1 && (rr.x = 1), t.search("Y") === -1 && (rr.y = 1), t.search("Z") === -1 && (rr.z = 1);
        s.scale.copy(this._scaleStart).multiply(rr), this.scaleSnap && (t.search("X") !== -1 && (s.scale.x = Math.round(s.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (s.scale.y = Math.round(s.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (s.scale.z = Math.round(s.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (n === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const o = 20 / this.worldPosition.distanceTo(Rn.setFromMatrixPosition(this.camera.matrixWorld));
        let l = !1;
        t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Rn.copy(this.rotationAxis).cross(this.eye)) * o) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(w_[t]), Rn.copy(w_[t]), r === "local" && Rn.applyQuaternion(this.worldQuaternion), Rn.cross(this.eye), Rn.length() === 0 ? l = !0 : this.rotationAngle = this._offset.dot(Rn.normalize()) * o), (t === "E" || l) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), r === "local" && t !== "E" && t !== "XYZE" ? (s.quaternion.copy(this._quaternionStart), s.quaternion.multiply(Rt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), s.quaternion.copy(Rt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), s.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent($f), this.dispatchEvent(A_);
    }
  }
  pointerUp(e) {
    e.button === 0 && (this.dragging && this.axis !== null && (E_.mode = this.mode, this.dispatchEvent(E_)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
  // Set current object
  attach(e) {
    return this.object = e, this.visible = !0, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.visible = !1, this.axis = null, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent($f), this.dispatchEvent(A_), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return ra;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function Q3(i) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: i.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (i.clientX - e.left) / e.width * 2 - 1,
      y: -(i.clientY - e.top) / e.height * 2 + 1,
      button: i.button
    };
  }
}
function J3(i) {
  if (this.enabled)
    switch (i.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(i));
        break;
    }
}
function eL(i) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(i.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(i)), this.pointerDown(this._getPointer(i)));
}
function tL(i) {
  this.enabled && this.pointerMove(this._getPointer(i));
}
function nL(i) {
  this.enabled && (this.domElement.releasePointerCapture(i.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(i)));
}
function Kf(i, e, t) {
  const n = e.intersectObject(i, !0);
  for (let s = 0; s < n.length; s++)
    if (n[s].object.visible || t)
      return n[s];
  return !1;
}
const Qh = new Jn(), bt = new T(0, 1, 0), C_ = new T(0, 0, 0), R_ = new _e(), Jh = new pt(), xu = new pt(), Ki = new T(), P_ = new _e(), Dl = new T(1, 0, 0), ua = new T(0, 1, 0), Ol = new T(0, 0, 1), eu = new T(), wl = new T(), Tl = new T();
class iL extends Ze {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new on({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), t = new Jt({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), n = e.clone();
    n.opacity = 0.15;
    const s = t.clone();
    s.opacity = 0.5;
    const r = e.clone();
    r.color.setHex(16711680);
    const a = e.clone();
    a.color.setHex(65280);
    const o = e.clone();
    o.color.setHex(255);
    const l = e.clone();
    l.color.setHex(16711680), l.opacity = 0.5;
    const c = e.clone();
    c.color.setHex(65280), c.opacity = 0.5;
    const h = e.clone();
    h.color.setHex(255), h.opacity = 0.5;
    const u = e.clone();
    u.opacity = 0.25;
    const d = e.clone();
    d.color.setHex(16776960), d.opacity = 0.25, e.clone().color.setHex(16776960);
    const m = e.clone();
    m.color.setHex(7895160);
    const g = new qt(0, 0.04, 0.1, 12);
    g.translate(0, 0.05, 0);
    const p = new Pt(0.08, 0.08, 0.08);
    p.translate(0, 0.04, 0);
    const v = new Be();
    v.setAttribute("position", new ye([0, 0, 0, 1, 0, 0], 3));
    const y = new qt(75e-4, 75e-4, 0.5, 3);
    y.translate(0, 0.25, 0);
    function _(F, H) {
      const G = new os(F, 75e-4, 3, 64, H * Math.PI * 2);
      return G.rotateY(Math.PI / 2), G.rotateX(Math.PI / 2), G;
    }
    function x() {
      const F = new Be();
      return F.setAttribute("position", new ye([0, 0, 0, 1, 1, 1], 3)), F;
    }
    const M = {
      X: [
        [new le(g, r), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new le(g, r), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new le(y, r), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new le(g, a), [0, 0.5, 0]],
        [new le(g, a), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new le(y, a)]
      ],
      Z: [
        [new le(g, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new le(g, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new le(y, o), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new le(new Bs(0.1, 0), u.clone()), [0, 0, 0]]
      ],
      XY: [
        [new le(new Pt(0.15, 0.15, 0.01), h.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new le(new Pt(0.15, 0.15, 0.01), l.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new le(new Pt(0.15, 0.15, 0.01), c.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, S = {
      X: [
        [new le(new qt(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new le(new qt(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new le(new qt(0.2, 0, 0.6, 4), n), [0, 0.3, 0]],
        [new le(new qt(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new le(new qt(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new le(new qt(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new le(new Bs(0.2, 0), n)]
      ],
      XY: [
        [new le(new Pt(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new le(new Pt(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new le(new Pt(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, w = {
      START: [
        [new le(new Bs(0.01, 2), s), null, null, null, "helper"]
      ],
      END: [
        [new le(new Bs(0.01, 2), s), null, null, null, "helper"]
      ],
      DELTA: [
        [new pn(x(), s), null, null, null, "helper"]
      ],
      X: [
        [new pn(v, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new pn(v, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new pn(v, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, E = {
      XYZE: [
        [new le(_(0.5, 1), m), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new le(_(0.5, 0.5), r)]
      ],
      Y: [
        [new le(_(0.5, 0.5), a), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new le(_(0.5, 0.5), o), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new le(_(0.75, 1), d), null, [0, Math.PI / 2, 0]]
      ]
    }, b = {
      AXIS: [
        [new pn(v, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, A = {
      XYZE: [
        [new le(new Fa(0.25, 10, 8), n)]
      ],
      X: [
        [new le(new os(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new le(new os(0.5, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new le(new os(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new le(new os(0.75, 0.1, 2, 24), n)]
      ]
    }, D = {
      X: [
        [new le(p, r), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new le(y, r), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new le(p, r), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new le(p, a), [0, 0.5, 0]],
        [new le(y, a)],
        [new le(p, a), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new le(p, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new le(y, o), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new le(p, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new le(new Pt(0.15, 0.15, 0.01), h), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new le(new Pt(0.15, 0.15, 0.01), l), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new le(new Pt(0.15, 0.15, 0.01), c), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new le(new Pt(0.1, 0.1, 0.1), u.clone())]
      ]
    }, B = {
      X: [
        [new le(new qt(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new le(new qt(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new le(new qt(0.2, 0, 0.6, 4), n), [0, 0.3, 0]],
        [new le(new qt(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new le(new qt(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new le(new qt(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new le(new Pt(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new le(new Pt(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new le(new Pt(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new le(new Pt(0.2, 0.2, 0.2), n), [0, 0, 0]]
      ]
    }, X = {
      X: [
        [new pn(v, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new pn(v, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new pn(v, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function L(F) {
      const H = new Ze();
      for (const G in F)
        for (let te = F[G].length; te--; ) {
          const j = F[G][te][0].clone(), J = F[G][te][1], N = F[G][te][2], q = F[G][te][3], ge = F[G][te][4];
          j.name = G, j.tag = ge, J && j.position.set(J[0], J[1], J[2]), N && j.rotation.set(N[0], N[1], N[2]), q && j.scale.set(q[0], q[1], q[2]), j.updateMatrix();
          const de = j.geometry.clone();
          de.applyMatrix4(j.matrix), j.geometry = de, j.renderOrder = 1 / 0, j.position.set(0, 0, 0), j.rotation.set(0, 0, 0), j.scale.set(1, 1, 1), H.add(j);
        }
      return H;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = L(M)), this.add(this.gizmo.rotate = L(E)), this.add(this.gizmo.scale = L(D)), this.add(this.picker.translate = L(S)), this.add(this.picker.rotate = L(A)), this.add(this.picker.scale = L(B)), this.add(this.helper.translate = L(w)), this.add(this.helper.rotate = L(b)), this.add(this.helper.scale = L(X)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(e) {
    const n = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : xu;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let s = [];
    s = s.concat(this.picker[this.mode].children), s = s.concat(this.gizmo[this.mode].children), s = s.concat(this.helper[this.mode].children);
    for (let r = 0; r < s.length; r++) {
      const a = s[r];
      a.visible = !0, a.rotation.set(0, 0, 0), a.position.copy(this.worldPosition);
      let o;
      if (this.camera.isOrthographicCamera ? o = (this.camera.top - this.camera.bottom) / this.camera.zoom : o = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), a.scale.set(1, 1, 1).multiplyScalar(o * this.size / 4), a.tag === "helper") {
        a.visible = !1, a.name === "AXIS" ? (a.visible = !!this.axis, this.axis === "X" && (Rt.setFromEuler(Qh.set(0, 0, 0)), a.quaternion.copy(n).multiply(Rt), Math.abs(bt.copy(Dl).applyQuaternion(n).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Y" && (Rt.setFromEuler(Qh.set(0, 0, Math.PI / 2)), a.quaternion.copy(n).multiply(Rt), Math.abs(bt.copy(ua).applyQuaternion(n).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Z" && (Rt.setFromEuler(Qh.set(0, Math.PI / 2, 0)), a.quaternion.copy(n).multiply(Rt), Math.abs(bt.copy(Ol).applyQuaternion(n).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "XYZE" && (Rt.setFromEuler(Qh.set(0, Math.PI / 2, 0)), bt.copy(this.rotationAxis), a.quaternion.setFromRotationMatrix(R_.lookAt(C_, bt, ua)), a.quaternion.multiply(Rt), a.visible = this.dragging), this.axis === "E" && (a.visible = !1)) : a.name === "START" ? (a.position.copy(this.worldPositionStart), a.visible = this.dragging) : a.name === "END" ? (a.position.copy(this.worldPosition), a.visible = this.dragging) : a.name === "DELTA" ? (a.position.copy(this.worldPositionStart), a.quaternion.copy(this.worldQuaternionStart), Rn.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Rn.applyQuaternion(this.worldQuaternionStart.clone().invert()), a.scale.copy(Rn), a.visible = this.dragging) : (a.quaternion.copy(n), this.dragging ? a.position.copy(this.worldPositionStart) : a.position.copy(this.worldPosition), this.axis && (a.visible = this.axis.search(a.name) !== -1));
        continue;
      }
      a.quaternion.copy(n), this.mode === "translate" || this.mode === "scale" ? (a.name === "X" && Math.abs(bt.copy(Dl).applyQuaternion(n).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Y" && Math.abs(bt.copy(ua).applyQuaternion(n).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Z" && Math.abs(bt.copy(Ol).applyQuaternion(n).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XY" && Math.abs(bt.copy(Ol).applyQuaternion(n).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "YZ" && Math.abs(bt.copy(Dl).applyQuaternion(n).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XZ" && Math.abs(bt.copy(ua).applyQuaternion(n).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1)) : this.mode === "rotate" && (Jh.copy(n), bt.copy(this.eye).applyQuaternion(Rt.copy(n).invert()), a.name.search("E") !== -1 && a.quaternion.setFromRotationMatrix(R_.lookAt(this.eye, C_, ua)), a.name === "X" && (Rt.setFromAxisAngle(Dl, Math.atan2(-bt.y, bt.z)), Rt.multiplyQuaternions(Jh, Rt), a.quaternion.copy(Rt)), a.name === "Y" && (Rt.setFromAxisAngle(ua, Math.atan2(bt.x, bt.z)), Rt.multiplyQuaternions(Jh, Rt), a.quaternion.copy(Rt)), a.name === "Z" && (Rt.setFromAxisAngle(Ol, Math.atan2(bt.y, bt.x)), Rt.multiplyQuaternions(Jh, Rt), a.quaternion.copy(Rt))), a.visible = a.visible && (a.name.indexOf("X") === -1 || this.showX), a.visible = a.visible && (a.name.indexOf("Y") === -1 || this.showY), a.visible = a.visible && (a.name.indexOf("Z") === -1 || this.showZ), a.visible = a.visible && (a.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), a.material._color = a.material._color || a.material.color.clone(), a.material._opacity = a.material._opacity || a.material.opacity, a.material.color.copy(a.material._color), a.material.opacity = a.material._opacity, this.enabled && this.axis && (a.name === this.axis || this.axis.split("").some(function(l) {
        return a.name === l;
      })) && (a.material.color.setHex(16776960), a.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class sL extends le {
  constructor() {
    super(
      new Fr(1e5, 1e5, 2, 2),
      new on({ visible: !1, wireframe: !0, side: $t, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), eu.copy(Dl).applyQuaternion(t === "local" ? this.worldQuaternion : xu), wl.copy(ua).applyQuaternion(t === "local" ? this.worldQuaternion : xu), Tl.copy(Ol).applyQuaternion(t === "local" ? this.worldQuaternion : xu), bt.copy(wl), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            bt.copy(this.eye).cross(eu), Ki.copy(eu).cross(bt);
            break;
          case "Y":
            bt.copy(this.eye).cross(wl), Ki.copy(wl).cross(bt);
            break;
          case "Z":
            bt.copy(this.eye).cross(Tl), Ki.copy(Tl).cross(bt);
            break;
          case "XY":
            Ki.copy(Tl);
            break;
          case "YZ":
            Ki.copy(eu);
            break;
          case "XZ":
            bt.copy(Tl), Ki.copy(wl);
            break;
          case "XYZ":
          case "E":
            Ki.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        Ki.set(0, 0, 0);
    }
    Ki.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (P_.lookAt(Rn.set(0, 0, 0), Ki, bt), this.quaternion.setFromRotationMatrix(P_)), super.updateMatrixWorld(e);
  }
}
const Hs = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
class js {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const rL = new Na(-1, 1, 1, -1, 0, 1);
class aL extends Be {
  constructor() {
    super(), this.setAttribute("position", new ye([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new ye([0, 2, 0, 0, 2, 0], 2));
  }
}
const oL = new aL();
class ll {
  constructor(e) {
    this._mesh = new le(oL, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, rL);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class Gg extends js {
  constructor(e, t) {
    super(), this.textureID = t !== void 0 ? t : "tDiffuse", e instanceof mt ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = cn.clone(e.uniforms), this.material = new mt({
      name: e.name !== void 0 ? e.name : "unspecified",
      defines: Object.assign({}, e.defines),
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    })), this.fsQuad = new ll(this.material);
  }
  render(e, t, n) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class L_ extends js {
  constructor(e, t) {
    super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, t, n) {
    const s = e.getContext(), r = e.state;
    r.buffers.color.setMask(!1), r.buffers.depth.setMask(!1), r.buffers.color.setLocked(!0), r.buffers.depth.setLocked(!0);
    let a, o;
    this.inverse ? (a = 0, o = 1) : (a = 1, o = 0), r.buffers.stencil.setTest(!0), r.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), r.buffers.stencil.setFunc(s.ALWAYS, a, 4294967295), r.buffers.stencil.setClear(o), r.buffers.stencil.setLocked(!0), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), r.buffers.color.setLocked(!1), r.buffers.depth.setLocked(!1), r.buffers.color.setMask(!0), r.buffers.depth.setMask(!0), r.buffers.stencil.setLocked(!1), r.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), r.buffers.stencil.setLocked(!0);
  }
}
class lL extends js {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class cL {
  constructor(e, t) {
    if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), t === void 0) {
      const n = e.getSize(new k());
      this._width = n.width, this._height = n.height, t = new xt(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: zt }), t.texture.name = "EffectComposer.rt1";
    } else
      this._width = t.width, this._height = t.height;
    this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new Gg(Hs), this.copyPass.material.blending = vt, this.clock = new qc();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(e, t) {
    this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(e) {
    const t = this.passes.indexOf(e);
    t !== -1 && this.passes.splice(t, 1);
  }
  isLastEnabledPass(e) {
    for (let t = e + 1; t < this.passes.length; t++)
      if (this.passes[t].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const t = this.renderer.getRenderTarget();
    let n = !1;
    for (let s = 0, r = this.passes.length; s < r; s++) {
      const a = this.passes[s];
      if (a.enabled !== !1) {
        if (a.renderToScreen = this.renderToScreen && this.isLastEnabledPass(s), a.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), a.needsSwap) {
          if (n) {
            const o = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
            l.setFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), l.setFunc(o.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        L_ !== void 0 && (a instanceof L_ ? n = !0 : a instanceof lL && (n = !1));
      }
    }
    this.renderer.setRenderTarget(t);
  }
  reset(e) {
    if (e === void 0) {
      const t = this.renderer.getSize(new k());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, t) {
    this._width = e, this._height = t;
    const n = this._width * this._pixelRatio, s = this._height * this._pixelRatio;
    this.renderTarget1.setSize(n, s), this.renderTarget2.setSize(n, s);
    for (let r = 0; r < this.passes.length; r++)
      this.passes[r].setSize(n, s);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class hL extends js {
  constructor(e, t, n = null, s = null, r = null) {
    super(), this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = s, this.clearAlpha = r, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Q();
  }
  render(e, t, n) {
    const s = e.autoClear;
    e.autoClear = !1;
    let r, a;
    this.overrideMaterial !== null && (a = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor)), this.clearAlpha !== null && (r = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(r), this.overrideMaterial !== null && (this.scene.overrideMaterial = a), e.autoClear = s;
  }
}
class mr extends js {
  constructor(e, t, n, s) {
    super(), this.renderScene = t, this.renderCamera = n, this.selectedObjects = s !== void 0 ? s : [], this.visibleEdgeColor = new Q(1, 1, 1), this.hiddenEdgeColor = new Q(0.1, 0.04, 0.02), this.edgeGlow = 0, this.usePatternTexture = !1, this.edgeThickness = 1, this.edgeStrength = 3, this.downSampleRatio = 2, this.pulsePeriod = 0, this._visibilityCache = /* @__PURE__ */ new Map(), this.resolution = e !== void 0 ? new k(e.x, e.y) : new k(256, 256);
    const r = Math.round(this.resolution.x / this.downSampleRatio), a = Math.round(this.resolution.y / this.downSampleRatio);
    this.renderTargetMaskBuffer = new xt(this.resolution.x, this.resolution.y), this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask", this.renderTargetMaskBuffer.texture.generateMipmaps = !1, this.depthMaterial = new Md(), this.depthMaterial.side = $t, this.depthMaterial.depthPacking = Gm, this.depthMaterial.blending = vt, this.prepareMaskMaterial = this.getPrepareMaskMaterial(), this.prepareMaskMaterial.side = $t, this.prepareMaskMaterial.fragmentShader = h(this.prepareMaskMaterial.fragmentShader, this.renderCamera), this.renderTargetDepthBuffer = new xt(this.resolution.x, this.resolution.y, { type: zt }), this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth", this.renderTargetDepthBuffer.texture.generateMipmaps = !1, this.renderTargetMaskDownSampleBuffer = new xt(r, a, { type: zt }), this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample", this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = !1, this.renderTargetBlurBuffer1 = new xt(r, a, { type: zt }), this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1", this.renderTargetBlurBuffer1.texture.generateMipmaps = !1, this.renderTargetBlurBuffer2 = new xt(Math.round(r / 2), Math.round(a / 2), { type: zt }), this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2", this.renderTargetBlurBuffer2.texture.generateMipmaps = !1, this.edgeDetectionMaterial = this.getEdgeDetectionMaterial(), this.renderTargetEdgeBuffer1 = new xt(r, a, { type: zt }), this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1", this.renderTargetEdgeBuffer1.texture.generateMipmaps = !1, this.renderTargetEdgeBuffer2 = new xt(Math.round(r / 2), Math.round(a / 2), { type: zt }), this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2", this.renderTargetEdgeBuffer2.texture.generateMipmaps = !1;
    const o = 4, l = 4;
    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(o), this.separableBlurMaterial1.uniforms.texSize.value.set(r, a), this.separableBlurMaterial1.uniforms.kernelRadius.value = 1, this.separableBlurMaterial2 = this.getSeperableBlurMaterial(l), this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(r / 2), Math.round(a / 2)), this.separableBlurMaterial2.uniforms.kernelRadius.value = l, this.overlayMaterial = this.getOverlayMaterial();
    const c = Hs;
    this.copyUniforms = cn.clone(c.uniforms), this.materialCopy = new mt({
      uniforms: this.copyUniforms,
      vertexShader: c.vertexShader,
      fragmentShader: c.fragmentShader,
      blending: vt,
      depthTest: !1,
      depthWrite: !1
    }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new Q(), this.oldClearAlpha = 1, this.fsQuad = new ll(null), this.tempPulseColor1 = new Q(), this.tempPulseColor2 = new Q(), this.textureMatrix = new _e();
    function h(u, d) {
      const f = d.isPerspectiveCamera ? "perspective" : "orthographic";
      return u.replace(/DEPTH_TO_VIEW_Z/g, f + "DepthToViewZ");
    }
  }
  dispose() {
    this.renderTargetMaskBuffer.dispose(), this.renderTargetDepthBuffer.dispose(), this.renderTargetMaskDownSampleBuffer.dispose(), this.renderTargetBlurBuffer1.dispose(), this.renderTargetBlurBuffer2.dispose(), this.renderTargetEdgeBuffer1.dispose(), this.renderTargetEdgeBuffer2.dispose(), this.depthMaterial.dispose(), this.prepareMaskMaterial.dispose(), this.edgeDetectionMaterial.dispose(), this.separableBlurMaterial1.dispose(), this.separableBlurMaterial2.dispose(), this.overlayMaterial.dispose(), this.materialCopy.dispose(), this.fsQuad.dispose();
  }
  setSize(e, t) {
    this.renderTargetMaskBuffer.setSize(e, t), this.renderTargetDepthBuffer.setSize(e, t);
    let n = Math.round(e / this.downSampleRatio), s = Math.round(t / this.downSampleRatio);
    this.renderTargetMaskDownSampleBuffer.setSize(n, s), this.renderTargetBlurBuffer1.setSize(n, s), this.renderTargetEdgeBuffer1.setSize(n, s), this.separableBlurMaterial1.uniforms.texSize.value.set(n, s), n = Math.round(n / 2), s = Math.round(s / 2), this.renderTargetBlurBuffer2.setSize(n, s), this.renderTargetEdgeBuffer2.setSize(n, s), this.separableBlurMaterial2.uniforms.texSize.value.set(n, s);
  }
  changeVisibilityOfSelectedObjects(e) {
    const t = this._visibilityCache;
    function n(s) {
      s.isMesh && (e === !0 ? s.visible = t.get(s) : (t.set(s, s.visible), s.visible = e));
    }
    for (let s = 0; s < this.selectedObjects.length; s++)
      this.selectedObjects[s].traverse(n);
  }
  changeVisibilityOfNonSelectedObjects(e) {
    const t = this._visibilityCache, n = [];
    function s(a) {
      a.isMesh && n.push(a);
    }
    for (let a = 0; a < this.selectedObjects.length; a++)
      this.selectedObjects[a].traverse(s);
    function r(a) {
      if (a.isMesh || a.isSprite) {
        let o = !1;
        for (let l = 0; l < n.length; l++)
          if (n[l].id === a.id) {
            o = !0;
            break;
          }
        if (o === !1) {
          const l = a.visible;
          (e === !1 || t.get(a) === !0) && (a.visible = e), t.set(a, l);
        }
      } else (a.isPoints || a.isLine) && (e === !0 ? a.visible = t.get(a) : (t.set(a, a.visible), a.visible = e));
    }
    this.renderScene.traverse(r);
  }
  updateTextureMatrix() {
    this.textureMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), this.textureMatrix.multiply(this.renderCamera.projectionMatrix), this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
  }
  render(e, t, n, s, r) {
    if (this.selectedObjects.length > 0) {
      e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
      const a = e.autoClear;
      e.autoClear = !1, r && e.state.buffers.stencil.setTest(!1), e.setClearColor(16777215, 1), this.changeVisibilityOfSelectedObjects(!1);
      const o = this.renderScene.background;
      if (this.renderScene.background = null, this.renderScene.overrideMaterial = this.depthMaterial, e.setRenderTarget(this.renderTargetDepthBuffer), e.clear(), e.render(this.renderScene, this.renderCamera), this.changeVisibilityOfSelectedObjects(!0), this._visibilityCache.clear(), this.updateTextureMatrix(), this.changeVisibilityOfNonSelectedObjects(!1), this.renderScene.overrideMaterial = this.prepareMaskMaterial, this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near, this.renderCamera.far), this.prepareMaskMaterial.uniforms.depthTexture.value = this.renderTargetDepthBuffer.texture, this.prepareMaskMaterial.uniforms.textureMatrix.value = this.textureMatrix, e.setRenderTarget(this.renderTargetMaskBuffer), e.clear(), e.render(this.renderScene, this.renderCamera), this.renderScene.overrideMaterial = null, this.changeVisibilityOfNonSelectedObjects(!0), this._visibilityCache.clear(), this.renderScene.background = o, this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetMaskBuffer.texture, e.setRenderTarget(this.renderTargetMaskDownSampleBuffer), e.clear(), this.fsQuad.render(e), this.tempPulseColor1.copy(this.visibleEdgeColor), this.tempPulseColor2.copy(this.hiddenEdgeColor), this.pulsePeriod > 0) {
        const l = 0.625 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * 0.75 / 2;
        this.tempPulseColor1.multiplyScalar(l), this.tempPulseColor2.multiplyScalar(l);
      }
      this.fsQuad.material = this.edgeDetectionMaterial, this.edgeDetectionMaterial.uniforms.maskTexture.value = this.renderTargetMaskDownSampleBuffer.texture, this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height), this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value = this.tempPulseColor1, this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value = this.tempPulseColor2, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial1, this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = mr.BlurDirectionX, this.separableBlurMaterial1.uniforms.kernelRadius.value = this.edgeThickness, e.setRenderTarget(this.renderTargetBlurBuffer1), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetBlurBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = mr.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial2, this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial2.uniforms.direction.value = mr.BlurDirectionX, e.setRenderTarget(this.renderTargetBlurBuffer2), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetBlurBuffer2.texture, this.separableBlurMaterial2.uniforms.direction.value = mr.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer2), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.overlayMaterial, this.overlayMaterial.uniforms.maskTexture.value = this.renderTargetMaskBuffer.texture, this.overlayMaterial.uniforms.edgeTexture1.value = this.renderTargetEdgeBuffer1.texture, this.overlayMaterial.uniforms.edgeTexture2.value = this.renderTargetEdgeBuffer2.texture, this.overlayMaterial.uniforms.patternTexture.value = this.patternTexture, this.overlayMaterial.uniforms.edgeStrength.value = this.edgeStrength, this.overlayMaterial.uniforms.edgeGlow.value = this.edgeGlow, this.overlayMaterial.uniforms.usePatternTexture.value = this.usePatternTexture, r && e.state.buffers.stencil.setTest(!0), e.setRenderTarget(n), this.fsQuad.render(e), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = a;
    }
    this.renderToScreen && (this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = n.texture, e.setRenderTarget(null), this.fsQuad.render(e));
  }
  getPrepareMaskMaterial() {
    return new mt({
      uniforms: {
        depthTexture: { value: null },
        cameraNearFar: { value: new k(0.5, 0.5) },
        textureMatrix: { value: null }
      },
      vertexShader: `#include <morphtarget_pars_vertex>
				#include <skinning_pars_vertex>

				varying vec4 projTexCoord;
				varying vec4 vPosition;
				uniform mat4 textureMatrix;

				void main() {

					#include <skinbase_vertex>
					#include <begin_vertex>
					#include <morphtarget_vertex>
					#include <skinning_vertex>
					#include <project_vertex>

					vPosition = mvPosition;

					vec4 worldPosition = vec4( transformed, 1.0 );

					#ifdef USE_INSTANCING

						worldPosition = instanceMatrix * worldPosition;

					#endif
					
					worldPosition = modelMatrix * worldPosition;

					projTexCoord = textureMatrix * worldPosition;

				}`,
      fragmentShader: `#include <packing>
				varying vec4 vPosition;
				varying vec4 projTexCoord;
				uniform sampler2D depthTexture;
				uniform vec2 cameraNearFar;

				void main() {

					float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));
					float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );
					float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;
					gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);

				}`
    });
  }
  getEdgeDetectionMaterial() {
    return new mt({
      uniforms: {
        maskTexture: { value: null },
        texSize: { value: new k(0.5, 0.5) },
        visibleEdgeColor: { value: new T(1, 1, 1) },
        hiddenEdgeColor: { value: new T(1, 1, 1) }
      },
      vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform vec2 texSize;
				uniform vec3 visibleEdgeColor;
				uniform vec3 hiddenEdgeColor;

				void main() {
					vec2 invSize = 1.0 / texSize;
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);
					float diff1 = (c1.r - c2.r)*0.5;
					float diff2 = (c3.r - c4.r)*0.5;
					float d = length( vec2(diff1, diff2) );
					float a1 = min(c1.g, c2.g);
					float a2 = min(c3.g, c4.g);
					float visibilityFactor = min(a1, a2);
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);
				}`
    });
  }
  getSeperableBlurMaterial(e) {
    return new mt({
      defines: {
        MAX_RADIUS: e
      },
      uniforms: {
        colorTexture: { value: null },
        texSize: { value: new k(0.5, 0.5) },
        direction: { value: new k(0.5, 0.5) },
        kernelRadius: { value: 1 }
      },
      vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;
				uniform float kernelRadius;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}

				void main() {
					vec2 invSize = 1.0 / texSize;
					float sigma = kernelRadius/2.0;
					float weightSum = gaussianPdf(0.0, sigma);
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);
					vec2 uvOffset = delta;
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {
						float x = kernelRadius * float(i) / float(MAX_RADIUS);
						float w = gaussianPdf(x, sigma);
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
						diffuseSum += ((sample1 + sample2) * w);
						weightSum += (2.0 * w);
						uvOffset += delta;
					}
					gl_FragColor = diffuseSum/weightSum;
				}`
    });
  }
  getOverlayMaterial() {
    return new mt({
      uniforms: {
        maskTexture: { value: null },
        edgeTexture1: { value: null },
        edgeTexture2: { value: null },
        patternTexture: { value: null },
        edgeStrength: { value: 1 },
        edgeGlow: { value: 1 },
        usePatternTexture: { value: 0 }
      },
      vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform sampler2D edgeTexture1;
				uniform sampler2D edgeTexture2;
				uniform sampler2D patternTexture;
				uniform float edgeStrength;
				uniform float edgeGlow;
				uniform bool usePatternTexture;

				void main() {
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);
					vec4 maskColor = texture2D(maskTexture, vUv);
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;
					if(usePatternTexture)
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);
					gl_FragColor = finalColor;
				}`,
      blending: Ta,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    });
  }
}
mr.BlurDirectionX = new k(1, 0);
mr.BlurDirectionY = new k(0, 1);
const uL = {
  name: "OutputShader",
  uniforms: {
    tDiffuse: { value: null },
    toneMappingExposure: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
	
		precision highp float;

		uniform sampler2D tDiffuse;

		#include <tonemapping_pars_fragment>
		#include <colorspace_pars_fragment>

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			// tone mapping

			#ifdef LINEAR_TONE_MAPPING

				gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );

			#elif defined( REINHARD_TONE_MAPPING )

				gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );

			#elif defined( CINEON_TONE_MAPPING )

				gl_FragColor.rgb = OptimizedCineonToneMapping( gl_FragColor.rgb );

			#elif defined( ACES_FILMIC_TONE_MAPPING )

				gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );

			#endif

			// color space

			#ifdef SRGB_TRANSFER

				gl_FragColor = sRGBTransferOETF( gl_FragColor );

			#endif

		}`
  )
};
class dL extends js {
  constructor() {
    super();
    const e = uL;
    this.uniforms = cn.clone(e.uniforms), this.material = new og({
      name: e.name,
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    }), this.fsQuad = new ll(this.material), this._outputColorSpace = null, this._toneMapping = null;
  }
  render(e, t, n) {
    this.uniforms.tDiffuse.value = n.texture, this.uniforms.toneMappingExposure.value = e.toneMappingExposure, (this._outputColorSpace !== e.outputColorSpace || this._toneMapping !== e.toneMapping) && (this._outputColorSpace = e.outputColorSpace, this._toneMapping = e.toneMapping, this.material.defines = {}, gt.getTransfer(this._outputColorSpace) === Mt && (this.material.defines.SRGB_TRANSFER = ""), this._toneMapping === od ? this.material.defines.LINEAR_TONE_MAPPING = "" : this._toneMapping === ld ? this.material.defines.REINHARD_TONE_MAPPING = "" : this._toneMapping === cd ? this.material.defines.CINEON_TONE_MAPPING = "" : this._toneMapping === hd && (this.material.defines.ACES_FILMIC_TONE_MAPPING = ""), this.material.needsUpdate = !0), this.renderToScreen === !0 ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
const fL = {
  uniforms: {
    tDiffuse: { value: null },
    luminosityThreshold: { value: 1 },
    smoothWidth: { value: 1 },
    defaultColor: { value: new Q(0) },
    defaultOpacity: { value: 0 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
  )
};
class Qo extends js {
  constructor(e, t, n, s) {
    super(), this.strength = t !== void 0 ? t : 1, this.radius = n, this.threshold = s, this.resolution = e !== void 0 ? new k(e.x, e.y) : new k(256, 256), this.clearColor = new Q(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
    let r = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new xt(r, a, { type: zt }), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
    for (let u = 0; u < this.nMips; u++) {
      const d = new xt(r, a, { type: zt });
      d.texture.name = "UnrealBloomPass.h" + u, d.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(d);
      const f = new xt(r, a, { type: zt });
      f.texture.name = "UnrealBloomPass.v" + u, f.texture.generateMipmaps = !1, this.renderTargetsVertical.push(f), r = Math.round(r / 2), a = Math.round(a / 2);
    }
    const o = fL;
    this.highPassUniforms = cn.clone(o.uniforms), this.highPassUniforms.luminosityThreshold.value = s, this.highPassUniforms.smoothWidth.value = 0.01, this.materialHighPassFilter = new mt({
      uniforms: this.highPassUniforms,
      vertexShader: o.vertexShader,
      fragmentShader: o.fragmentShader
    }), this.separableBlurMaterials = [];
    const l = [3, 5, 7, 9, 11];
    r = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
    for (let u = 0; u < this.nMips; u++)
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[u])), this.separableBlurMaterials[u].uniforms.invSize.value = new k(1 / r, 1 / a), r = Math.round(r / 2), a = Math.round(a / 2);
    this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = 0.1;
    const c = [1, 0.8, 0.6, 0.4, 0.2];
    this.compositeMaterial.uniforms.bloomFactors.value = c, this.bloomTintColors = [new T(1, 1, 1), new T(1, 1, 1), new T(1, 1, 1), new T(1, 1, 1), new T(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
    const h = Hs;
    this.copyUniforms = cn.clone(h.uniforms), this.blendMaterial = new mt({
      uniforms: this.copyUniforms,
      vertexShader: h.vertexShader,
      fragmentShader: h.fragmentShader,
      blending: Ta,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new Q(), this.oldClearAlpha = 1, this.basic = new on(), this.fsQuad = new ll(null);
  }
  dispose() {
    for (let e = 0; e < this.renderTargetsHorizontal.length; e++)
      this.renderTargetsHorizontal[e].dispose();
    for (let e = 0; e < this.renderTargetsVertical.length; e++)
      this.renderTargetsVertical[e].dispose();
    this.renderTargetBright.dispose();
    for (let e = 0; e < this.separableBlurMaterials.length; e++)
      this.separableBlurMaterials[e].dispose();
    this.compositeMaterial.dispose(), this.blendMaterial.dispose(), this.basic.dispose(), this.fsQuad.dispose();
  }
  setSize(e, t) {
    let n = Math.round(e / 2), s = Math.round(t / 2);
    this.renderTargetBright.setSize(n, s);
    for (let r = 0; r < this.nMips; r++)
      this.renderTargetsHorizontal[r].setSize(n, s), this.renderTargetsVertical[r].setSize(n, s), this.separableBlurMaterials[r].uniforms.invSize.value = new k(1 / n, 1 / s), n = Math.round(n / 2), s = Math.round(s / 2);
  }
  render(e, t, n, s, r) {
    e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
    const a = e.autoClear;
    e.autoClear = !1, e.setClearColor(this.clearColor, 0), r && e.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = n.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e);
    let o = this.renderTargetBright;
    for (let l = 0; l < this.nMips; l++)
      this.fsQuad.material = this.separableBlurMaterials[l], this.separableBlurMaterials[l].uniforms.colorTexture.value = o.texture, this.separableBlurMaterials[l].uniforms.direction.value = Qo.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[l]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[l].uniforms.colorTexture.value = this.renderTargetsHorizontal[l].texture, this.separableBlurMaterials[l].uniforms.direction.value = Qo.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[l]), e.clear(), this.fsQuad.render(e), o = this.renderTargetsVertical[l];
    this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.blendMaterial, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, r && e.state.buffers.stencil.setTest(!0), this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.fsQuad.render(e)), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = a;
  }
  getSeperableBlurMaterial(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(0.39894 * Math.exp(-0.5 * n * n / (e * e)) / e);
    return new mt({
      defines: {
        KERNEL_RADIUS: e
      },
      uniforms: {
        colorTexture: { value: null },
        invSize: { value: new k(0.5, 0.5) },
        // inverse texture size
        direction: { value: new k(0.5, 0.5) },
        gaussianCoefficients: { value: t }
        // precomputed Gaussian coefficients
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
    });
  }
  getCompositeMaterial(e) {
    return new mt({
      defines: {
        NUM_MIPS: e
      },
      uniforms: {
        blurTexture1: { value: null },
        blurTexture2: { value: null },
        blurTexture3: { value: null },
        blurTexture4: { value: null },
        blurTexture5: { value: null },
        bloomStrength: { value: 1 },
        bloomFactors: { value: null },
        bloomTintColors: { value: null },
        bloomRadius: { value: 0 }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
    });
  }
}
Qo.BlurDirectionX = new k(1, 0);
Qo.BlurDirectionY = new k(0, 1);
const Qi = {
  defines: {
    MAX_STEP: 0,
    PERSPECTIVE_CAMERA: !0,
    DISTANCE_ATTENUATION: !0,
    FRESNEL: !0,
    INFINITE_THICK: !1,
    SELECTIVE: !1
  },
  uniforms: {
    tDiffuse: { value: null },
    tNormal: { value: null },
    tMetalness: { value: null },
    tDepth: { value: null },
    cameraNear: { value: null },
    cameraFar: { value: null },
    resolution: { value: new k() },
    cameraProjectionMatrix: { value: new _e() },
    cameraInverseProjectionMatrix: { value: new _e() },
    opacity: { value: 0.5 },
    maxDistance: { value: 180 },
    cameraRange: { value: 0 },
    thickness: { value: 0.018 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`
  ),
  fragmentShader: (
    /* glsl */
    `
		// precision highp float;
		precision highp sampler2D;
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
		uniform sampler2D tMetalness;
		uniform sampler2D tDiffuse;
		uniform float cameraRange;
		uniform vec2 resolution;
		uniform float opacity;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float maxDistance;
		uniform float thickness;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		#include <packing>
		float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
			//x0: point, x1: linePointA, x2: linePointB
			//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
			return length(cross(x0-x1,x0-x2))/length(x2-x1);
		}
		float pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){
			// https://mathworld.wolfram.com/Point-PlaneDistance.html
			//// https://en.wikipedia.org/wiki/Plane_(geometry)
			//// http://paulbourke.net/geometry/pointlineplane/
			float a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;
			float x0=point.x,y0=point.y,z0=point.z;
			float x=planePoint.x,y=planePoint.y,z=planePoint.z;
			float d=-(a*x+b*y+c*z);
			float distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);
			return distance;
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			#ifdef PERSPECTIVE_CAMERA
				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view
		}
		vec3 getViewNormal( const in vec2 uv ) {
			return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );
		}
		vec2 viewPositionToXY(vec3 viewPosition){
			vec2 xy;
			vec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);
			xy=clip.xy;//clip
			float clipW=clip.w;
			xy/=clipW;//NDC
			xy=(xy+1.)/2.;//uv
			xy*=resolution;//screen
			return xy;
		}
		void main(){
			#ifdef SELECTIVE
				float metalness=texture2D(tMetalness,vUv).r;
				if(metalness==0.) return;
			#endif

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );
			if(-viewZ>=cameraFar) return;

			float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];
			vec3 viewPosition=getViewPosition( vUv, depth, clipW );

			vec2 d0=gl_FragCoord.xy;
			vec2 d1;

			vec3 viewNormal=getViewNormal( vUv );

			#ifdef PERSPECTIVE_CAMERA
				vec3 viewIncidentDir=normalize(viewPosition);
				vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);
			#else
				vec3 viewIncidentDir=vec3(0,0,-1);
				vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);
			#endif

			float maxReflectRayLen=maxDistance/dot(-viewIncidentDir,viewNormal);
			// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
			// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
			// maxDistance/maxReflectRayLen=cos(theta)
			// maxDistance/maxReflectRayLen==dot(a,b)
			// maxReflectRayLen==maxDistance/dot(a,b)

			vec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;
			#ifdef PERSPECTIVE_CAMERA
				if(d1viewPosition.z>-cameraNear){
					//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
					float t=(-cameraNear-viewPosition.z)/viewReflectDir.z;
					d1viewPosition=viewPosition+viewReflectDir*t;
				}
			#endif
			d1=viewPositionToXY(d1viewPosition);

			float totalLen=length(d1-d0);
			float xLen=d1.x-d0.x;
			float yLen=d1.y-d0.y;
			float totalStep=max(abs(xLen),abs(yLen));
			float xSpan=xLen/totalStep;
			float ySpan=yLen/totalStep;
			for(float i=0.;i<float(MAX_STEP);i++){
				if(i>=totalStep) break;
				vec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);
				if(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;
				float s=length(xy-d0)/totalLen;
				vec2 uv=xy/resolution;

				float d = getDepth(uv);
				float vZ = getViewZ( d );
				if(-vZ>=cameraFar) continue;
				float cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];
				vec3 vP=getViewPosition( uv, d, cW );

				#ifdef PERSPECTIVE_CAMERA
					// https://comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
					float recipVPZ=1./viewPosition.z;
					float viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));
				#else
					float viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);
				#endif

				// if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.
				// https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164
				if(viewReflectRayZ<=vZ){

					bool hit;
					#ifdef INFINITE_THICK
						hit=true;
					#else
						float away=pointToLineDistance(vP,viewPosition,d1viewPosition);

						float minThickness;
						vec2 xyNeighbor=xy;
						xyNeighbor.x+=1.;
						vec2 uvNeighbor=xyNeighbor/resolution;
						vec3 vPNeighbor=getViewPosition(uvNeighbor,d,cW);
						minThickness=vPNeighbor.x-vP.x;
						minThickness*=3.;
						float tk=max(minThickness,thickness);

						hit=away<=tk;
					#endif

					if(hit){
						vec3 vN=getViewNormal( uv );
						if(dot(viewReflectDir,vN)>=0.) continue;
						float distance=pointPlaneDistance(vP,viewPosition,viewNormal);
						if(distance>maxDistance) break;
						float op=opacity;
						#ifdef DISTANCE_ATTENUATION
							float ratio=1.-(distance/maxDistance);
							float attenuation=ratio*ratio;
							op=opacity*attenuation;
						#endif
						#ifdef FRESNEL
							float fresnelCoe=(dot(viewIncidentDir,viewReflectDir)+1.)/2.;
							op*=fresnelCoe;
						#endif
						vec4 reflectColor=texture2D(tDiffuse,uv);
						gl_FragColor.xyz=reflectColor.xyz;
						gl_FragColor.a=op;
						break;
					}
				}
			}
		}
	`
  )
}, tu = {
  defines: {
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: { value: null },
    cameraNear: { value: null },
    cameraFar: { value: null }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 uv ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, uv ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, uv ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			float d = 1.0 - depth;
			// d=(d-.999)*1000.;
			gl_FragColor = vec4( vec3( d ), 1.0 );

		}

	`
  )
}, ar = {
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new k() },
    opacity: { value: 0.5 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform vec2 resolution;
		varying vec2 vUv;
		void main() {
			//reverse engineering from PhotoShop blur filter, then change coefficient

			vec2 texelSize = ( 1.0 / resolution );

			vec4 c=texture2D(tDiffuse,vUv);

			vec2 offset;

			offset=(vec2(-1,0))*texelSize;
			vec4 cl=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(1,0))*texelSize;
			vec4 cr=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,-1))*texelSize;
			vec4 cb=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,1))*texelSize;
			vec4 ct=texture2D(tDiffuse,vUv+offset);

			// float coeCenter=.5;
			// float coeSide=.125;
			float coeCenter=.2;
			float coeSide=.2;
			float a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;
			vec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;
			gl_FragColor=vec4(rgb,a);

		}
	`
  )
};
class Ns extends js {
  constructor({ renderer: e, scene: t, camera: n, width: s, height: r, selects: a, bouncing: o = !1, groundReflector: l }) {
    super(), this.width = s !== void 0 ? s : 512, this.height = r !== void 0 ? r : 512, this.clear = !0, this.renderer = e, this.scene = t, this.camera = n, this.groundReflector = l, this.opacity = Qi.uniforms.opacity.value, this.output = 0, this.maxDistance = Qi.uniforms.maxDistance.value, this.thickness = Qi.uniforms.thickness.value, this.tempColor = new Q(), this._selects = a, this.selective = Array.isArray(this._selects), Object.defineProperty(this, "selects", {
      get() {
        return this._selects;
      },
      set(h) {
        this._selects !== h && (this._selects = h, Array.isArray(h) ? (this.selective = !0, this.ssrMaterial.defines.SELECTIVE = !0, this.ssrMaterial.needsUpdate = !0) : (this.selective = !1, this.ssrMaterial.defines.SELECTIVE = !1, this.ssrMaterial.needsUpdate = !0));
      }
    }), this._bouncing = o, Object.defineProperty(this, "bouncing", {
      get() {
        return this._bouncing;
      },
      set(h) {
        this._bouncing !== h && (this._bouncing = h, h ? this.ssrMaterial.uniforms.tDiffuse.value = this.prevRenderTarget.texture : this.ssrMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture);
      }
    }), this.blur = !0, this._distanceAttenuation = Qi.defines.DISTANCE_ATTENUATION, Object.defineProperty(this, "distanceAttenuation", {
      get() {
        return this._distanceAttenuation;
      },
      set(h) {
        this._distanceAttenuation !== h && (this._distanceAttenuation = h, this.ssrMaterial.defines.DISTANCE_ATTENUATION = h, this.ssrMaterial.needsUpdate = !0);
      }
    }), this._fresnel = Qi.defines.FRESNEL, Object.defineProperty(this, "fresnel", {
      get() {
        return this._fresnel;
      },
      set(h) {
        this._fresnel !== h && (this._fresnel = h, this.ssrMaterial.defines.FRESNEL = h, this.ssrMaterial.needsUpdate = !0);
      }
    }), this._infiniteThick = Qi.defines.INFINITE_THICK, Object.defineProperty(this, "infiniteThick", {
      get() {
        return this._infiniteThick;
      },
      set(h) {
        this._infiniteThick !== h && (this._infiniteThick = h, this.ssrMaterial.defines.INFINITE_THICK = h, this.ssrMaterial.needsUpdate = !0);
      }
    });
    const c = new bd();
    c.type = Nc, c.minFilter = lt, c.magFilter = lt, this.beautyRenderTarget = new xt(this.width, this.height, {
      minFilter: lt,
      magFilter: lt,
      type: zt,
      depthTexture: c,
      depthBuffer: !0
    }), this.prevRenderTarget = new xt(this.width, this.height, {
      minFilter: lt,
      magFilter: lt
    }), this.normalRenderTarget = new xt(this.width, this.height, {
      minFilter: lt,
      magFilter: lt,
      type: zt
    }), this.metalnessRenderTarget = new xt(this.width, this.height, {
      minFilter: lt,
      magFilter: lt,
      type: zt
    }), this.ssrRenderTarget = new xt(this.width, this.height, {
      minFilter: lt,
      magFilter: lt
    }), this.blurRenderTarget = this.ssrRenderTarget.clone(), this.blurRenderTarget2 = this.ssrRenderTarget.clone(), this.ssrMaterial = new mt({
      defines: Object.assign({}, Qi.defines, {
        MAX_STEP: Math.sqrt(this.width * this.width + this.height * this.height)
      }),
      uniforms: cn.clone(Qi.uniforms),
      vertexShader: Qi.vertexShader,
      fragmentShader: Qi.fragmentShader,
      blending: vt
    }), this.ssrMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.ssrMaterial.uniforms.tNormal.value = this.normalRenderTarget.texture, this.ssrMaterial.defines.SELECTIVE = this.selective, this.ssrMaterial.needsUpdate = !0, this.ssrMaterial.uniforms.tMetalness.value = this.metalnessRenderTarget.texture, this.ssrMaterial.uniforms.tDepth.value = this.beautyRenderTarget.depthTexture, this.ssrMaterial.uniforms.cameraNear.value = this.camera.near, this.ssrMaterial.uniforms.cameraFar.value = this.camera.far, this.ssrMaterial.uniforms.thickness.value = this.thickness, this.ssrMaterial.uniforms.resolution.value.set(this.width, this.height), this.ssrMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssrMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.normalMaterial = new Dd(), this.normalMaterial.blending = vt, this.metalnessOnMaterial = new on({
      color: "white"
    }), this.metalnessOffMaterial = new on({
      color: "black"
    }), this.blurMaterial = new mt({
      defines: Object.assign({}, ar.defines),
      uniforms: cn.clone(ar.uniforms),
      vertexShader: ar.vertexShader,
      fragmentShader: ar.fragmentShader
    }), this.blurMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.blurMaterial.uniforms.resolution.value.set(this.width, this.height), this.blurMaterial2 = new mt({
      defines: Object.assign({}, ar.defines),
      uniforms: cn.clone(ar.uniforms),
      vertexShader: ar.vertexShader,
      fragmentShader: ar.fragmentShader
    }), this.blurMaterial2.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.blurMaterial2.uniforms.resolution.value.set(this.width, this.height), this.depthRenderMaterial = new mt({
      defines: Object.assign({}, tu.defines),
      uniforms: cn.clone(tu.uniforms),
      vertexShader: tu.vertexShader,
      fragmentShader: tu.fragmentShader,
      blending: vt
    }), this.depthRenderMaterial.uniforms.tDepth.value = this.beautyRenderTarget.depthTexture, this.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near, this.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far, this.copyMaterial = new mt({
      uniforms: cn.clone(Hs.uniforms),
      vertexShader: Hs.vertexShader,
      fragmentShader: Hs.fragmentShader,
      transparent: !0,
      depthTest: !1,
      depthWrite: !1,
      blendSrc: Sr,
      blendDst: wr,
      blendEquation: mi,
      blendSrcAlpha: Sr,
      blendDstAlpha: wr,
      blendEquationAlpha: mi
      // premultipliedAlpha:true,
    }), this.fsQuad = new ll(null), this.originalClearColor = new Q();
  }
  dispose() {
    this.beautyRenderTarget.dispose(), this.prevRenderTarget.dispose(), this.normalRenderTarget.dispose(), this.metalnessRenderTarget.dispose(), this.ssrRenderTarget.dispose(), this.blurRenderTarget.dispose(), this.blurRenderTarget2.dispose(), this.normalMaterial.dispose(), this.metalnessOnMaterial.dispose(), this.metalnessOffMaterial.dispose(), this.blurMaterial.dispose(), this.blurMaterial2.dispose(), this.copyMaterial.dispose(), this.depthRenderMaterial.dispose(), this.fsQuad.dispose();
  }
  render(e, t) {
    switch (e.setRenderTarget(this.beautyRenderTarget), e.clear(), this.groundReflector && (this.groundReflector.visible = !1, this.groundReflector.doRender(this.renderer, this.scene, this.camera), this.groundReflector.visible = !0), e.render(this.scene, this.camera), this.groundReflector && (this.groundReflector.visible = !1), this.renderOverride(e, this.normalMaterial, this.normalRenderTarget, 0, 0), this.selective && this.renderMetalness(e, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0), this.ssrMaterial.uniforms.opacity.value = this.opacity, this.ssrMaterial.uniforms.maxDistance.value = this.maxDistance, this.ssrMaterial.uniforms.thickness.value = this.thickness, this.renderPass(e, this.ssrMaterial, this.ssrRenderTarget), this.blur && (this.renderPass(e, this.blurMaterial, this.blurRenderTarget), this.renderPass(e, this.blurMaterial2, this.blurRenderTarget2)), this.output) {
      case Ns.OUTPUT.Default:
        this.bouncing ? (this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = vt, this.renderPass(e, this.copyMaterial, this.prevRenderTarget), this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = Gi, this.renderPass(e, this.copyMaterial, this.prevRenderTarget), this.copyMaterial.uniforms.tDiffuse.value = this.prevRenderTarget.texture, this.copyMaterial.blending = vt, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t)) : (this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = vt, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t), this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = Gi, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t));
        break;
      case Ns.OUTPUT.SSR:
        this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = vt, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t), this.bouncing && (this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = vt, this.renderPass(e, this.copyMaterial, this.prevRenderTarget), this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = Gi, this.renderPass(e, this.copyMaterial, this.prevRenderTarget));
        break;
      case Ns.OUTPUT.Beauty:
        this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = vt, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
        break;
      case Ns.OUTPUT.Depth:
        this.renderPass(e, this.depthRenderMaterial, this.renderToScreen ? null : t);
        break;
      case Ns.OUTPUT.Normal:
        this.copyMaterial.uniforms.tDiffuse.value = this.normalRenderTarget.texture, this.copyMaterial.blending = vt, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
        break;
      case Ns.OUTPUT.Metalness:
        this.copyMaterial.uniforms.tDiffuse.value = this.metalnessRenderTarget.texture, this.copyMaterial.blending = vt, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
        break;
      default:
        console.warn("THREE.SSRPass: Unknown output type.");
    }
  }
  renderPass(e, t, n, s, r) {
    this.originalClearColor.copy(e.getClearColor(this.tempColor));
    const a = e.getClearAlpha(this.tempColor), o = e.autoClear;
    e.setRenderTarget(n), e.autoClear = !1, s != null && (e.setClearColor(s), e.setClearAlpha(r || 0), e.clear()), this.fsQuad.material = t, this.fsQuad.render(e), e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  renderOverride(e, t, n, s, r) {
    this.originalClearColor.copy(e.getClearColor(this.tempColor));
    const a = e.getClearAlpha(this.tempColor), o = e.autoClear;
    e.setRenderTarget(n), e.autoClear = !1, s = t.clearColor || s, r = t.clearAlpha || r, s != null && (e.setClearColor(s), e.setClearAlpha(r || 0), e.clear()), this.scene.overrideMaterial = t, e.render(this.scene, this.camera), this.scene.overrideMaterial = null, e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  renderMetalness(e, t, n, s, r) {
    this.originalClearColor.copy(e.getClearColor(this.tempColor));
    const a = e.getClearAlpha(this.tempColor), o = e.autoClear;
    e.setRenderTarget(n), e.autoClear = !1, s = t.clearColor || s, r = t.clearAlpha || r, s != null && (e.setClearColor(s), e.setClearAlpha(r || 0), e.clear()), this.scene.traverseVisible((l) => {
      l._SSRPassBackupMaterial = l.material, this._selects.includes(l) ? l.material = this.metalnessOnMaterial : l.material = this.metalnessOffMaterial;
    }), e.render(this.scene, this.camera), this.scene.traverseVisible((l) => {
      l.material = l._SSRPassBackupMaterial;
    }), e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  setSize(e, t) {
    this.width = e, this.height = t, this.ssrMaterial.defines.MAX_STEP = Math.sqrt(e * e + t * t), this.ssrMaterial.needsUpdate = !0, this.beautyRenderTarget.setSize(e, t), this.prevRenderTarget.setSize(e, t), this.ssrRenderTarget.setSize(e, t), this.normalRenderTarget.setSize(e, t), this.metalnessRenderTarget.setSize(e, t), this.blurRenderTarget.setSize(e, t), this.blurRenderTarget2.setSize(e, t), this.ssrMaterial.uniforms.resolution.value.set(e, t), this.ssrMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssrMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.blurMaterial.uniforms.resolution.value.set(e, t), this.blurMaterial2.uniforms.resolution.value.set(e, t);
  }
}
Ns.OUTPUT = {
  Default: 0,
  SSR: 1,
  Beauty: 3,
  Depth: 4,
  Normal: 5,
  Metalness: 7
};
const nu = {
  defines: {
    NUM_SAMPLES: 7,
    NUM_RINGS: 4,
    DIFFUSE_TEXTURE: 0,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: { value: null },
    tDiffuse: { value: null },
    tNormal: { value: null },
    size: { value: new k(512, 512) },
    cameraNear: { value: 1 },
    cameraFar: { value: 100 },
    cameraProjectionMatrix: { value: new _e() },
    cameraInverseProjectionMatrix: { value: new _e() },
    scale: { value: 1 },
    intensity: { value: 0.1 },
    bias: { value: 0.5 },
    minResolution: { value: 0 },
    kernelRadius: { value: 100 },
    randomSeed: { value: 0 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		#include <common>

		varying vec2 vUv;

		#if DIFFUSE_TEXTURE == 1
		uniform sampler2D tDiffuse;
		#endif

		uniform sampler2D tDepth;
		uniform sampler2D tNormal;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float scale;
		uniform float intensity;
		uniform float bias;
		uniform float kernelRadius;
		uniform float minResolution;
		uniform vec2 size;
		uniform float randomSeed;

		// RGBA depth

		#include <packing>

		vec4 getDefaultColor( const in vec2 screenPosition ) {
			#if DIFFUSE_TEXTURE == 1
			return texture2D( tDiffuse, vUv );
			#else
			return vec4( 1.0 );
			#endif
		}

		float getDepth( const in vec2 screenPosition ) {
			return texture2D( tDepth, screenPosition ).x;
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
		}

		vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {
			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
		}

		float scaleDividedByCameraFar;
		float minResolutionMultipliedByCameraFar;

		float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {
			vec3 viewDelta = sampleViewPosition - centerViewPosition;
			float viewDistance = length( viewDelta );
			float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;

			return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );
		}

		// moving costly divides into consts
		const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );
		const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );

		float getAmbientOcclusion( const in vec3 centerViewPosition ) {
			// precompute some variables require in getOcclusion.
			scaleDividedByCameraFar = scale / cameraFar;
			minResolutionMultipliedByCameraFar = minResolution * cameraFar;
			vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );

			// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
			float angle = rand( vUv + randomSeed ) * PI2;
			vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;
			vec2 radiusStep = radius;

			float occlusionSum = 0.0;
			float weightSum = 0.0;

			for( int i = 0; i < NUM_SAMPLES; i ++ ) {
				vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;
				radius += radiusStep;
				angle += ANGLE_STEP;

				float sampleDepth = getDepth( sampleUv );
				if( sampleDepth >= ( 1.0 - EPSILON ) ) {
					continue;
				}

				float sampleViewZ = getViewZ( sampleDepth );
				vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );
				occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );
				weightSum += 1.0;
			}

			if( weightSum == 0.0 ) discard;

			return occlusionSum * ( intensity / weightSum );
		}

		void main() {
			float centerDepth = getDepth( vUv );
			if( centerDepth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = getViewZ( centerDepth );
			vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );

			float ambientOcclusion = getAmbientOcclusion( viewPosition );

			gl_FragColor = getDefaultColor( vUv );
			gl_FragColor.xyz *=  1.0 - ambientOcclusion;
		}`
  )
}, or = {
  defines: {
    KERNEL_RADIUS: 4,
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDiffuse: { value: null },
    size: { value: new k(512, 512) },
    sampleUvOffsets: { value: [new k(0, 0)] },
    sampleWeights: { value: [1] },
    tDepth: { value: null },
    cameraNear: { value: 10 },
    cameraFar: { value: 1e3 },
    depthCutoff: { value: 10 }
  },
  vertexShader: (
    /* glsl */
    `

		#include <common>

		uniform vec2 size;

		varying vec2 vUv;
		varying vec2 vInvSize;

		void main() {
			vUv = uv;
			vInvSize = 1.0 / size;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		#include <common>
		#include <packing>

		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform float depthCutoff;

		uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];
		uniform float sampleWeights[ KERNEL_RADIUS + 1 ];

		varying vec2 vUv;
		varying vec2 vInvSize;

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		void main() {
			float depth = getDepth( vUv );
			if( depth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = -getViewZ( depth );
			bool rBreak = false, lBreak = false;

			float weightSum = sampleWeights[0];
			vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;

			for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {

				float sampleWeight = sampleWeights[i];
				vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;

				vec2 sampleUv = vUv + sampleUvOffset;
				float viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;

				if( ! rBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

				sampleUv = vUv - sampleUvOffset;
				viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;

				if( ! lBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

			}

			gl_FragColor = diffuseSum / weightSum;
		}`
  )
}, Hu = {
  createSampleWeights: function(i, e) {
    const t = [];
    for (let n = 0; n <= i; n++)
      t.push(pL(n, e));
    return t;
  },
  createSampleOffsets: function(i, e) {
    const t = [];
    for (let n = 0; n <= i; n++)
      t.push(e.clone().multiplyScalar(n));
    return t;
  },
  configure: function(i, e, t, n) {
    i.defines.KERNEL_RADIUS = e, i.uniforms.sampleUvOffsets.value = Hu.createSampleOffsets(e, n), i.uniforms.sampleWeights.value = Hu.createSampleWeights(e, t), i.needsUpdate = !0;
  }
};
function pL(i, e) {
  return Math.exp(-(i * i) / (2 * (e * e))) / (Math.sqrt(2 * Math.PI) * e);
}
class Sc extends js {
  constructor(e, t, n = new k(256, 256)) {
    super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.originalClearColor = new Q(), this._oldClearColor = new Q(), this.oldClearAlpha = 1, this.params = {
      output: 0,
      saoBias: 0.5,
      saoIntensity: 0.18,
      saoScale: 1,
      saoKernelRadius: 100,
      saoMinResolution: 0,
      saoBlur: !0,
      saoBlurRadius: 8,
      saoBlurStdDev: 4,
      saoBlurDepthCutoff: 0.01
    }, this.resolution = new k(n.x, n.y), this.saoRenderTarget = new xt(this.resolution.x, this.resolution.y, { type: zt }), this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();
    const s = new bd();
    s.format = Ar, s.type = zs, this.normalRenderTarget = new xt(this.resolution.x, this.resolution.y, {
      minFilter: lt,
      magFilter: lt,
      type: zt,
      depthTexture: s
    }), this.normalMaterial = new Dd(), this.normalMaterial.blending = vt, this.saoMaterial = new mt({
      defines: Object.assign({}, nu.defines),
      fragmentShader: nu.fragmentShader,
      vertexShader: nu.vertexShader,
      uniforms: cn.clone(nu.uniforms)
    }), this.saoMaterial.extensions.derivatives = !0, this.saoMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0, this.saoMaterial.uniforms.tDepth.value = s, this.saoMaterial.uniforms.tNormal.value = this.normalRenderTarget.texture, this.saoMaterial.uniforms.size.value.set(this.resolution.x, this.resolution.y), this.saoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.saoMaterial.uniforms.cameraProjectionMatrix.value = this.camera.projectionMatrix, this.saoMaterial.blending = vt, this.vBlurMaterial = new mt({
      uniforms: cn.clone(or.uniforms),
      defines: Object.assign({}, or.defines),
      vertexShader: or.vertexShader,
      fragmentShader: or.fragmentShader
    }), this.vBlurMaterial.defines.DEPTH_PACKING = 0, this.vBlurMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0, this.vBlurMaterial.uniforms.tDiffuse.value = this.saoRenderTarget.texture, this.vBlurMaterial.uniforms.tDepth.value = s, this.vBlurMaterial.uniforms.size.value.set(this.resolution.x, this.resolution.y), this.vBlurMaterial.blending = vt, this.hBlurMaterial = new mt({
      uniforms: cn.clone(or.uniforms),
      defines: Object.assign({}, or.defines),
      vertexShader: or.vertexShader,
      fragmentShader: or.fragmentShader
    }), this.hBlurMaterial.defines.DEPTH_PACKING = 0, this.hBlurMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0, this.hBlurMaterial.uniforms.tDiffuse.value = this.blurIntermediateRenderTarget.texture, this.hBlurMaterial.uniforms.tDepth.value = s, this.hBlurMaterial.uniforms.size.value.set(this.resolution.x, this.resolution.y), this.hBlurMaterial.blending = vt, this.materialCopy = new mt({
      uniforms: cn.clone(Hs.uniforms),
      vertexShader: Hs.vertexShader,
      fragmentShader: Hs.fragmentShader,
      blending: vt
    }), this.materialCopy.transparent = !0, this.materialCopy.depthTest = !1, this.materialCopy.depthWrite = !1, this.materialCopy.blending = Fo, this.materialCopy.blendSrc = Dc, this.materialCopy.blendDst = Bo, this.materialCopy.blendEquation = mi, this.materialCopy.blendSrcAlpha = Ic, this.materialCopy.blendDstAlpha = Bo, this.materialCopy.blendEquationAlpha = mi, this.fsQuad = new ll(null);
  }
  render(e, t, n) {
    this.renderToScreen && (this.materialCopy.blending = vt, this.materialCopy.uniforms.tDiffuse.value = n.texture, this.materialCopy.needsUpdate = !0, this.renderPass(e, this.materialCopy, null)), e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
    const s = e.autoClear;
    e.autoClear = !1, this.saoMaterial.uniforms.bias.value = this.params.saoBias, this.saoMaterial.uniforms.intensity.value = this.params.saoIntensity, this.saoMaterial.uniforms.scale.value = this.params.saoScale, this.saoMaterial.uniforms.kernelRadius.value = this.params.saoKernelRadius, this.saoMaterial.uniforms.minResolution.value = this.params.saoMinResolution, this.saoMaterial.uniforms.cameraNear.value = this.camera.near, this.saoMaterial.uniforms.cameraFar.value = this.camera.far;
    const r = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);
    this.vBlurMaterial.uniforms.depthCutoff.value = r, this.hBlurMaterial.uniforms.depthCutoff.value = r, this.vBlurMaterial.uniforms.cameraNear.value = this.camera.near, this.vBlurMaterial.uniforms.cameraFar.value = this.camera.far, this.hBlurMaterial.uniforms.cameraNear.value = this.camera.near, this.hBlurMaterial.uniforms.cameraFar.value = this.camera.far, this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius), (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) && (Hu.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new k(0, 1)), Hu.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new k(1, 0)), this.prevStdDev = this.params.saoBlurStdDev, this.prevNumSamples = this.params.saoBlurRadius), this.renderOverride(e, this.normalMaterial, this.normalRenderTarget, 7829503, 1), this.renderPass(e, this.saoMaterial, this.saoRenderTarget, 16777215, 1), this.params.saoBlur && (this.renderPass(e, this.vBlurMaterial, this.blurIntermediateRenderTarget, 16777215, 1), this.renderPass(e, this.hBlurMaterial, this.saoRenderTarget, 16777215, 1));
    const a = this.materialCopy;
    this.params.output === Sc.OUTPUT.Normal ? (this.materialCopy.uniforms.tDiffuse.value = this.normalRenderTarget.texture, this.materialCopy.needsUpdate = !0) : (this.materialCopy.uniforms.tDiffuse.value = this.saoRenderTarget.texture, this.materialCopy.needsUpdate = !0), this.params.output === Sc.OUTPUT.Default ? a.blending = Fo : a.blending = vt, this.renderPass(e, a, this.renderToScreen ? null : n), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = s;
  }
  renderPass(e, t, n, s, r) {
    e.getClearColor(this.originalClearColor);
    const a = e.getClearAlpha(), o = e.autoClear;
    e.setRenderTarget(n), e.autoClear = !1, s != null && (e.setClearColor(s), e.setClearAlpha(r || 0), e.clear()), this.fsQuad.material = t, this.fsQuad.render(e), e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  renderOverride(e, t, n, s, r) {
    e.getClearColor(this.originalClearColor);
    const a = e.getClearAlpha(), o = e.autoClear;
    e.setRenderTarget(n), e.autoClear = !1, s = t.clearColor || s, r = t.clearAlpha || r, s != null && (e.setClearColor(s), e.setClearAlpha(r || 0), e.clear()), this.scene.overrideMaterial = t, e.render(this.scene, this.camera), this.scene.overrideMaterial = null, e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  setSize(e, t) {
    this.saoRenderTarget.setSize(e, t), this.blurIntermediateRenderTarget.setSize(e, t), this.normalRenderTarget.setSize(e, t), this.saoMaterial.uniforms.size.value.set(e, t), this.saoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.saoMaterial.uniforms.cameraProjectionMatrix.value = this.camera.projectionMatrix, this.saoMaterial.needsUpdate = !0, this.vBlurMaterial.uniforms.size.value.set(e, t), this.vBlurMaterial.needsUpdate = !0, this.hBlurMaterial.uniforms.size.value.set(e, t), this.hBlurMaterial.needsUpdate = !0;
  }
  dispose() {
    this.saoRenderTarget.dispose(), this.blurIntermediateRenderTarget.dispose(), this.normalRenderTarget.dispose(), this.normalMaterial.dispose(), this.saoMaterial.dispose(), this.vBlurMaterial.dispose(), this.hBlurMaterial.dispose(), this.materialCopy.dispose(), this.fsQuad.dispose();
  }
}
Sc.OUTPUT = {
  Default: 0,
  SAO: 1,
  Normal: 2
};
const mL = {
  name: "FXAAShader",
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new k(1 / 1024, 1 / 512) }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: `
	precision highp float;

	uniform sampler2D tDiffuse;

	uniform vec2 resolution;

	varying vec2 vUv;

	// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)

	//----------------------------------------------------------------------------------
	// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag
	// SDK Version: v3.00
	// Email:       gameworks@nvidia.com
	// Site:        http://developer.nvidia.com/
	//
	// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
	//
	// Redistribution and use in source and binary forms, with or without
	// modification, are permitted provided that the following conditions
	// are met:
	//  * Redistributions of source code must retain the above copyright
	//    notice, this list of conditions and the following disclaimer.
	//  * Redistributions in binary form must reproduce the above copyright
	//    notice, this list of conditions and the following disclaimer in the
	//    documentation and/or other materials provided with the distribution.
	//  * Neither the name of NVIDIA CORPORATION nor the names of its
	//    contributors may be used to endorse or promote products derived
	//    from this software without specific prior written permission.
	//
	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
	// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
	// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	//
	//----------------------------------------------------------------------------------

	#ifndef FXAA_DISCARD
			//
			// Only valid for PC OpenGL currently.
			// Probably will not work when FXAA_GREEN_AS_LUMA = 1.
			//
			// 1 = Use discard on pixels which don't need AA.
			//     For APIs which enable concurrent TEX+ROP from same surface.
			// 0 = Return unchanged color on pixels which don't need AA.
			//
			#define FXAA_DISCARD 0
	#endif

	/*--------------------------------------------------------------------------*/
	#define FxaaTexTop(t, p) texture2D(t, p, -100.0)
	#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)
	/*--------------------------------------------------------------------------*/

	#define NUM_SAMPLES 5

	// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha
	float contrast( vec4 a, vec4 b ) {
			vec4 diff = abs( a - b );
			return max( max( max( diff.r, diff.g ), diff.b ), diff.a );
	}

	/*============================================================================

									FXAA3 QUALITY - PC

	============================================================================*/

	/*--------------------------------------------------------------------------*/
	vec4 FxaaPixelShader(
			vec2 posM,
			sampler2D tex,
			vec2 fxaaQualityRcpFrame,
			float fxaaQualityEdgeThreshold,
			float fxaaQualityinvEdgeThreshold
	) {
			vec4 rgbaM = FxaaTexTop(tex, posM);
			vec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);
			// . S .
			// W M E
			// . N .

			bool earlyExit = max( max( max(
					contrast( rgbaM, rgbaN ),
					contrast( rgbaM, rgbaS ) ),
					contrast( rgbaM, rgbaE ) ),
					contrast( rgbaM, rgbaW ) )
					< fxaaQualityEdgeThreshold;
			// . 0 .
			// 0 0 0
			// . 0 .

			#if (FXAA_DISCARD == 1)
					if(earlyExit) FxaaDiscard;
			#else
					if(earlyExit) return rgbaM;
			#endif

			float contrastN = contrast( rgbaM, rgbaN );
			float contrastS = contrast( rgbaM, rgbaS );
			float contrastE = contrast( rgbaM, rgbaE );
			float contrastW = contrast( rgbaM, rgbaW );

			float relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );
			relativeVContrast *= fxaaQualityinvEdgeThreshold;

			bool horzSpan = relativeVContrast > 0.;
			// . 1 .
			// 0 0 0
			// . 1 .

			// 45 deg edge detection and corners of objects, aka V/H contrast is too similar
			if( abs( relativeVContrast ) < .3 ) {
					// locate the edge
					vec2 dirToEdge;
					dirToEdge.x = contrastE > contrastW ? 1. : -1.;
					dirToEdge.y = contrastS > contrastN ? 1. : -1.;
					// . 2 .      . 1 .
					// 1 0 2  ~=  0 0 1
					// . 1 .      . 0 .

					// tap 2 pixels and see which ones are "outside" the edge, to
					// determine if the edge is vertical or horizontal

					vec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);
					float matchAlongH = contrast( rgbaM, rgbaAlongH );
					// . 1 .
					// 0 0 1
					// . 0 H

					vec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);
					float matchAlongV = contrast( rgbaM, rgbaAlongV );
					// V 1 .
					// 0 0 1
					// . 0 .

					relativeVContrast = matchAlongV - matchAlongH;
					relativeVContrast *= fxaaQualityinvEdgeThreshold;

					if( abs( relativeVContrast ) < .3 ) { // 45 deg edge
							// 1 1 .
							// 0 0 1
							// . 0 1

							// do a simple blur
							return mix(
									rgbaM,
									(rgbaN + rgbaS + rgbaE + rgbaW) * .25,
									.4
							);
					}

					horzSpan = relativeVContrast > 0.;
			}

			if(!horzSpan) rgbaN = rgbaW;
			if(!horzSpan) rgbaS = rgbaE;
			// . 0 .      1
			// 1 0 1  ->  0
			// . 0 .      1

			bool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );
			if(!pairN) rgbaN = rgbaS;

			vec2 offNP;
			offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
			offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;

			bool doneN = false;
			bool doneP = false;

			float nDist = 0.;
			float pDist = 0.;

			vec2 posN = posM;
			vec2 posP = posM;

			int iterationsUsed = 0;
			int iterationsUsedN = 0;
			int iterationsUsedP = 0;
			for( int i = 0; i < NUM_SAMPLES; i++ ) {
					iterationsUsed = i;

					float increment = float(i + 1);

					if(!doneN) {
							nDist += increment;
							posN = posM + offNP * nDist;
							vec4 rgbaEndN = FxaaTexTop(tex, posN.xy);
							doneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );
							iterationsUsedN = i;
					}

					if(!doneP) {
							pDist += increment;
							posP = posM - offNP * pDist;
							vec4 rgbaEndP = FxaaTexTop(tex, posP.xy);
							doneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );
							iterationsUsedP = i;
					}

					if(doneN || doneP) break;
			}


			if ( !doneP && !doneN ) return rgbaM; // failed to find end of edge

			float dist = min(
					doneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,
					doneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.
			);

			// hacky way of reduces blurriness of mostly diagonal edges
			// but reduces AA quality
			dist = pow(dist, .5);

			dist = 1. - dist;

			return mix(
					rgbaM,
					rgbaN,
					dist * .5
			);
	}

	void main() {
			const float edgeDetectionQuality = .2;
			const float invEdgeDetectionQuality = 1. / edgeDetectionQuality;

			gl_FragColor = FxaaPixelShader(
					vUv,
					tDiffuse,
					resolution,
					edgeDetectionQuality, // [0,1] contrast needed, otherwise early discard
					invEdgeDetectionQuality
			);

	}
	`
};
class gL extends Gg {
  constructor() {
    super({
      name: "ScreenMaskShader",
      uniforms: {
        tDiffuse: { value: null },
        opacity: { value: 1 },
        intensity: { value: 1 },
        maskColor: { value: new Q(1, 1, 1) },
        R: { value: 0.2 },
        sr: { value: 1.2 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
      `,
      fragmentShader: `
        uniform float opacity;
        uniform float intensity;
        uniform sampler2D tDiffuse;
        uniform vec3 maskColor;
        uniform float R;
        uniform float sr;
        varying vec2 vUv;
        void main() {
          // 
          vec4 texel = texture2D( tDiffuse, vUv );
          // 
          float dist = sqrt((vUv.x-0.5)*(vUv.x-0.5)+(vUv.y-0.5)*(vUv.y-0.5));
          // , sr 
          float rr = (sr - smoothstep(R, R + 0.5, dist));
          // 
          texel *= vec4(maskColor * rr * vec3(intensity,intensity,intensity), 1.0);
          gl_FragColor = opacity * texel;
        }
      `
    });
  }
}
class Rb extends Ze {
  constructor(e = document.createElement("div")) {
    super(), this.isCSS2DObject = !0, this.element = e, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.center = new k(0.5, 0.5), this.addEventListener("removed", function() {
      this.traverse(function(t) {
        t.element instanceof Element && t.element.parentNode !== null && t.element.parentNode.removeChild(t.element);
      });
    });
  }
  copy(e, t) {
    return super.copy(e, t), this.element = e.element.cloneNode(!0), this.center = e.center, this;
  }
}
const ho = new T(), I_ = new _e(), D_ = new _e(), O_ = new T(), N_ = new T();
class vL {
  constructor(e = {}) {
    const t = this;
    let n, s, r, a;
    const o = {
      objects: /* @__PURE__ */ new WeakMap()
    }, l = e.element !== void 0 ? e.element : document.createElement("div");
    l.style.overflow = "hidden", this.domElement = l, this.getSize = function() {
      return {
        width: n,
        height: s
      };
    }, this.render = function(f, m) {
      f.matrixWorldAutoUpdate === !0 && f.updateMatrixWorld(), m.parent === null && m.matrixWorldAutoUpdate === !0 && m.updateMatrixWorld(), I_.copy(m.matrixWorldInverse), D_.multiplyMatrices(m.projectionMatrix, I_), c(f, f, m), d(f);
    }, this.setSize = function(f, m) {
      n = f, s = m, r = n / 2, a = s / 2, l.style.width = f + "px", l.style.height = m + "px";
    };
    function c(f, m, g) {
      if (f.isCSS2DObject) {
        ho.setFromMatrixPosition(f.matrixWorld), ho.applyMatrix4(D_);
        const p = f.visible === !0 && ho.z >= -1 && ho.z <= 1 && f.layers.test(g.layers) === !0;
        if (f.element.style.display = p === !0 ? "" : "none", p === !0) {
          f.onBeforeRender(t, m, g);
          const y = f.element;
          y.style.transform = "translate(" + -100 * f.center.x + "%," + -100 * f.center.y + "%)translate(" + (ho.x * r + r) + "px," + (-ho.y * a + a) + "px)", y.parentNode !== l && l.appendChild(y), f.onAfterRender(t, m, g);
        }
        const v = {
          distanceToCameraSquared: h(g, f)
        };
        o.objects.set(f, v);
      }
      for (let p = 0, v = f.children.length; p < v; p++)
        c(f.children[p], m, g);
    }
    function h(f, m) {
      return O_.setFromMatrixPosition(f.matrixWorld), N_.setFromMatrixPosition(m.matrixWorld), O_.distanceToSquared(N_);
    }
    function u(f) {
      const m = [];
      return f.traverse(function(g) {
        g.isCSS2DObject && m.push(g);
      }), m;
    }
    function d(f) {
      const m = u(f).sort(function(p, v) {
        if (p.renderOrder !== v.renderOrder)
          return v.renderOrder - p.renderOrder;
        const y = o.objects.get(p).distanceToCameraSquared, _ = o.objects.get(v).distanceToCameraSquared;
        return y - _;
      }), g = m.length;
      for (let p = 0, v = m.length; p < v; p++)
        m[p].element.style.zIndex = g - p;
    }
  }
}
const U_ = new T(), _L = new pt(), F_ = new T();
class Pb extends Ze {
  constructor(e = document.createElement("div")) {
    super(), this.isCSS3DObject = !0, this.element = e, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.addEventListener("removed", function() {
      this.traverse(function(t) {
        t.element instanceof Element && t.element.parentNode !== null && t.element.parentNode.removeChild(t.element);
      });
    });
  }
  copy(e, t) {
    return super.copy(e, t), this.element = e.element.cloneNode(!0), this;
  }
}
const Ji = new _e(), yL = new _e();
class xL {
  constructor(e = {}) {
    const t = this;
    let n, s, r, a;
    const o = {
      camera: { style: "" },
      objects: /* @__PURE__ */ new WeakMap()
    }, l = e.element !== void 0 ? e.element : document.createElement("div");
    l.style.overflow = "hidden", this.domElement = l;
    const c = document.createElement("div");
    c.style.transformOrigin = "0 0", c.style.pointerEvents = "none", l.appendChild(c);
    const h = document.createElement("div");
    h.style.transformStyle = "preserve-3d", c.appendChild(h), this.getSize = function() {
      return {
        width: n,
        height: s
      };
    }, this.render = function(g, p) {
      const v = p.projectionMatrix.elements[5] * a;
      p.view && p.view.enabled ? (c.style.transform = `translate( ${-p.view.offsetX * (n / p.view.width)}px, ${-p.view.offsetY * (s / p.view.height)}px )`, c.style.transform += `scale( ${p.view.fullWidth / p.view.width}, ${p.view.fullHeight / p.view.height} )`) : c.style.transform = "", g.matrixWorldAutoUpdate === !0 && g.updateMatrixWorld(), p.parent === null && p.matrixWorldAutoUpdate === !0 && p.updateMatrixWorld();
      let y, _;
      p.isOrthographicCamera && (y = -(p.right + p.left) / 2, _ = (p.top + p.bottom) / 2);
      const x = p.view && p.view.enabled ? p.view.height / p.view.fullHeight : 1, M = p.isOrthographicCamera ? `scale( ${x} )scale(` + v + ")translate(" + u(y) + "px," + u(_) + "px)" + d(p.matrixWorldInverse) : `scale( ${x} )translateZ(` + v + "px)" + d(p.matrixWorldInverse), w = (p.isPerspectiveCamera ? "perspective(" + v + "px) " : "") + M + "translate(" + r + "px," + a + "px)";
      o.camera.style !== w && (h.style.transform = w, o.camera.style = w), m(g, g, p);
    }, this.setSize = function(g, p) {
      n = g, s = p, r = n / 2, a = s / 2, l.style.width = g + "px", l.style.height = p + "px", c.style.width = g + "px", c.style.height = p + "px", h.style.width = g + "px", h.style.height = p + "px";
    };
    function u(g) {
      return Math.abs(g) < 1e-10 ? 0 : g;
    }
    function d(g) {
      const p = g.elements;
      return "matrix3d(" + u(p[0]) + "," + u(-p[1]) + "," + u(p[2]) + "," + u(p[3]) + "," + u(p[4]) + "," + u(-p[5]) + "," + u(p[6]) + "," + u(p[7]) + "," + u(p[8]) + "," + u(-p[9]) + "," + u(p[10]) + "," + u(p[11]) + "," + u(p[12]) + "," + u(-p[13]) + "," + u(p[14]) + "," + u(p[15]) + ")";
    }
    function f(g) {
      const p = g.elements;
      return "translate(-50%,-50%)" + ("matrix3d(" + u(p[0]) + "," + u(p[1]) + "," + u(p[2]) + "," + u(p[3]) + "," + u(-p[4]) + "," + u(-p[5]) + "," + u(-p[6]) + "," + u(-p[7]) + "," + u(p[8]) + "," + u(p[9]) + "," + u(p[10]) + "," + u(p[11]) + "," + u(p[12]) + "," + u(p[13]) + "," + u(p[14]) + "," + u(p[15]) + ")");
    }
    function m(g, p, v, y) {
      if (g.isCSS3DObject) {
        const _ = g.visible === !0 && g.layers.test(v.layers) === !0;
        if (g.element.style.display = _ === !0 ? "" : "none", _ === !0) {
          g.onBeforeRender(t, p, v);
          let x;
          g.isCSS3DSprite ? (Ji.copy(v.matrixWorldInverse), Ji.transpose(), g.rotation2D !== 0 && Ji.multiply(yL.makeRotationZ(g.rotation2D)), g.matrixWorld.decompose(U_, _L, F_), Ji.setPosition(U_), Ji.scale(F_), Ji.elements[3] = 0, Ji.elements[7] = 0, Ji.elements[11] = 0, Ji.elements[15] = 1, x = f(Ji)) : x = f(g.matrixWorld);
          const M = g.element, S = o.objects.get(g);
          if (S === void 0 || S.style !== x) {
            M.style.transform = x;
            const w = { style: x };
            o.objects.set(g, w);
          }
          M.parentNode !== h && h.appendChild(M), g.onAfterRender(t, p, v);
        }
      }
      for (let _ = 0, x = g.children.length; _ < x; _++)
        m(g.children[_], p, v);
    }
  }
}
var Yl = function() {
  var i = 0, e = document.createElement("div");
  e.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", e.addEventListener("click", function(h) {
    h.preventDefault(), n(++i % e.children.length);
  }, !1);
  function t(h) {
    return e.appendChild(h.dom), h;
  }
  function n(h) {
    for (var u = 0; u < e.children.length; u++)
      e.children[u].style.display = u === h ? "block" : "none";
    i = h;
  }
  var s = (performance || Date).now(), r = s, a = 0, o = t(new Yl.Panel("FPS", "#0ff", "#002")), l = t(new Yl.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory)
    var c = t(new Yl.Panel("MB", "#f08", "#201"));
  return n(0), {
    REVISION: 16,
    dom: e,
    addPanel: t,
    showPanel: n,
    begin: function() {
      s = (performance || Date).now();
    },
    end: function() {
      a++;
      var h = (performance || Date).now();
      if (l.update(h - s, 200), h >= r + 1e3 && (o.update(a * 1e3 / (h - r), 100), r = h, a = 0, c)) {
        var u = performance.memory;
        c.update(u.usedJSHeapSize / 1048576, u.jsHeapSizeLimit / 1048576);
      }
      return h;
    },
    update: function() {
      s = this.end();
    },
    // Backwards Compatibility
    domElement: e,
    setMode: n
  };
};
Yl.Panel = function(i, e, t) {
  var n = 1 / 0, s = 0, r = Math.round, a = r(window.devicePixelRatio || 1), o = 80 * a, l = 48 * a, c = 3 * a, h = 2 * a, u = 3 * a, d = 15 * a, f = 74 * a, m = 30 * a, g = document.createElement("canvas");
  g.width = o, g.height = l, g.style.cssText = "width:80px;height:48px";
  var p = g.getContext("2d");
  return p.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif", p.textBaseline = "top", p.fillStyle = t, p.fillRect(0, 0, o, l), p.fillStyle = e, p.fillText(i, c, h), p.fillRect(u, d, f, m), p.fillStyle = t, p.globalAlpha = 0.9, p.fillRect(u, d, f, m), {
    dom: g,
    update: function(v, y) {
      n = Math.min(n, v), s = Math.max(s, v), p.fillStyle = t, p.globalAlpha = 1, p.fillRect(0, 0, o, d), p.fillStyle = e, p.fillText(r(v) + " " + i + " (" + r(n) + "-" + r(s) + ")", c, h), p.drawImage(g, u + a, d, f - a, m, u, d, f - a, m), p.fillRect(u + f - a, d, a, m), p.fillStyle = t, p.globalAlpha = 0.9, p.fillRect(u + f - a, d, a, r((1 - v / y) * m));
    }
  };
};
const B_ = new ln(), iu = new T();
class Lb extends _g {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(n), this.setAttribute("position", new ye(e, 3)), this.setAttribute("uv", new ye(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), n.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new Du(t, 6, 1);
    return this.setAttribute("instanceStart", new ei(n, 3, 0)), this.setAttribute("instanceEnd", new ei(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new Du(t, 6, 1);
    return this.setAttribute("instanceColorStart", new ei(n, 3, 0)), this.setAttribute("instanceColorEnd", new ei(n, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new ag(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new ln());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), B_.setFromBufferAttribute(t), this.boundingBox.union(B_));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new oi()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const n = this.boundingSphere.center;
      this.boundingBox.getCenter(n);
      let s = 0;
      for (let r = 0, a = e.count; r < a; r++)
        iu.fromBufferAttribute(e, r), s = Math.max(s, n.distanceToSquared(iu)), iu.fromBufferAttribute(t, r), s = Math.max(s, n.distanceToSquared(iu));
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
ve.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new k(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
zn.line = {
  uniforms: cn.merge([
    ve.common,
    ve.fog,
    ve.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
class Vg extends mt {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: cn.clone(zn.line.uniforms),
      vertexShader: zn.line.vertexShader,
      fragmentShader: zn.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1));
  }
}
const k_ = new T(), z_ = new T(), vn = new tt(), _n = new tt(), es = new tt(), Qf = new T(), Jf = new _e(), xn = new fM(), H_ = new T(), su = new ln(), ru = new oi(), ts = new tt();
let cs, wa;
function G_(i, e, t) {
  return ts.set(0, 0, -e, 1).applyMatrix4(i.projectionMatrix), ts.multiplyScalar(1 / ts.w), ts.x = wa / t.width, ts.y = wa / t.height, ts.applyMatrix4(i.projectionMatrixInverse), ts.multiplyScalar(1 / ts.w), Math.abs(Math.max(ts.x, ts.y));
}
function ML(i, e) {
  const t = i.matrixWorld, n = i.geometry, s = n.attributes.instanceStart, r = n.attributes.instanceEnd, a = Math.min(n.instanceCount, s.count);
  for (let o = 0, l = a; o < l; o++) {
    xn.start.fromBufferAttribute(s, o), xn.end.fromBufferAttribute(r, o), xn.applyMatrix4(t);
    const c = new T(), h = new T();
    cs.distanceSqToSegment(xn.start, xn.end, h, c), h.distanceTo(c) < wa * 0.5 && e.push({
      point: h,
      pointOnLine: c,
      distance: cs.origin.distanceTo(h),
      object: i,
      face: null,
      faceIndex: o,
      uv: null,
      uv1: null
    });
  }
}
function bL(i, e, t) {
  const n = e.projectionMatrix, r = i.material.resolution, a = i.matrixWorld, o = i.geometry, l = o.attributes.instanceStart, c = o.attributes.instanceEnd, h = Math.min(o.instanceCount, l.count), u = -e.near;
  cs.at(1, es), es.w = 1, es.applyMatrix4(e.matrixWorldInverse), es.applyMatrix4(n), es.multiplyScalar(1 / es.w), es.x *= r.x / 2, es.y *= r.y / 2, es.z = 0, Qf.copy(es), Jf.multiplyMatrices(e.matrixWorldInverse, a);
  for (let d = 0, f = h; d < f; d++) {
    if (vn.fromBufferAttribute(l, d), _n.fromBufferAttribute(c, d), vn.w = 1, _n.w = 1, vn.applyMatrix4(Jf), _n.applyMatrix4(Jf), vn.z > u && _n.z > u)
      continue;
    if (vn.z > u) {
      const _ = vn.z - _n.z, x = (vn.z - u) / _;
      vn.lerp(_n, x);
    } else if (_n.z > u) {
      const _ = _n.z - vn.z, x = (_n.z - u) / _;
      _n.lerp(vn, x);
    }
    vn.applyMatrix4(n), _n.applyMatrix4(n), vn.multiplyScalar(1 / vn.w), _n.multiplyScalar(1 / _n.w), vn.x *= r.x / 2, vn.y *= r.y / 2, _n.x *= r.x / 2, _n.y *= r.y / 2, xn.start.copy(vn), xn.start.z = 0, xn.end.copy(_n), xn.end.z = 0;
    const g = xn.closestPointToPointParameter(Qf, !0);
    xn.at(g, H_);
    const p = Kn.lerp(vn.z, _n.z, g), v = p >= -1 && p <= 1, y = Qf.distanceTo(H_) < wa * 0.5;
    if (v && y) {
      xn.start.fromBufferAttribute(l, d), xn.end.fromBufferAttribute(c, d), xn.start.applyMatrix4(a), xn.end.applyMatrix4(a);
      const _ = new T(), x = new T();
      cs.distanceSqToSegment(xn.start, xn.end, x, _), t.push({
        point: x,
        pointOnLine: _,
        distance: cs.origin.distanceTo(x),
        object: i,
        face: null,
        faceIndex: d,
        uv: null,
        uv1: null
      });
    }
  }
}
class SL extends le {
  constructor(e = new Lb(), t = new Vg({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, n = e.attributes.instanceEnd, s = new Float32Array(2 * t.count);
    for (let a = 0, o = 0, l = t.count; a < l; a++, o += 2)
      k_.fromBufferAttribute(t, a), z_.fromBufferAttribute(n, a), s[o] = o === 0 ? 0 : s[o - 1], s[o + 1] = s[o] + k_.distanceTo(z_);
    const r = new Du(s, 2, 1);
    return e.setAttribute("instanceDistanceStart", new ei(r, 1, 0)), e.setAttribute("instanceDistanceEnd", new ei(r, 1, 1)), this;
  }
  raycast(e, t) {
    const n = this.material.worldUnits, s = e.camera;
    s === null && !n && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const r = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    cs = e.ray;
    const a = this.matrixWorld, o = this.geometry, l = this.material;
    wa = l.linewidth + r, o.boundingSphere === null && o.computeBoundingSphere(), ru.copy(o.boundingSphere).applyMatrix4(a);
    let c;
    if (n)
      c = wa * 0.5;
    else {
      const u = Math.max(s.near, ru.distanceToPoint(cs.origin));
      c = G_(s, u, l.resolution);
    }
    if (ru.radius += c, cs.intersectsSphere(ru) === !1)
      return;
    o.boundingBox === null && o.computeBoundingBox(), su.copy(o.boundingBox).applyMatrix4(a);
    let h;
    if (n)
      h = wa * 0.5;
    else {
      const u = Math.max(s.near, su.distanceToPoint(cs.origin));
      h = G_(s, u, l.resolution);
    }
    su.expandByScalar(h), cs.intersectsBox(su) !== !1 && (n ? ML(this, t) : bL(this, s, t));
  }
}
class Ib extends Lb {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let s = 0; s < t; s += 3)
      n[2 * s] = e[s], n[2 * s + 1] = e[s + 1], n[2 * s + 2] = e[s + 2], n[2 * s + 3] = e[s + 3], n[2 * s + 4] = e[s + 4], n[2 * s + 5] = e[s + 5];
    return super.setPositions(n), this;
  }
  setColors(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let s = 0; s < t; s += 3)
      n[2 * s] = e[s], n[2 * s + 1] = e[s + 1], n[2 * s + 2] = e[s + 2], n[2 * s + 3] = e[s + 3], n[2 * s + 4] = e[s + 4], n[2 * s + 5] = e[s + 5];
    return super.setColors(n), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class wL extends SL {
  constructor(e = new Ib(), t = new Vg({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
class Db extends Ua {
  constructor(e, t = {}) {
    const n = t.font;
    if (n === void 0)
      super();
    else {
      const s = n.generateShapes(e, t.size);
      t.depth = t.height !== void 0 ? t.height : 50, t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = !1), super(s, t);
    }
    this.type = "TextGeometry";
  }
}
function TL(i) {
  i("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), i("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), i("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  for (var e = 1; e <= 60; ++e)
    i("EPSG:" + (32600 + e), "+proj=utm +zone=" + e + " +datum=WGS84 +units=m"), i("EPSG:" + (32700 + e), "+proj=utm +zone=" + e + " +south +datum=WGS84 +units=m");
  i.WGS84 = i["EPSG:4326"], i["EPSG:3785"] = i["EPSG:3857"], i.GOOGLE = i["EPSG:3857"], i["EPSG:900913"] = i["EPSG:3857"], i["EPSG:102113"] = i["EPSG:3857"];
}
var Ia = 1, Da = 2, Do = 3, EL = 4, hm = 5, V_ = 6378137, AL = 6356752314e-3, W_ = 0.0066943799901413165, jl = 484813681109536e-20, re = Math.PI / 2, CL = 0.16666666666666666, RL = 0.04722222222222222, PL = 0.022156084656084655, Se = 1e-10, Mn = 0.017453292519943295, fs = 57.29577951308232, _t = Math.PI / 4, wc = Math.PI * 2, Sn = 3.14159265359, li = {};
li.greenwich = 0;
li.lisbon = -9.131906111111;
li.paris = 2.337229166667;
li.bogota = -74.080916666667;
li.madrid = -3.687938888889;
li.rome = 12.452333333333;
li.bern = 7.439583333333;
li.jakarta = 106.807719444444;
li.ferro = -17.666666666667;
li.brussels = 4.367975;
li.stockholm = 18.058277777778;
li.athens = 23.7163375;
li.oslo = 10.722916666667;
const LL = {
  mm: { to_meter: 1e-3 },
  cm: { to_meter: 0.01 },
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 },
  fath: { to_meter: 1.8288 },
  kmi: { to_meter: 1852 },
  "us-ch": { to_meter: 20.1168402336805 },
  "us-mi": { to_meter: 1609.34721869444 },
  km: { to_meter: 1e3 },
  "ind-ft": { to_meter: 0.30479841 },
  "ind-yd": { to_meter: 0.91439523 },
  mi: { to_meter: 1609.344 },
  yd: { to_meter: 0.9144 },
  ch: { to_meter: 20.1168 },
  link: { to_meter: 0.201168 },
  dm: { to_meter: 0.01 },
  in: { to_meter: 0.0254 },
  "ind-ch": { to_meter: 20.11669506 },
  "us-in": { to_meter: 0.025400050800101 },
  "us-yd": { to_meter: 0.914401828803658 }
};
var X_ = /[\s_\-\/\(\)]/g;
function Dr(i, e) {
  if (i[e])
    return i[e];
  for (var t = Object.keys(i), n = e.toLowerCase().replace(X_, ""), s = -1, r, a; ++s < t.length; )
    if (r = t[s], a = r.toLowerCase().replace(X_, ""), a === n)
      return i[r];
}
function um(i) {
  var e = {}, t = i.split("+").map(function(o) {
    return o.trim();
  }).filter(function(o) {
    return o;
  }).reduce(function(o, l) {
    var c = l.split("=");
    return c.push(!0), o[c[0].toLowerCase()] = c[1], o;
  }, {}), n, s, r, a = {
    proj: "projName",
    datum: "datumCode",
    rf: function(o) {
      e.rf = parseFloat(o);
    },
    lat_0: function(o) {
      e.lat0 = o * Mn;
    },
    lat_1: function(o) {
      e.lat1 = o * Mn;
    },
    lat_2: function(o) {
      e.lat2 = o * Mn;
    },
    lat_ts: function(o) {
      e.lat_ts = o * Mn;
    },
    lon_0: function(o) {
      e.long0 = o * Mn;
    },
    lon_1: function(o) {
      e.long1 = o * Mn;
    },
    lon_2: function(o) {
      e.long2 = o * Mn;
    },
    alpha: function(o) {
      e.alpha = parseFloat(o) * Mn;
    },
    gamma: function(o) {
      e.rectified_grid_angle = parseFloat(o);
    },
    lonc: function(o) {
      e.longc = o * Mn;
    },
    x_0: function(o) {
      e.x0 = parseFloat(o);
    },
    y_0: function(o) {
      e.y0 = parseFloat(o);
    },
    k_0: function(o) {
      e.k0 = parseFloat(o);
    },
    k: function(o) {
      e.k0 = parseFloat(o);
    },
    a: function(o) {
      e.a = parseFloat(o);
    },
    b: function(o) {
      e.b = parseFloat(o);
    },
    r: function(o) {
      e.a = e.b = parseFloat(o);
    },
    r_a: function() {
      e.R_A = !0;
    },
    zone: function(o) {
      e.zone = parseInt(o, 10);
    },
    south: function() {
      e.utmSouth = !0;
    },
    towgs84: function(o) {
      e.datum_params = o.split(",").map(function(l) {
        return parseFloat(l);
      });
    },
    to_meter: function(o) {
      e.to_meter = parseFloat(o);
    },
    units: function(o) {
      e.units = o;
      var l = Dr(LL, o);
      l && (e.to_meter = l.to_meter);
    },
    from_greenwich: function(o) {
      e.from_greenwich = o * Mn;
    },
    pm: function(o) {
      var l = Dr(li, o);
      e.from_greenwich = (l || parseFloat(o)) * Mn;
    },
    nadgrids: function(o) {
      o === "@null" ? e.datumCode = "none" : e.nadgrids = o;
    },
    axis: function(o) {
      var l = "ewnsud";
      o.length === 3 && l.indexOf(o.substr(0, 1)) !== -1 && l.indexOf(o.substr(1, 1)) !== -1 && l.indexOf(o.substr(2, 1)) !== -1 && (e.axis = o);
    },
    approx: function() {
      e.approx = !0;
    }
  };
  for (n in t)
    s = t[n], n in a ? (r = a[n], typeof r == "function" ? r(s) : e[r] = s) : e[n] = s;
  return typeof e.datumCode == "string" && e.datumCode !== "WGS84" && (e.datumCode = e.datumCode.toLowerCase()), e;
}
var Tc = 1, Ob = 2, Nb = 3, Gu = 4, Ub = 5, Wg = -1, IL = /\s/, DL = /[A-Za-z]/, OL = /[A-Za-z84_]/, Gd = /[,\]]/, Fb = /[\d\.E\-\+]/;
function Zs(i) {
  if (typeof i != "string")
    throw new Error("not a string");
  this.text = i.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = Tc;
}
Zs.prototype.readCharicter = function() {
  var i = this.text[this.place++];
  if (this.state !== Gu)
    for (; IL.test(i); ) {
      if (this.place >= this.text.length)
        return;
      i = this.text[this.place++];
    }
  switch (this.state) {
    case Tc:
      return this.neutral(i);
    case Ob:
      return this.keyword(i);
    case Gu:
      return this.quoted(i);
    case Ub:
      return this.afterquote(i);
    case Nb:
      return this.number(i);
    case Wg:
      return;
  }
};
Zs.prototype.afterquote = function(i) {
  if (i === '"') {
    this.word += '"', this.state = Gu;
    return;
  }
  if (Gd.test(i)) {
    this.word = this.word.trim(), this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in afterquote yet, index ' + this.place);
};
Zs.prototype.afterItem = function(i) {
  if (i === ",") {
    this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = Tc;
    return;
  }
  if (i === "]") {
    this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = Tc, this.currentObject = this.stack.pop(), this.currentObject || (this.state = Wg);
    return;
  }
};
Zs.prototype.number = function(i) {
  if (Fb.test(i)) {
    this.word += i;
    return;
  }
  if (Gd.test(i)) {
    this.word = parseFloat(this.word), this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in number yet, index ' + this.place);
};
Zs.prototype.quoted = function(i) {
  if (i === '"') {
    this.state = Ub;
    return;
  }
  this.word += i;
};
Zs.prototype.keyword = function(i) {
  if (OL.test(i)) {
    this.word += i;
    return;
  }
  if (i === "[") {
    var e = [];
    e.push(this.word), this.level++, this.root === null ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, this.state = Tc;
    return;
  }
  if (Gd.test(i)) {
    this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in keyword yet, index ' + this.place);
};
Zs.prototype.neutral = function(i) {
  if (DL.test(i)) {
    this.word = i, this.state = Ob;
    return;
  }
  if (i === '"') {
    this.word = "", this.state = Gu;
    return;
  }
  if (Fb.test(i)) {
    this.word = i, this.state = Nb;
    return;
  }
  if (Gd.test(i)) {
    this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in neutral yet, index ' + this.place);
};
Zs.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === Wg)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function NL(i) {
  var e = new Zs(i);
  return e.output();
}
function ep(i, e, t) {
  Array.isArray(e) && (t.unshift(e), e = null);
  var n = e ? {} : i, s = t.reduce(function(r, a) {
    return Mo(a, r), r;
  }, n);
  e && (i[e] = s);
}
function Mo(i, e) {
  if (!Array.isArray(i)) {
    e[i] = !0;
    return;
  }
  var t = i.shift();
  if (t === "PARAMETER" && (t = i.shift()), i.length === 1) {
    if (Array.isArray(i[0])) {
      e[t] = {}, Mo(i[0], e[t]);
      return;
    }
    e[t] = i[0];
    return;
  }
  if (!i.length) {
    e[t] = !0;
    return;
  }
  if (t === "TOWGS84") {
    e[t] = i;
    return;
  }
  if (t === "AXIS") {
    t in e || (e[t] = []), e[t].push(i);
    return;
  }
  Array.isArray(t) || (e[t] = {});
  var n;
  switch (t) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      e[t] = {
        name: i[0].toLowerCase(),
        convert: i[1]
      }, i.length === 3 && Mo(i[2], e[t]);
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      e[t] = {
        name: i[0],
        a: i[1],
        rf: i[2]
      }, i.length === 4 && Mo(i[3], e[t]);
      return;
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "LOCAL_DATUM":
    case "DATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
      i[0] = ["name", i[0]], ep(e, t, i);
      return;
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "FITTED_CS":
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "ENGCRS":
    case "ENGINEERINGCRS":
      i[0] = ["name", i[0]], ep(e, t, i), e[t].type = t;
      return;
    default:
      for (n = -1; ++n < i.length; )
        if (!Array.isArray(i[n]))
          return Mo(i, e[t]);
      return ep(e, t, i);
  }
}
var UL = 0.017453292519943295, FL = [
  "PROJECTEDCRS",
  "PROJCRS",
  "GEOGCS",
  "GEOCCS",
  "PROJCS",
  "LOCAL_CS",
  "GEODCRS",
  "GEODETICCRS",
  "GEODETICDATUM",
  "ENGCRS",
  "ENGINEERINGCRS"
];
function BL(i, e) {
  var t = e[0], n = e[1];
  !(t in i) && n in i && (i[t] = i[n], e.length === 3 && (i[t] = e[2](i[t])));
}
function ns(i) {
  return i * UL;
}
function Bb(i) {
  for (var e = Object.keys(i), t = 0, n = e.length; t < n; ++t) {
    var s = e[t];
    FL.indexOf(s) !== -1 && kL(i[s]), typeof i[s] == "object" && Bb(i[s]);
  }
}
function kL(i) {
  if (i.AUTHORITY) {
    var e = Object.keys(i.AUTHORITY)[0];
    e && e in i.AUTHORITY && (i.title = e + ":" + i.AUTHORITY[e]);
  }
  if (i.type === "GEOGCS" ? i.projName = "longlat" : i.type === "LOCAL_CS" ? (i.projName = "identity", i.local = !0) : typeof i.PROJECTION == "object" ? i.projName = Object.keys(i.PROJECTION)[0] : i.projName = i.PROJECTION, i.AXIS) {
    for (var t = "", n = 0, s = i.AXIS.length; n < s; ++n) {
      var r = [i.AXIS[n][0].toLowerCase(), i.AXIS[n][1].toLowerCase()];
      r[0].indexOf("north") !== -1 || (r[0] === "y" || r[0] === "lat") && r[1] === "north" ? t += "n" : r[0].indexOf("south") !== -1 || (r[0] === "y" || r[0] === "lat") && r[1] === "south" ? t += "s" : r[0].indexOf("east") !== -1 || (r[0] === "x" || r[0] === "lon") && r[1] === "east" ? t += "e" : (r[0].indexOf("west") !== -1 || (r[0] === "x" || r[0] === "lon") && r[1] === "west") && (t += "w");
    }
    t.length === 2 && (t += "u"), t.length === 3 && (i.axis = t);
  }
  i.UNIT && (i.units = i.UNIT.name.toLowerCase(), i.units === "metre" && (i.units = "meter"), i.UNIT.convert && (i.type === "GEOGCS" ? i.DATUM && i.DATUM.SPHEROID && (i.to_meter = i.UNIT.convert * i.DATUM.SPHEROID.a) : i.to_meter = i.UNIT.convert));
  var a = i.GEOGCS;
  i.type === "GEOGCS" && (a = i), a && (a.DATUM ? i.datumCode = a.DATUM.name.toLowerCase() : i.datumCode = a.name.toLowerCase(), i.datumCode.slice(0, 2) === "d_" && (i.datumCode = i.datumCode.slice(2)), i.datumCode === "new_zealand_1949" && (i.datumCode = "nzgd49"), (i.datumCode === "wgs_1984" || i.datumCode === "world_geodetic_system_1984") && (i.PROJECTION === "Mercator_Auxiliary_Sphere" && (i.sphere = !0), i.datumCode = "wgs84"), i.datumCode === "belge_1972" && (i.datumCode = "rnb72"), a.DATUM && a.DATUM.SPHEROID && (i.ellps = a.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), i.ellps.toLowerCase().slice(0, 13) === "international" && (i.ellps = "intl"), i.a = a.DATUM.SPHEROID.a, i.rf = parseFloat(a.DATUM.SPHEROID.rf, 10)), a.DATUM && a.DATUM.TOWGS84 && (i.datum_params = a.DATUM.TOWGS84), ~i.datumCode.indexOf("osgb_1936") && (i.datumCode = "osgb36"), ~i.datumCode.indexOf("osni_1952") && (i.datumCode = "osni52"), (~i.datumCode.indexOf("tm65") || ~i.datumCode.indexOf("geodetic_datum_of_1965")) && (i.datumCode = "ire65"), i.datumCode === "ch1903+" && (i.datumCode = "ch1903"), ~i.datumCode.indexOf("israel") && (i.datumCode = "isr93")), i.b && !isFinite(i.b) && (i.b = i.a);
  function o(h) {
    var u = i.to_meter || 1;
    return h * u;
  }
  var l = function(h) {
    return BL(i, h);
  }, c = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", ns],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", ns],
    ["x0", "false_easting", o],
    ["y0", "false_northing", o],
    ["long0", "central_meridian", ns],
    ["lat0", "latitude_of_origin", ns],
    ["lat0", "standard_parallel_1", ns],
    ["lat1", "standard_parallel_1", ns],
    ["lat2", "standard_parallel_2", ns],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", ns],
    ["srsCode", "name"]
  ];
  c.forEach(l), !i.long0 && i.longc && (i.projName === "Albers_Conic_Equal_Area" || i.projName === "Lambert_Azimuthal_Equal_Area") && (i.long0 = i.longc), !i.lat_ts && i.lat1 && (i.projName === "Stereographic_South_Pole" || i.projName === "Polar Stereographic (variant B)") ? (i.lat0 = ns(i.lat1 > 0 ? 90 : -90), i.lat_ts = i.lat1) : !i.lat_ts && i.lat0 && i.projName === "Polar_Stereographic" && (i.lat_ts = i.lat0, i.lat0 = ns(i.lat0 > 0 ? 90 : -90));
}
function kb(i) {
  var e = NL(i), t = e[0], n = {};
  return Mo(e, n), Bb(n), n[t];
}
function Bn(i) {
  var e = this;
  if (arguments.length === 2) {
    var t = arguments[1];
    typeof t == "string" ? t.charAt(0) === "+" ? Bn[i] = um(arguments[1]) : Bn[i] = kb(arguments[1]) : Bn[i] = t;
  } else if (arguments.length === 1) {
    if (Array.isArray(i))
      return i.map(function(n) {
        Array.isArray(n) ? Bn.apply(e, n) : Bn(n);
      });
    if (typeof i == "string") {
      if (i in Bn)
        return Bn[i];
    } else "EPSG" in i ? Bn["EPSG:" + i.EPSG] = i : "ESRI" in i ? Bn["ESRI:" + i.ESRI] = i : "IAU2000" in i ? Bn["IAU2000:" + i.IAU2000] = i : console.log(i);
    return;
  }
}
TL(Bn);
function zL(i) {
  return typeof i == "string";
}
function HL(i) {
  return i in Bn;
}
var GL = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function VL(i) {
  return GL.some(function(e) {
    return i.indexOf(e) > -1;
  });
}
var WL = ["3857", "900913", "3785", "102113"];
function XL(i) {
  var e = Dr(i, "authority");
  if (e) {
    var t = Dr(e, "epsg");
    return t && WL.indexOf(t) > -1;
  }
}
function qL(i) {
  var e = Dr(i, "extension");
  if (e)
    return Dr(e, "proj4");
}
function YL(i) {
  return i[0] === "+";
}
function jL(i) {
  if (zL(i)) {
    if (HL(i))
      return Bn[i];
    if (VL(i)) {
      var e = kb(i);
      if (XL(e))
        return Bn["EPSG:3857"];
      var t = qL(e);
      return t ? um(t) : e;
    }
    if (YL(i))
      return um(i);
  } else
    return i;
}
function q_(i, e) {
  i = i || {};
  var t, n;
  if (!e)
    return i;
  for (n in e)
    t = e[n], t !== void 0 && (i[n] = t);
  return i;
}
function Ms(i, e, t) {
  var n = i * e;
  return t / Math.sqrt(1 - n * n);
}
function Zc(i) {
  return i < 0 ? -1 : 1;
}
function Te(i) {
  return Math.abs(i) <= Sn ? i : i - Zc(i) * wc;
}
function Vi(i, e, t) {
  var n = i * t, s = 0.5 * i;
  return n = Math.pow((1 - n) / (1 + n), s), Math.tan(0.5 * (re - e)) / n;
}
function Ec(i, e) {
  for (var t = 0.5 * i, n, s, r = re - 2 * Math.atan(e), a = 0; a <= 15; a++)
    if (n = i * Math.sin(r), s = re - 2 * Math.atan(e * Math.pow((1 - n) / (1 + n), t)) - r, r += s, Math.abs(s) <= 1e-10)
      return r;
  return -9999;
}
function ZL() {
  var i = this.b / this.a;
  this.es = 1 - i * i, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = Ms(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}
function $L(i) {
  var e = i.x, t = i.y;
  if (t * fs > 90 && t * fs < -90 && e * fs > 180 && e * fs < -180)
    return null;
  var n, s;
  if (Math.abs(Math.abs(t) - re) <= Se)
    return null;
  if (this.sphere)
    n = this.x0 + this.a * this.k0 * Te(e - this.long0), s = this.y0 + this.a * this.k0 * Math.log(Math.tan(_t + 0.5 * t));
  else {
    var r = Math.sin(t), a = Vi(this.e, t, r);
    n = this.x0 + this.a * this.k0 * Te(e - this.long0), s = this.y0 - this.a * this.k0 * Math.log(a);
  }
  return i.x = n, i.y = s, i;
}
function KL(i) {
  var e = i.x - this.x0, t = i.y - this.y0, n, s;
  if (this.sphere)
    s = re - 2 * Math.atan(Math.exp(-t / (this.a * this.k0)));
  else {
    var r = Math.exp(-t / (this.a * this.k0));
    if (s = Ec(this.e, r), s === -9999)
      return null;
  }
  return n = Te(this.long0 + e / (this.a * this.k0)), i.x = n, i.y = s, i;
}
var QL = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
const JL = {
  init: ZL,
  forward: $L,
  inverse: KL,
  names: QL
};
function eI() {
}
function Y_(i) {
  return i;
}
var tI = ["longlat", "identity"];
const nI = {
  init: eI,
  forward: Y_,
  inverse: Y_,
  names: tI
};
var iI = [JL, nI], Mu = {}, Vu = [];
function zb(i, e) {
  var t = Vu.length;
  return i.names ? (Vu[t] = i, i.names.forEach(function(n) {
    Mu[n.toLowerCase()] = t;
  }), this) : (console.log(e), !0);
}
function sI(i) {
  if (!i)
    return !1;
  var e = i.toLowerCase();
  if (typeof Mu[e] < "u" && Vu[Mu[e]])
    return Vu[Mu[e]];
}
function rI() {
  iI.forEach(zb);
}
const aI = {
  start: rI,
  add: zb,
  get: sI
};
var Ye = {};
Ye.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
Ye.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
Ye.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
Ye.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
Ye.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
Ye.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
Ye.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
Ye.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
Ye.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
Ye.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
Ye.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
Ye.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
Ye.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
Ye.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
Ye.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
Ye.clrk80ign = {
  a: 63782492e-1,
  b: 6356515,
  rf: 293.4660213,
  ellipseName: "Clarke 1880 (IGN)"
};
Ye.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
Ye.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
Ye.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
Ye.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
Ye.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
Ye.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
Ye.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
Ye.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
Ye.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
Ye.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
Ye.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
Ye.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
Ye.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
Ye.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
Ye.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
Ye.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
Ye.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
Ye.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
Ye.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
Ye.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
Ye.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
Ye.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
Ye.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
Ye.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
Ye.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
Ye.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var oI = Ye.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
Ye.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};
function lI(i, e, t, n) {
  var s = i * i, r = e * e, a = (s - r) / s, o = 0;
  n ? (i *= 1 - a * (CL + a * (RL + a * PL)), s = i * i, a = 0) : o = Math.sqrt(a);
  var l = (s - r) / r;
  return {
    es: a,
    e: o,
    ep2: l
  };
}
function cI(i, e, t, n, s) {
  if (!i) {
    var r = Dr(Ye, n);
    r || (r = oI), i = r.a, e = r.b, t = r.rf;
  }
  return t && !e && (e = (1 - 1 / t) * i), (t === 0 || Math.abs(i - e) < Se) && (s = !0, e = i), {
    a: i,
    b: e,
    rf: t,
    sphere: s
  };
}
var bu = {
  wgs84: {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
  },
  ch1903: {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
  },
  ggrs87: {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
  },
  nad83: {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
  },
  nad27: {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
  },
  potsdam: {
    towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
  },
  carthage: {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
  },
  hermannskogel: {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Hermannskogel"
  },
  mgi: {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Militar-Geographische Institut"
  },
  osni52: {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
  },
  ire65: {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
  },
  rassadiran: {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
  },
  nzgd49: {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
  },
  osgb36: {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Ordnance Survey of Great Britain 1936"
  },
  s_jtsk: {
    towgs84: "589,76,480",
    ellipse: "bessel",
    datumName: "S-JTSK (Ferro)"
  },
  beduaram: {
    towgs84: "-106,-87,188",
    ellipse: "clrk80",
    datumName: "Beduaram"
  },
  gunung_segara: {
    towgs84: "-403,684,41",
    ellipse: "bessel",
    datumName: "Gunung Segara Jakarta"
  },
  rnb72: {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
  }
};
for (var hI in bu) {
  var j_ = bu[hI];
  bu[j_.datumName] = j_;
}
function uI(i, e, t, n, s, r, a) {
  var o = {};
  return i === void 0 || i === "none" ? o.datum_type = hm : o.datum_type = EL, e && (o.datum_params = e.map(parseFloat), (o.datum_params[0] !== 0 || o.datum_params[1] !== 0 || o.datum_params[2] !== 0) && (o.datum_type = Ia), o.datum_params.length > 3 && (o.datum_params[3] !== 0 || o.datum_params[4] !== 0 || o.datum_params[5] !== 0 || o.datum_params[6] !== 0) && (o.datum_type = Da, o.datum_params[3] *= jl, o.datum_params[4] *= jl, o.datum_params[5] *= jl, o.datum_params[6] = o.datum_params[6] / 1e6 + 1)), a && (o.datum_type = Do, o.grids = a), o.a = t, o.b = n, o.es = s, o.ep2 = r, o;
}
var Hb = {};
function dI(i, e) {
  var t = new DataView(e), n = mI(t), s = gI(t, n), r = vI(t, s, n), a = { header: s, subgrids: r };
  return Hb[i] = a, a;
}
function fI(i) {
  if (i === void 0)
    return null;
  var e = i.split(",");
  return e.map(pI);
}
function pI(i) {
  if (i.length === 0)
    return null;
  var e = i[0] === "@";
  return e && (i = i.slice(1)), i === "null" ? { name: "null", mandatory: !e, grid: null, isNull: !0 } : {
    name: i,
    mandatory: !e,
    grid: Hb[i] || null,
    isNull: !1
  };
}
function bo(i) {
  return i / 3600 * Math.PI / 180;
}
function mI(i) {
  var e = i.getInt32(8, !1);
  return e === 11 ? !1 : (e = i.getInt32(8, !0), e !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
}
function gI(i, e) {
  return {
    nFields: i.getInt32(8, e),
    nSubgridFields: i.getInt32(24, e),
    nSubgrids: i.getInt32(40, e),
    shiftType: dm(i, 56, 64).trim(),
    fromSemiMajorAxis: i.getFloat64(120, e),
    fromSemiMinorAxis: i.getFloat64(136, e),
    toSemiMajorAxis: i.getFloat64(152, e),
    toSemiMinorAxis: i.getFloat64(168, e)
  };
}
function dm(i, e, t) {
  return String.fromCharCode.apply(null, new Uint8Array(i.buffer.slice(e, t)));
}
function vI(i, e, t) {
  for (var n = 176, s = [], r = 0; r < e.nSubgrids; r++) {
    var a = yI(i, n, t), o = xI(i, n, a, t), l = Math.round(
      1 + (a.upperLongitude - a.lowerLongitude) / a.longitudeInterval
    ), c = Math.round(
      1 + (a.upperLatitude - a.lowerLatitude) / a.latitudeInterval
    );
    s.push({
      ll: [bo(a.lowerLongitude), bo(a.lowerLatitude)],
      del: [bo(a.longitudeInterval), bo(a.latitudeInterval)],
      lim: [l, c],
      count: a.gridNodeCount,
      cvs: _I(o)
    }), n += 176 + a.gridNodeCount * 16;
  }
  return s;
}
function _I(i) {
  return i.map(function(e) {
    return [bo(e.longitudeShift), bo(e.latitudeShift)];
  });
}
function yI(i, e, t) {
  return {
    name: dm(i, e + 8, e + 16).trim(),
    parent: dm(i, e + 24, e + 24 + 8).trim(),
    lowerLatitude: i.getFloat64(e + 72, t),
    upperLatitude: i.getFloat64(e + 88, t),
    lowerLongitude: i.getFloat64(e + 104, t),
    upperLongitude: i.getFloat64(e + 120, t),
    latitudeInterval: i.getFloat64(e + 136, t),
    longitudeInterval: i.getFloat64(e + 152, t),
    gridNodeCount: i.getInt32(e + 168, t)
  };
}
function xI(i, e, t, n) {
  for (var s = e + 176, r = 16, a = [], o = 0; o < t.gridNodeCount; o++) {
    var l = {
      latitudeShift: i.getFloat32(s + o * r, n),
      longitudeShift: i.getFloat32(s + o * r + 4, n),
      latitudeAccuracy: i.getFloat32(s + o * r + 8, n),
      longitudeAccuracy: i.getFloat32(s + o * r + 12, n)
    };
    a.push(l);
  }
  return a;
}
function _s(i, e) {
  if (!(this instanceof _s))
    return new _s(i);
  e = e || function(c) {
    if (c)
      throw c;
  };
  var t = jL(i);
  if (typeof t != "object") {
    e("Could not parse to valid json: " + i);
    return;
  }
  var n = _s.projections.get(t.projName);
  if (!n) {
    e("Could not get projection name from: " + i);
    return;
  }
  if (t.datumCode && t.datumCode !== "none") {
    var s = Dr(bu, t.datumCode);
    s && (t.datum_params = t.datum_params || (s.towgs84 ? s.towgs84.split(",") : null), t.ellps = s.ellipse, t.datumName = s.datumName ? s.datumName : t.datumCode);
  }
  t.k0 = t.k0 || 1, t.axis = t.axis || "enu", t.ellps = t.ellps || "wgs84", t.lat1 = t.lat1 || t.lat0;
  var r = cI(t.a, t.b, t.rf, t.ellps, t.sphere), a = lI(r.a, r.b, r.rf, t.R_A), o = fI(t.nadgrids), l = t.datum || uI(
    t.datumCode,
    t.datum_params,
    r.a,
    r.b,
    a.es,
    a.ep2,
    o
  );
  q_(this, t), q_(this, n), this.a = r.a, this.b = r.b, this.rf = r.rf, this.sphere = r.sphere, this.es = a.es, this.e = a.e, this.ep2 = a.ep2, this.datum = l, this.init(), e(null, this);
}
_s.projections = aI;
_s.projections.start();
function MI(i, e) {
  return i.datum_type !== e.datum_type || i.a !== e.a || Math.abs(i.es - e.es) > 5e-11 ? !1 : i.datum_type === Ia ? i.datum_params[0] === e.datum_params[0] && i.datum_params[1] === e.datum_params[1] && i.datum_params[2] === e.datum_params[2] : i.datum_type === Da ? i.datum_params[0] === e.datum_params[0] && i.datum_params[1] === e.datum_params[1] && i.datum_params[2] === e.datum_params[2] && i.datum_params[3] === e.datum_params[3] && i.datum_params[4] === e.datum_params[4] && i.datum_params[5] === e.datum_params[5] && i.datum_params[6] === e.datum_params[6] : !0;
}
function Gb(i, e, t) {
  var n = i.x, s = i.y, r = i.z ? i.z : 0, a, o, l, c;
  if (s < -re && s > -1.001 * re)
    s = -re;
  else if (s > re && s < 1.001 * re)
    s = re;
  else {
    if (s < -re)
      return { x: -1 / 0, y: -1 / 0, z: i.z };
    if (s > re)
      return { x: 1 / 0, y: 1 / 0, z: i.z };
  }
  return n > Math.PI && (n -= 2 * Math.PI), o = Math.sin(s), c = Math.cos(s), l = o * o, a = t / Math.sqrt(1 - e * l), {
    x: (a + r) * c * Math.cos(n),
    y: (a + r) * c * Math.sin(n),
    z: (a * (1 - e) + r) * o
  };
}
function Vb(i, e, t, n) {
  var s = 1e-12, r = s * s, a = 30, o, l, c, h, u, d, f, m, g, p, v, y, _, x = i.x, M = i.y, S = i.z ? i.z : 0, w, E, b;
  if (o = Math.sqrt(x * x + M * M), l = Math.sqrt(x * x + M * M + S * S), o / t < s) {
    if (w = 0, l / t < s)
      return E = re, b = -n, {
        x: i.x,
        y: i.y,
        z: i.z
      };
  } else
    w = Math.atan2(M, x);
  c = S / l, h = o / l, u = 1 / Math.sqrt(1 - e * (2 - e) * h * h), m = h * (1 - e) * u, g = c * u, _ = 0;
  do
    _++, f = t / Math.sqrt(1 - e * g * g), b = o * m + S * g - f * (1 - e * g * g), d = e * f / (f + b), u = 1 / Math.sqrt(1 - d * (2 - d) * h * h), p = h * (1 - d) * u, v = c * u, y = v * m - p * g, m = p, g = v;
  while (y * y > r && _ < a);
  return E = Math.atan(v / Math.abs(p)), {
    x: w,
    y: E,
    z: b
  };
}
function bI(i, e, t) {
  if (e === Ia)
    return {
      x: i.x + t[0],
      y: i.y + t[1],
      z: i.z + t[2]
    };
  if (e === Da) {
    var n = t[0], s = t[1], r = t[2], a = t[3], o = t[4], l = t[5], c = t[6];
    return {
      x: c * (i.x - l * i.y + o * i.z) + n,
      y: c * (l * i.x + i.y - a * i.z) + s,
      z: c * (-o * i.x + a * i.y + i.z) + r
    };
  }
}
function SI(i, e, t) {
  if (e === Ia)
    return {
      x: i.x - t[0],
      y: i.y - t[1],
      z: i.z - t[2]
    };
  if (e === Da) {
    var n = t[0], s = t[1], r = t[2], a = t[3], o = t[4], l = t[5], c = t[6], h = (i.x - n) / c, u = (i.y - s) / c, d = (i.z - r) / c;
    return {
      x: h + l * u - o * d,
      y: -l * h + u + a * d,
      z: o * h - a * u + d
    };
  }
}
function au(i) {
  return i === Ia || i === Da;
}
function wI(i, e, t) {
  if (MI(i, e) || i.datum_type === hm || e.datum_type === hm)
    return t;
  var n = i.a, s = i.es;
  if (i.datum_type === Do) {
    var r = Z_(i, !1, t);
    if (r !== 0)
      return;
    n = V_, s = W_;
  }
  var a = e.a, o = e.b, l = e.es;
  if (e.datum_type === Do && (a = V_, o = AL, l = W_), s === l && n === a && !au(i.datum_type) && !au(e.datum_type))
    return t;
  if (t = Gb(t, s, n), au(i.datum_type) && (t = bI(t, i.datum_type, i.datum_params)), au(e.datum_type) && (t = SI(t, e.datum_type, e.datum_params)), t = Vb(t, l, a, o), e.datum_type === Do) {
    var c = Z_(e, !0, t);
    if (c !== 0)
      return;
  }
  return t;
}
function Z_(i, e, t) {
  if (i.grids === null || i.grids.length === 0)
    return console.log("Grid shift grids not found"), -1;
  var n = { x: -t.x, y: t.y }, s = { x: Number.NaN, y: Number.NaN }, r = [];
  e:
    for (var a = 0; a < i.grids.length; a++) {
      var o = i.grids[a];
      if (r.push(o.name), o.isNull) {
        s = n;
        break;
      }
      if (o.mandatory, o.grid === null) {
        if (o.mandatory)
          return console.log("Unable to find mandatory grid '" + o.name + "'"), -1;
        continue;
      }
      for (var l = o.grid.subgrids, c = 0, h = l.length; c < h; c++) {
        var u = l[c], d = (Math.abs(u.del[1]) + Math.abs(u.del[0])) / 1e4, f = u.ll[0] - d, m = u.ll[1] - d, g = u.ll[0] + (u.lim[0] - 1) * u.del[0] + d, p = u.ll[1] + (u.lim[1] - 1) * u.del[1] + d;
        if (!(m > n.y || f > n.x || p < n.y || g < n.x) && (s = TI(n, e, u), !isNaN(s.x)))
          break e;
      }
    }
  return isNaN(s.x) ? (console.log("Failed to find a grid shift table for location '" + -n.x * fs + " " + n.y * fs + " tried: '" + r + "'"), -1) : (t.x = -s.x, t.y = s.y, 0);
}
function TI(i, e, t) {
  var n = { x: Number.NaN, y: Number.NaN };
  if (isNaN(i.x))
    return n;
  var s = { x: i.x, y: i.y };
  s.x -= t.ll[0], s.y -= t.ll[1], s.x = Te(s.x - Math.PI) + Math.PI;
  var r = $_(s, t);
  if (e) {
    if (isNaN(r.x))
      return n;
    r.x = s.x - r.x, r.y = s.y - r.y;
    var a = 9, o = 1e-12, l, c;
    do {
      if (c = $_(r, t), isNaN(c.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      l = { x: s.x - (c.x + r.x), y: s.y - (c.y + r.y) }, r.x += l.x, r.y += l.y;
    } while (a-- && Math.abs(l.x) > o && Math.abs(l.y) > o);
    if (a < 0)
      return console.log("Inverse grid shift iterator failed to converge."), n;
    n.x = Te(r.x + t.ll[0]), n.y = r.y + t.ll[1];
  } else
    isNaN(r.x) || (n.x = i.x + r.x, n.y = i.y + r.y);
  return n;
}
function $_(i, e) {
  var t = { x: i.x / e.del[0], y: i.y / e.del[1] }, n = { x: Math.floor(t.x), y: Math.floor(t.y) }, s = { x: t.x - 1 * n.x, y: t.y - 1 * n.y }, r = { x: Number.NaN, y: Number.NaN }, a;
  if (n.x < 0 || n.x >= e.lim[0] || n.y < 0 || n.y >= e.lim[1])
    return r;
  a = n.y * e.lim[0] + n.x;
  var o = { x: e.cvs[a][0], y: e.cvs[a][1] };
  a++;
  var l = { x: e.cvs[a][0], y: e.cvs[a][1] };
  a += e.lim[0];
  var c = { x: e.cvs[a][0], y: e.cvs[a][1] };
  a--;
  var h = { x: e.cvs[a][0], y: e.cvs[a][1] }, u = s.x * s.y, d = s.x * (1 - s.y), f = (1 - s.x) * (1 - s.y), m = (1 - s.x) * s.y;
  return r.x = f * o.x + d * l.x + m * h.x + u * c.x, r.y = f * o.y + d * l.y + m * h.y + u * c.y, r;
}
function K_(i, e, t) {
  var n = t.x, s = t.y, r = t.z || 0, a, o, l, c = {};
  for (l = 0; l < 3; l++)
    if (!(e && l === 2 && t.z === void 0))
      switch (l === 0 ? (a = n, "ew".indexOf(i.axis[l]) !== -1 ? o = "x" : o = "y") : l === 1 ? (a = s, "ns".indexOf(i.axis[l]) !== -1 ? o = "y" : o = "x") : (a = r, o = "z"), i.axis[l]) {
        case "e":
          c[o] = a;
          break;
        case "w":
          c[o] = -a;
          break;
        case "n":
          c[o] = a;
          break;
        case "s":
          c[o] = -a;
          break;
        case "u":
          t[o] !== void 0 && (c.z = a);
          break;
        case "d":
          t[o] !== void 0 && (c.z = -a);
          break;
        default:
          return null;
      }
  return c;
}
function Wb(i) {
  var e = {
    x: i[0],
    y: i[1]
  };
  return i.length > 2 && (e.z = i[2]), i.length > 3 && (e.m = i[3]), e;
}
function EI(i) {
  Q_(i.x), Q_(i.y);
}
function Q_(i) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(i))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof i != "number" || i !== i || !isFinite(i))
    throw new TypeError("coordinates must be finite numbers");
}
function AI(i, e) {
  return (i.datum.datum_type === Ia || i.datum.datum_type === Da || i.datum.datum_type === Do) && e.datumCode !== "WGS84" || (e.datum.datum_type === Ia || e.datum.datum_type === Da || e.datum.datum_type === Do) && i.datumCode !== "WGS84";
}
function Wu(i, e, t, n) {
  var s;
  Array.isArray(t) ? t = Wb(t) : t = {
    x: t.x,
    y: t.y,
    z: t.z,
    m: t.m
  };
  var r = t.z !== void 0;
  if (EI(t), i.datum && e.datum && AI(i, e) && (s = new _s("WGS84"), t = Wu(i, s, t, n), i = s), n && i.axis !== "enu" && (t = K_(i, !1, t)), i.projName === "longlat")
    t = {
      x: t.x * Mn,
      y: t.y * Mn,
      z: t.z || 0
    };
  else if (i.to_meter && (t = {
    x: t.x * i.to_meter,
    y: t.y * i.to_meter,
    z: t.z || 0
  }), t = i.inverse(t), !t)
    return;
  if (i.from_greenwich && (t.x += i.from_greenwich), t = wI(i.datum, e.datum, t), !!t)
    return e.from_greenwich && (t = {
      x: t.x - e.from_greenwich,
      y: t.y,
      z: t.z || 0
    }), e.projName === "longlat" ? t = {
      x: t.x * fs,
      y: t.y * fs,
      z: t.z || 0
    } : (t = e.forward(t), e.to_meter && (t = {
      x: t.x / e.to_meter,
      y: t.y / e.to_meter,
      z: t.z || 0
    })), n && e.axis !== "enu" ? K_(e, !0, t) : (t && !r && delete t.z, t);
}
var J_ = _s("WGS84");
function tp(i, e, t, n) {
  var s, r, a;
  return Array.isArray(t) ? (s = Wu(i, e, t, n) || { x: NaN, y: NaN }, t.length > 2 ? typeof i.name < "u" && i.name === "geocent" || typeof e.name < "u" && e.name === "geocent" ? typeof s.z == "number" ? [s.x, s.y, s.z].concat(t.slice(3)) : [s.x, s.y, t[2]].concat(t.slice(3)) : [s.x, s.y].concat(t.slice(2)) : [s.x, s.y]) : (r = Wu(i, e, t, n), a = Object.keys(t), a.length === 2 || a.forEach(function(o) {
    if (typeof i.name < "u" && i.name === "geocent" || typeof e.name < "u" && e.name === "geocent") {
      if (o === "x" || o === "y" || o === "z")
        return;
    } else if (o === "x" || o === "y")
      return;
    r[o] = t[o];
  }), r);
}
function ey(i) {
  return i instanceof _s ? i : i.oProj ? i.oProj : _s(i);
}
function ai(i, e, t) {
  i = ey(i);
  var n = !1, s;
  return typeof e > "u" ? (e = i, i = J_, n = !0) : (typeof e.x < "u" || Array.isArray(e)) && (t = e, e = i, i = J_, n = !0), e = ey(e), t ? tp(i, e, t) : (s = {
    forward: function(r, a) {
      return tp(i, e, r, a);
    },
    inverse: function(r, a) {
      return tp(e, i, r, a);
    }
  }, n && (s.oProj = e), s);
}
var ty = 6, Xb = "AJSAJS", qb = "AFAFAF", So = 65, jn = 73, Ri = 79, Nl = 86, Ul = 90;
const CI = {
  forward: Yb,
  inverse: RI,
  toPoint: jb
};
function Yb(i, e) {
  return e = e || 5, II(PI({
    lat: i[1],
    lon: i[0]
  }), e);
}
function RI(i) {
  var e = Xg($b(i.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top];
}
function jb(i) {
  var e = Xg($b(i.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2];
}
function np(i) {
  return i * (Math.PI / 180);
}
function ny(i) {
  return 180 * (i / Math.PI);
}
function PI(i) {
  var e = i.lat, t = i.lon, n = 6378137, s = 669438e-8, r = 0.9996, a, o, l, c, h, u, d, f = np(e), m = np(t), g, p;
  p = Math.floor((t + 180) / 6) + 1, t === 180 && (p = 60), e >= 56 && e < 64 && t >= 3 && t < 12 && (p = 32), e >= 72 && e < 84 && (t >= 0 && t < 9 ? p = 31 : t >= 9 && t < 21 ? p = 33 : t >= 21 && t < 33 ? p = 35 : t >= 33 && t < 42 && (p = 37)), a = (p - 1) * 6 - 180 + 3, g = np(a), o = s / (1 - s), l = n / Math.sqrt(1 - s * Math.sin(f) * Math.sin(f)), c = Math.tan(f) * Math.tan(f), h = o * Math.cos(f) * Math.cos(f), u = Math.cos(f) * (m - g), d = n * ((1 - s / 4 - 3 * s * s / 64 - 5 * s * s * s / 256) * f - (3 * s / 8 + 3 * s * s / 32 + 45 * s * s * s / 1024) * Math.sin(2 * f) + (15 * s * s / 256 + 45 * s * s * s / 1024) * Math.sin(4 * f) - 35 * s * s * s / 3072 * Math.sin(6 * f));
  var v = r * l * (u + (1 - c + h) * u * u * u / 6 + (5 - 18 * c + c * c + 72 * h - 58 * o) * u * u * u * u * u / 120) + 5e5, y = r * (d + l * Math.tan(f) * (u * u / 2 + (5 - c + 9 * h + 4 * h * h) * u * u * u * u / 24 + (61 - 58 * c + c * c + 600 * h - 330 * o) * u * u * u * u * u * u / 720));
  return e < 0 && (y += 1e7), {
    northing: Math.round(y),
    easting: Math.round(v),
    zoneNumber: p,
    zoneLetter: LI(e)
  };
}
function Xg(i) {
  var e = i.northing, t = i.easting, n = i.zoneLetter, s = i.zoneNumber;
  if (s < 0 || s > 60)
    return null;
  var r = 0.9996, a = 6378137, o = 669438e-8, l, c = (1 - Math.sqrt(1 - o)) / (1 + Math.sqrt(1 - o)), h, u, d, f, m, g, p, v, y, _ = t - 5e5, x = e;
  n < "N" && (x -= 1e7), p = (s - 1) * 6 - 180 + 3, l = o / (1 - o), g = x / r, v = g / (a * (1 - o / 4 - 3 * o * o / 64 - 5 * o * o * o / 256)), y = v + (3 * c / 2 - 27 * c * c * c / 32) * Math.sin(2 * v) + (21 * c * c / 16 - 55 * c * c * c * c / 32) * Math.sin(4 * v) + 151 * c * c * c / 96 * Math.sin(6 * v), h = a / Math.sqrt(1 - o * Math.sin(y) * Math.sin(y)), u = Math.tan(y) * Math.tan(y), d = l * Math.cos(y) * Math.cos(y), f = a * (1 - o) / Math.pow(1 - o * Math.sin(y) * Math.sin(y), 1.5), m = _ / (h * r);
  var M = y - h * Math.tan(y) / f * (m * m / 2 - (5 + 3 * u + 10 * d - 4 * d * d - 9 * l) * m * m * m * m / 24 + (61 + 90 * u + 298 * d + 45 * u * u - 252 * l - 3 * d * d) * m * m * m * m * m * m / 720);
  M = ny(M);
  var S = (m - (1 + 2 * u + d) * m * m * m / 6 + (5 - 2 * d + 28 * u - 3 * d * d + 8 * l + 24 * u * u) * m * m * m * m * m / 120) / Math.cos(y);
  S = p + ny(S);
  var w;
  if (i.accuracy) {
    var E = Xg({
      northing: i.northing + i.accuracy,
      easting: i.easting + i.accuracy,
      zoneLetter: i.zoneLetter,
      zoneNumber: i.zoneNumber
    });
    w = {
      top: E.lat,
      right: E.lon,
      bottom: M,
      left: S
    };
  } else
    w = {
      lat: M,
      lon: S
    };
  return w;
}
function LI(i) {
  var e = "Z";
  return 84 >= i && i >= 72 ? e = "X" : 72 > i && i >= 64 ? e = "W" : 64 > i && i >= 56 ? e = "V" : 56 > i && i >= 48 ? e = "U" : 48 > i && i >= 40 ? e = "T" : 40 > i && i >= 32 ? e = "S" : 32 > i && i >= 24 ? e = "R" : 24 > i && i >= 16 ? e = "Q" : 16 > i && i >= 8 ? e = "P" : 8 > i && i >= 0 ? e = "N" : 0 > i && i >= -8 ? e = "M" : -8 > i && i >= -16 ? e = "L" : -16 > i && i >= -24 ? e = "K" : -24 > i && i >= -32 ? e = "J" : -32 > i && i >= -40 ? e = "H" : -40 > i && i >= -48 ? e = "G" : -48 > i && i >= -56 ? e = "F" : -56 > i && i >= -64 ? e = "E" : -64 > i && i >= -72 ? e = "D" : -72 > i && i >= -80 && (e = "C"), e;
}
function II(i, e) {
  var t = "00000" + i.easting, n = "00000" + i.northing;
  return i.zoneNumber + i.zoneLetter + DI(i.easting, i.northing, i.zoneNumber) + t.substr(t.length - 5, e) + n.substr(n.length - 5, e);
}
function DI(i, e, t) {
  var n = Zb(t), s = Math.floor(i / 1e5), r = Math.floor(e / 1e5) % 20;
  return OI(s, r, n);
}
function Zb(i) {
  var e = i % ty;
  return e === 0 && (e = ty), e;
}
function OI(i, e, t) {
  var n = t - 1, s = Xb.charCodeAt(n), r = qb.charCodeAt(n), a = s + i - 1, o = r + e, l = !1;
  a > Ul && (a = a - Ul + So - 1, l = !0), (a === jn || s < jn && a > jn || (a > jn || s < jn) && l) && a++, (a === Ri || s < Ri && a > Ri || (a > Ri || s < Ri) && l) && (a++, a === jn && a++), a > Ul && (a = a - Ul + So - 1), o > Nl ? (o = o - Nl + So - 1, l = !0) : l = !1, (o === jn || r < jn && o > jn || (o > jn || r < jn) && l) && o++, (o === Ri || r < Ri && o > Ri || (o > Ri || r < Ri) && l) && (o++, o === jn && o++), o > Nl && (o = o - Nl + So - 1);
  var c = String.fromCharCode(a) + String.fromCharCode(o);
  return c;
}
function $b(i) {
  if (i && i.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var e = i.length, t = null, n = "", s, r = 0; !/[A-Z]/.test(s = i.charAt(r)); ) {
    if (r >= 2)
      throw "MGRSPoint bad conversion from: " + i;
    n += s, r++;
  }
  var a = parseInt(n, 10);
  if (r === 0 || r + 3 > e)
    throw "MGRSPoint bad conversion from: " + i;
  var o = i.charAt(r++);
  if (o <= "A" || o === "B" || o === "Y" || o >= "Z" || o === "I" || o === "O")
    throw "MGRSPoint zone letter " + o + " not handled: " + i;
  t = i.substring(r, r += 2);
  for (var l = Zb(a), c = NI(t.charAt(0), l), h = UI(t.charAt(1), l); h < FI(o); )
    h += 2e6;
  var u = e - r;
  if (u % 2 !== 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + i;
  var d = u / 2, f = 0, m = 0, g, p, v, y, _;
  return d > 0 && (g = 1e5 / Math.pow(10, d), p = i.substring(r, r + d), f = parseFloat(p) * g, v = i.substring(r + d), m = parseFloat(v) * g), y = f + c, _ = m + h, {
    easting: y,
    northing: _,
    zoneLetter: o,
    zoneNumber: a,
    accuracy: g
  };
}
function NI(i, e) {
  for (var t = Xb.charCodeAt(e - 1), n = 1e5, s = !1; t !== i.charCodeAt(0); ) {
    if (t++, t === jn && t++, t === Ri && t++, t > Ul) {
      if (s)
        throw "Bad character: " + i;
      t = So, s = !0;
    }
    n += 1e5;
  }
  return n;
}
function UI(i, e) {
  if (i > "V")
    throw "MGRSPoint given invalid Northing " + i;
  for (var t = qb.charCodeAt(e - 1), n = 0, s = !1; t !== i.charCodeAt(0); ) {
    if (t++, t === jn && t++, t === Ri && t++, t > Nl) {
      if (s)
        throw "Bad character: " + i;
      t = So, s = !0;
    }
    n += 1e5;
  }
  return n;
}
function FI(i) {
  var e;
  switch (i) {
    case "C":
      e = 11e5;
      break;
    case "D":
      e = 2e6;
      break;
    case "E":
      e = 28e5;
      break;
    case "F":
      e = 37e5;
      break;
    case "G":
      e = 46e5;
      break;
    case "H":
      e = 55e5;
      break;
    case "J":
      e = 64e5;
      break;
    case "K":
      e = 73e5;
      break;
    case "L":
      e = 82e5;
      break;
    case "M":
      e = 91e5;
      break;
    case "N":
      e = 0;
      break;
    case "P":
      e = 8e5;
      break;
    case "Q":
      e = 17e5;
      break;
    case "R":
      e = 26e5;
      break;
    case "S":
      e = 35e5;
      break;
    case "T":
      e = 44e5;
      break;
    case "U":
      e = 53e5;
      break;
    case "V":
      e = 62e5;
      break;
    case "W":
      e = 7e6;
      break;
    case "X":
      e = 79e5;
      break;
    default:
      e = -1;
  }
  if (e >= 0)
    return e;
  throw "Invalid zone letter: " + i;
}
function Jo(i, e, t) {
  if (!(this instanceof Jo))
    return new Jo(i, e, t);
  if (Array.isArray(i))
    this.x = i[0], this.y = i[1], this.z = i[2] || 0;
  else if (typeof i == "object")
    this.x = i.x, this.y = i.y, this.z = i.z || 0;
  else if (typeof i == "string" && typeof e > "u") {
    var n = i.split(",");
    this.x = parseFloat(n[0], 10), this.y = parseFloat(n[1], 10), this.z = parseFloat(n[2], 10) || 0;
  } else
    this.x = i, this.y = e, this.z = t || 0;
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Jo.fromMGRS = function(i) {
  return new Jo(jb(i));
};
Jo.prototype.toMGRS = function(i) {
  return Yb([this.x, this.y], i);
};
var BI = 1, kI = 0.25, iy = 0.046875, sy = 0.01953125, ry = 0.01068115234375, zI = 0.75, HI = 0.46875, GI = 0.013020833333333334, VI = 0.007120768229166667, WI = 0.3645833333333333, XI = 0.005696614583333333, qI = 0.3076171875;
function qg(i) {
  var e = [];
  e[0] = BI - i * (kI + i * (iy + i * (sy + i * ry))), e[1] = i * (zI - i * (iy + i * (sy + i * ry)));
  var t = i * i;
  return e[2] = t * (HI - i * (GI + i * VI)), t *= i, e[3] = t * (WI - i * XI), e[4] = t * i * qI, e;
}
function cl(i, e, t, n) {
  return t *= e, e *= e, n[0] * i - t * (n[1] + e * (n[2] + e * (n[3] + e * n[4])));
}
var YI = 20;
function Yg(i, e, t) {
  for (var n = 1 / (1 - e), s = i, r = YI; r; --r) {
    var a = Math.sin(s), o = 1 - e * a * a;
    if (o = (cl(s, a, Math.cos(s), t) - i) * (o * Math.sqrt(o)) * n, s -= o, Math.abs(o) < Se)
      return s;
  }
  return s;
}
function jI() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = qg(this.es), this.ml0 = cl(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}
function ZI(i) {
  var e = i.x, t = i.y, n = Te(e - this.long0), s, r, a, o = Math.sin(t), l = Math.cos(t);
  if (this.es) {
    var h = l * n, u = Math.pow(h, 2), d = this.ep2 * Math.pow(l, 2), f = Math.pow(d, 2), m = Math.abs(l) > Se ? Math.tan(t) : 0, g = Math.pow(m, 2), p = Math.pow(g, 2);
    s = 1 - this.es * Math.pow(o, 2), h = h / Math.sqrt(s);
    var v = cl(t, o, l, this.en);
    r = this.a * (this.k0 * h * (1 + u / 6 * (1 - g + d + u / 20 * (5 - 18 * g + p + 14 * d - 58 * g * d + u / 42 * (61 + 179 * p - p * g - 479 * g))))) + this.x0, a = this.a * (this.k0 * (v - this.ml0 + o * n * h / 2 * (1 + u / 12 * (5 - g + 9 * d + 4 * f + u / 30 * (61 + p - 58 * g + 270 * d - 330 * g * d + u / 56 * (1385 + 543 * p - p * g - 3111 * g)))))) + this.y0;
  } else {
    var c = l * Math.sin(n);
    if (Math.abs(Math.abs(c) - 1) < Se)
      return 93;
    if (r = 0.5 * this.a * this.k0 * Math.log((1 + c) / (1 - c)) + this.x0, a = l * Math.cos(n) / Math.sqrt(1 - Math.pow(c, 2)), c = Math.abs(a), c >= 1) {
      if (c - 1 > Se)
        return 93;
      a = 0;
    } else
      a = Math.acos(a);
    t < 0 && (a = -a), a = this.a * this.k0 * (a - this.lat0) + this.y0;
  }
  return i.x = r, i.y = a, i;
}
function $I(i) {
  var e, t, n, s, r = (i.x - this.x0) * (1 / this.a), a = (i.y - this.y0) * (1 / this.a);
  if (this.es)
    if (e = this.ml0 + a / this.k0, t = Yg(e, this.es, this.en), Math.abs(t) < re) {
      var u = Math.sin(t), d = Math.cos(t), f = Math.abs(d) > Se ? Math.tan(t) : 0, m = this.ep2 * Math.pow(d, 2), g = Math.pow(m, 2), p = Math.pow(f, 2), v = Math.pow(p, 2);
      e = 1 - this.es * Math.pow(u, 2);
      var y = r * Math.sqrt(e) / this.k0, _ = Math.pow(y, 2);
      e = e * f, n = t - e * _ / (1 - this.es) * 0.5 * (1 - _ / 12 * (5 + 3 * p - 9 * m * p + m - 4 * g - _ / 30 * (61 + 90 * p - 252 * m * p + 45 * v + 46 * m - _ / 56 * (1385 + 3633 * p + 4095 * v + 1574 * v * p)))), s = Te(this.long0 + y * (1 - _ / 6 * (1 + 2 * p + m - _ / 20 * (5 + 28 * p + 24 * v + 8 * m * p + 6 * m - _ / 42 * (61 + 662 * p + 1320 * v + 720 * v * p)))) / d);
    } else
      n = re * Zc(a), s = 0;
  else {
    var o = Math.exp(r / this.k0), l = 0.5 * (o - 1 / o), c = this.lat0 + a / this.k0, h = Math.cos(c);
    e = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(l, 2))), n = Math.asin(e), a < 0 && (n = -n), l === 0 && h === 0 ? s = 0 : s = Te(Math.atan2(l, h) + this.long0);
  }
  return i.x = s, i.y = n, i;
}
var KI = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const Su = {
  init: jI,
  forward: ZI,
  inverse: $I,
  names: KI
};
function Kb(i) {
  var e = Math.exp(i);
  return e = (e - 1 / e) / 2, e;
}
function Qn(i, e) {
  i = Math.abs(i), e = Math.abs(e);
  var t = Math.max(i, e), n = Math.min(i, e) / (t || 1);
  return t * Math.sqrt(1 + Math.pow(n, 2));
}
function QI(i) {
  var e = 1 + i, t = e - 1;
  return t === 0 ? i : i * Math.log(e) / t;
}
function JI(i) {
  var e = Math.abs(i);
  return e = QI(e * (1 + e / (Qn(1, e) + 1))), i < 0 ? -e : e;
}
function jg(i, e) {
  for (var t = 2 * Math.cos(2 * e), n = i.length - 1, s = i[n], r = 0, a; --n >= 0; )
    a = -r + t * s + i[n], r = s, s = a;
  return e + a * Math.sin(2 * e);
}
function eD(i, e) {
  for (var t = 2 * Math.cos(e), n = i.length - 1, s = i[n], r = 0, a; --n >= 0; )
    a = -r + t * s + i[n], r = s, s = a;
  return Math.sin(e) * a;
}
function tD(i) {
  var e = Math.exp(i);
  return e = (e + 1 / e) / 2, e;
}
function Qb(i, e, t) {
  for (var n = Math.sin(e), s = Math.cos(e), r = Kb(t), a = tD(t), o = 2 * s * a, l = -2 * n * r, c = i.length - 1, h = i[c], u = 0, d = 0, f = 0, m, g; --c >= 0; )
    m = d, g = u, d = h, u = f, h = -m + o * d - l * u + i[c], f = -g + l * d + o * u;
  return o = n * a, l = s * r, [o * h - l * f, o * f + l * h];
}
function nD() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (Su.init.apply(this), this.forward = Su.forward, this.inverse = Su.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var i = this.es / (1 + Math.sqrt(1 - this.es)), e = i / (2 - i), t = e;
  this.cgb[0] = e * (2 + e * (-2 / 3 + e * (-2 + e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675)))))), this.cbg[0] = e * (-2 + e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725)))))), t = t * e, this.cgb[1] = t * (7 / 3 + e * (-8 / 5 + e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))))), this.cbg[1] = t * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))), t = t * e, this.cgb[2] = t * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))), this.cbg[2] = t * (-26 / 15 + e * (34 / 21 + e * (8 / 5 + e * (-12686 / 2835)))), t = t * e, this.cgb[3] = t * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))), this.cbg[3] = t * (1237 / 630 + e * (-12 / 5 + e * (-24832 / 14175))), t = t * e, this.cgb[4] = t * (4174 / 315 + e * (-144838 / 6237)), this.cbg[4] = t * (-734 / 315 + e * (109598 / 31185)), t = t * e, this.cgb[5] = t * (601676 / 22275), this.cbg[5] = t * (444337 / 155925), t = Math.pow(e, 2), this.Qn = this.k0 / (1 + e) * (1 + t * (1 / 4 + t * (1 / 64 + t / 256))), this.utg[0] = e * (-0.5 + e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800)))))), this.gtu[0] = e * (0.5 + e * (-2 / 3 + e * (5 / 16 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))), this.utg[1] = t * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))), this.gtu[1] = t * (13 / 48 + e * (-3 / 5 + e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))))), t = t * e, this.utg[2] = t * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))), this.gtu[2] = t * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))), t = t * e, this.utg[3] = t * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))), this.gtu[3] = t * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))), t = t * e, this.utg[4] = t * (-4583 / 161280 + e * (108847 / 3991680)), this.gtu[4] = t * (34729 / 80640 + e * (-3418889 / 1995840)), t = t * e, this.utg[5] = t * (-20648693 / 638668800), this.gtu[5] = t * (212378941 / 319334400);
  var n = jg(this.cbg, this.lat0);
  this.Zb = -this.Qn * (n + eD(this.gtu, 2 * n));
}
function iD(i) {
  var e = Te(i.x - this.long0), t = i.y;
  t = jg(this.cbg, t);
  var n = Math.sin(t), s = Math.cos(t), r = Math.sin(e), a = Math.cos(e);
  t = Math.atan2(n, a * s), e = Math.atan2(r * s, Qn(n, s * a)), e = JI(Math.tan(e));
  var o = Qb(this.gtu, 2 * t, 2 * e);
  t = t + o[0], e = e + o[1];
  var l, c;
  return Math.abs(e) <= 2.623395162778 ? (l = this.a * (this.Qn * e) + this.x0, c = this.a * (this.Qn * t + this.Zb) + this.y0) : (l = 1 / 0, c = 1 / 0), i.x = l, i.y = c, i;
}
function sD(i) {
  var e = (i.x - this.x0) * (1 / this.a), t = (i.y - this.y0) * (1 / this.a);
  t = (t - this.Zb) / this.Qn, e = e / this.Qn;
  var n, s;
  if (Math.abs(e) <= 2.623395162778) {
    var r = Qb(this.utg, 2 * t, 2 * e);
    t = t + r[0], e = e + r[1], e = Math.atan(Kb(e));
    var a = Math.sin(t), o = Math.cos(t), l = Math.sin(e), c = Math.cos(e);
    t = Math.atan2(a * c, Qn(l, c * o)), e = Math.atan2(l, c * o), n = Te(e + this.long0), s = jg(this.cgb, t);
  } else
    n = 1 / 0, s = 1 / 0;
  return i.x = n, i.y = s, i;
}
var rD = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
const wu = {
  init: nD,
  forward: iD,
  inverse: sD,
  names: rD
};
function aD(i, e) {
  if (i === void 0) {
    if (i = Math.floor((Te(e) + Math.PI) * 30 / Math.PI) + 1, i < 0)
      return 0;
    if (i > 60)
      return 60;
  }
  return i;
}
var oD = "etmerc";
function lD() {
  var i = aD(this.zone, this.long0);
  if (i === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(i) - 183) * Mn, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, wu.init.apply(this), this.forward = wu.forward, this.inverse = wu.inverse;
}
var cD = ["Universal Transverse Mercator System", "utm"];
const hD = {
  init: lD,
  names: cD,
  dependsOn: oD
};
function Zg(i, e) {
  return Math.pow((1 - i) / (1 + i), e);
}
var uD = 20;
function dD() {
  var i = Math.sin(this.lat0), e = Math.cos(this.lat0);
  e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * i * i), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(i / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + _t) / (Math.pow(Math.tan(0.5 * this.lat0 + _t), this.C) * Zg(this.e * i, this.ratexp));
}
function fD(i) {
  var e = i.x, t = i.y;
  return i.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * t + _t), this.C) * Zg(this.e * Math.sin(t), this.ratexp)) - re, i.x = this.C * e, i;
}
function pD(i) {
  for (var e = 1e-14, t = i.x / this.C, n = i.y, s = Math.pow(Math.tan(0.5 * n + _t) / this.K, 1 / this.C), r = uD; r > 0 && (n = 2 * Math.atan(s * Zg(this.e * Math.sin(i.y), -0.5 * this.e)) - re, !(Math.abs(n - i.y) < e)); --r)
    i.y = n;
  return r ? (i.x = t, i.y = n, i) : null;
}
const $g = {
  init: dD,
  forward: fD,
  inverse: pD
};
function mD() {
  $g.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}
function gD(i) {
  var e, t, n, s;
  return i.x = Te(i.x - this.long0), $g.forward.apply(this, [i]), e = Math.sin(i.y), t = Math.cos(i.y), n = Math.cos(i.x), s = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * t * n), i.x = s * t * Math.sin(i.x), i.y = s * (this.cosc0 * e - this.sinc0 * t * n), i.x = this.a * i.x + this.x0, i.y = this.a * i.y + this.y0, i;
}
function vD(i) {
  var e, t, n, s, r;
  if (i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, i.x /= this.k0, i.y /= this.k0, r = Qn(i.x, i.y)) {
    var a = 2 * Math.atan2(r, this.R2);
    e = Math.sin(a), t = Math.cos(a), s = Math.asin(t * this.sinc0 + i.y * e * this.cosc0 / r), n = Math.atan2(i.x * e, r * this.cosc0 * t - i.y * this.sinc0 * e);
  } else
    s = this.phic0, n = 0;
  return i.x = n, i.y = s, $g.inverse.apply(this, [i]), i.x = Te(i.x + this.long0), i;
}
var _D = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const yD = {
  init: mD,
  forward: gD,
  inverse: vD,
  names: _D
};
function xD(i, e, t) {
  return e *= t, Math.tan(0.5 * (re + i)) * Math.pow((1 - e) / (1 + e), 0.5 * t);
}
function MD() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Se && (this.k0 = 0.5 * (1 + Zc(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= Se && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Se && Math.abs(Math.cos(this.lat_ts)) > Se && (this.k0 = 0.5 * this.cons * Ms(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Vi(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = Ms(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - re, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}
function bD(i) {
  var e = i.x, t = i.y, n = Math.sin(t), s = Math.cos(t), r, a, o, l, c, h, u = Te(e - this.long0);
  return Math.abs(Math.abs(e - this.long0) - Math.PI) <= Se && Math.abs(t + this.lat0) <= Se ? (i.x = NaN, i.y = NaN, i) : this.sphere ? (r = 2 * this.k0 / (1 + this.sinlat0 * n + this.coslat0 * s * Math.cos(u)), i.x = this.a * r * s * Math.sin(u) + this.x0, i.y = this.a * r * (this.coslat0 * n - this.sinlat0 * s * Math.cos(u)) + this.y0, i) : (a = 2 * Math.atan(this.ssfn_(t, n, this.e)) - re, l = Math.cos(a), o = Math.sin(a), Math.abs(this.coslat0) <= Se ? (c = Vi(this.e, t * this.con, this.con * n), h = 2 * this.a * this.k0 * c / this.cons, i.x = this.x0 + h * Math.sin(e - this.long0), i.y = this.y0 - this.con * h * Math.cos(e - this.long0), i) : (Math.abs(this.sinlat0) < Se ? (r = 2 * this.a * this.k0 / (1 + l * Math.cos(u)), i.y = r * o) : (r = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * o + this.cosX0 * l * Math.cos(u))), i.y = r * (this.cosX0 * o - this.sinX0 * l * Math.cos(u)) + this.y0), i.x = r * l * Math.sin(u) + this.x0, i));
}
function SD(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e, t, n, s, r, a = Math.sqrt(i.x * i.x + i.y * i.y);
  if (this.sphere) {
    var o = 2 * Math.atan(a / (2 * this.a * this.k0));
    return e = this.long0, t = this.lat0, a <= Se ? (i.x = e, i.y = t, i) : (t = Math.asin(Math.cos(o) * this.sinlat0 + i.y * Math.sin(o) * this.coslat0 / a), Math.abs(this.coslat0) < Se ? this.lat0 > 0 ? e = Te(this.long0 + Math.atan2(i.x, -1 * i.y)) : e = Te(this.long0 + Math.atan2(i.x, i.y)) : e = Te(this.long0 + Math.atan2(i.x * Math.sin(o), a * this.coslat0 * Math.cos(o) - i.y * this.sinlat0 * Math.sin(o))), i.x = e, i.y = t, i);
  } else if (Math.abs(this.coslat0) <= Se) {
    if (a <= Se)
      return t = this.lat0, e = this.long0, i.x = e, i.y = t, i;
    i.x *= this.con, i.y *= this.con, n = a * this.cons / (2 * this.a * this.k0), t = this.con * Ec(this.e, n), e = this.con * Te(this.con * this.long0 + Math.atan2(i.x, -1 * i.y));
  } else
    s = 2 * Math.atan(a * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, a <= Se ? r = this.X0 : (r = Math.asin(Math.cos(s) * this.sinX0 + i.y * Math.sin(s) * this.cosX0 / a), e = Te(this.long0 + Math.atan2(i.x * Math.sin(s), a * this.cosX0 * Math.cos(s) - i.y * this.sinX0 * Math.sin(s)))), t = -1 * Ec(this.e, Math.tan(0.5 * (re + r)));
  return i.x = e, i.y = t, i;
}
var wD = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"];
const TD = {
  init: MD,
  forward: bD,
  inverse: SD,
  names: wD,
  ssfn_: xD
};
function ED() {
  var i = this.lat0;
  this.lambda0 = this.long0;
  var e = Math.sin(i), t = this.a, n = this.rf, s = 1 / n, r = 2 * s - Math.pow(s, 2), a = this.e = Math.sqrt(r);
  this.R = this.k0 * t * Math.sqrt(1 - r) / (1 - r * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + r / (1 - r) * Math.pow(Math.cos(i), 4)), this.b0 = Math.asin(e / this.alpha);
  var o = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), l = Math.log(Math.tan(Math.PI / 4 + i / 2)), c = Math.log((1 + a * e) / (1 - a * e));
  this.K = o - this.alpha * l + this.alpha * a / 2 * c;
}
function AD(i) {
  var e = Math.log(Math.tan(Math.PI / 4 - i.y / 2)), t = this.e / 2 * Math.log((1 + this.e * Math.sin(i.y)) / (1 - this.e * Math.sin(i.y))), n = -this.alpha * (e + t) + this.K, s = 2 * (Math.atan(Math.exp(n)) - Math.PI / 4), r = this.alpha * (i.x - this.lambda0), a = Math.atan(Math.sin(r) / (Math.sin(this.b0) * Math.tan(s) + Math.cos(this.b0) * Math.cos(r))), o = Math.asin(Math.cos(this.b0) * Math.sin(s) - Math.sin(this.b0) * Math.cos(s) * Math.cos(r));
  return i.y = this.R / 2 * Math.log((1 + Math.sin(o)) / (1 - Math.sin(o))) + this.y0, i.x = this.R * a + this.x0, i;
}
function CD(i) {
  for (var e = i.x - this.x0, t = i.y - this.y0, n = e / this.R, s = 2 * (Math.atan(Math.exp(t / this.R)) - Math.PI / 4), r = Math.asin(Math.cos(this.b0) * Math.sin(s) + Math.sin(this.b0) * Math.cos(s) * Math.cos(n)), a = Math.atan(Math.sin(n) / (Math.cos(this.b0) * Math.cos(n) - Math.sin(this.b0) * Math.tan(s))), o = this.lambda0 + a / this.alpha, l = 0, c = r, h = -1e3, u = 0; Math.abs(c - h) > 1e-7; ) {
    if (++u > 20)
      return;
    l = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + r / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(c)) / 2)), h = c, c = 2 * Math.atan(Math.exp(l)) - Math.PI / 2;
  }
  return i.x = o, i.y = c, i;
}
var RD = ["somerc"];
const PD = {
  init: ED,
  forward: AD,
  inverse: CD,
  names: RD
};
var fo = 1e-7;
function LD(i) {
  var e = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], t = typeof i.PROJECTION == "object" ? Object.keys(i.PROJECTION)[0] : i.PROJECTION;
  return "no_uoff" in i || "no_off" in i || e.indexOf(t) !== -1;
}
function ID() {
  var i, e, t, n, s, r, a, o, l, c, h = 0, u, d = 0, f = 0, m = 0, g = 0, p = 0, v = 0;
  this.no_off = LD(this), this.no_rot = "no_rot" in this;
  var y = !1;
  "alpha" in this && (y = !0);
  var _ = !1;
  if ("rectified_grid_angle" in this && (_ = !0), y && (v = this.alpha), _ && (h = this.rectified_grid_angle * Mn), y || _)
    d = this.longc;
  else if (f = this.long1, g = this.lat1, m = this.long2, p = this.lat2, Math.abs(g - p) <= fo || (i = Math.abs(g)) <= fo || Math.abs(i - re) <= fo || Math.abs(Math.abs(this.lat0) - re) <= fo || Math.abs(Math.abs(p) - re) <= fo)
    throw new Error();
  var x = 1 - this.es;
  e = Math.sqrt(x), Math.abs(this.lat0) > Se ? (o = Math.sin(this.lat0), t = Math.cos(this.lat0), i = 1 - this.es * o * o, this.B = t * t, this.B = Math.sqrt(1 + this.es * this.B * this.B / x), this.A = this.B * this.k0 * e / i, n = this.B * e / (t * Math.sqrt(i)), s = n * n - 1, s <= 0 ? s = 0 : (s = Math.sqrt(s), this.lat0 < 0 && (s = -s)), this.E = s += n, this.E *= Math.pow(Vi(this.e, this.lat0, o), this.B)) : (this.B = 1 / e, this.A = this.k0, this.E = n = s = 1), y || _ ? (y ? (u = Math.asin(Math.sin(v) / n), _ || (h = v)) : (u = h, v = Math.asin(n * Math.sin(u))), this.lam0 = d - Math.asin(0.5 * (s - 1 / s) * Math.tan(u)) / this.B) : (r = Math.pow(Vi(this.e, g, Math.sin(g)), this.B), a = Math.pow(Vi(this.e, p, Math.sin(p)), this.B), s = this.E / r, l = (a - r) / (a + r), c = this.E * this.E, c = (c - a * r) / (c + a * r), i = f - m, i < -Math.pi ? m -= wc : i > Math.pi && (m += wc), this.lam0 = Te(0.5 * (f + m) - Math.atan(c * Math.tan(0.5 * this.B * (f - m)) / l) / this.B), u = Math.atan(2 * Math.sin(this.B * Te(f - this.lam0)) / (s - 1 / s)), h = v = Math.asin(n * Math.sin(u))), this.singam = Math.sin(u), this.cosgam = Math.cos(u), this.sinrot = Math.sin(h), this.cosrot = Math.cos(h), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(n * n - 1) / Math.cos(v))), this.lat0 < 0 && (this.u_0 = -this.u_0)), s = 0.5 * u, this.v_pole_n = this.ArB * Math.log(Math.tan(_t - s)), this.v_pole_s = this.ArB * Math.log(Math.tan(_t + s));
}
function DD(i) {
  var e = {}, t, n, s, r, a, o, l, c;
  if (i.x = i.x - this.lam0, Math.abs(Math.abs(i.y) - re) > Se) {
    if (a = this.E / Math.pow(Vi(this.e, i.y, Math.sin(i.y)), this.B), o = 1 / a, t = 0.5 * (a - o), n = 0.5 * (a + o), r = Math.sin(this.B * i.x), s = (t * this.singam - r * this.cosgam) / n, Math.abs(Math.abs(s) - 1) < Se)
      throw new Error();
    c = 0.5 * this.ArB * Math.log((1 - s) / (1 + s)), o = Math.cos(this.B * i.x), Math.abs(o) < fo ? l = this.A * i.x : l = this.ArB * Math.atan2(t * this.cosgam + r * this.singam, o);
  } else
    c = i.y > 0 ? this.v_pole_n : this.v_pole_s, l = this.ArB * i.y;
  return this.no_rot ? (e.x = l, e.y = c) : (l -= this.u_0, e.x = c * this.cosrot + l * this.sinrot, e.y = l * this.cosrot - c * this.sinrot), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e;
}
function OD(i) {
  var e, t, n, s, r, a, o, l = {};
  if (i.x = (i.x - this.x0) * (1 / this.a), i.y = (i.y - this.y0) * (1 / this.a), this.no_rot ? (t = i.y, e = i.x) : (t = i.x * this.cosrot - i.y * this.sinrot, e = i.y * this.cosrot + i.x * this.sinrot + this.u_0), n = Math.exp(-this.BrA * t), s = 0.5 * (n - 1 / n), r = 0.5 * (n + 1 / n), a = Math.sin(this.BrA * e), o = (a * this.cosgam + s * this.singam) / r, Math.abs(Math.abs(o) - 1) < Se)
    l.x = 0, l.y = o < 0 ? -re : re;
  else {
    if (l.y = this.E / Math.sqrt((1 + o) / (1 - o)), l.y = Ec(this.e, Math.pow(l.y, 1 / this.B)), l.y === 1 / 0)
      throw new Error();
    l.x = -this.rB * Math.atan2(s * this.cosgam - a * this.singam, Math.cos(this.BrA * e));
  }
  return l.x += this.lam0, l;
}
var ND = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const UD = {
  init: ID,
  forward: DD,
  inverse: OD,
  names: ND
};
function FD() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < Se)) {
    var i = this.b / this.a;
    this.e = Math.sqrt(1 - i * i);
    var e = Math.sin(this.lat1), t = Math.cos(this.lat1), n = Ms(this.e, e, t), s = Vi(this.e, this.lat1, e), r = Math.sin(this.lat2), a = Math.cos(this.lat2), o = Ms(this.e, r, a), l = Vi(this.e, this.lat2, r), c = Vi(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > Se ? this.ns = Math.log(n / o) / Math.log(s / l) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = n / (this.ns * Math.pow(s, this.ns)), this.rh = this.a * this.f0 * Math.pow(c, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}
function BD(i) {
  var e = i.x, t = i.y;
  Math.abs(2 * Math.abs(t) - Math.PI) <= Se && (t = Zc(t) * (re - 2 * Se));
  var n = Math.abs(Math.abs(t) - re), s, r;
  if (n > Se)
    s = Vi(this.e, t, Math.sin(t)), r = this.a * this.f0 * Math.pow(s, this.ns);
  else {
    if (n = t * this.ns, n <= 0)
      return null;
    r = 0;
  }
  var a = this.ns * Te(e - this.long0);
  return i.x = this.k0 * (r * Math.sin(a)) + this.x0, i.y = this.k0 * (this.rh - r * Math.cos(a)) + this.y0, i;
}
function kD(i) {
  var e, t, n, s, r, a = (i.x - this.x0) / this.k0, o = this.rh - (i.y - this.y0) / this.k0;
  this.ns > 0 ? (e = Math.sqrt(a * a + o * o), t = 1) : (e = -Math.sqrt(a * a + o * o), t = -1);
  var l = 0;
  if (e !== 0 && (l = Math.atan2(t * a, t * o)), e !== 0 || this.ns > 0) {
    if (t = 1 / this.ns, n = Math.pow(e / (this.a * this.f0), t), s = Ec(this.e, n), s === -9999)
      return null;
  } else
    s = -re;
  return r = Te(l / this.ns + this.long0), i.x = r, i.y = s, i;
}
var zD = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const HD = {
  init: FD,
  forward: BD,
  inverse: kD,
  names: zD
};
function GD() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}
function VD(i) {
  var e, t, n, s, r, a, o, l = i.x, c = i.y, h = Te(l - this.long0);
  return e = Math.pow((1 + this.e * Math.sin(c)) / (1 - this.e * Math.sin(c)), this.alfa * this.e / 2), t = 2 * (Math.atan(this.k * Math.pow(Math.tan(c / 2 + this.s45), this.alfa) / e) - this.s45), n = -h * this.alfa, s = Math.asin(Math.cos(this.ad) * Math.sin(t) + Math.sin(this.ad) * Math.cos(t) * Math.cos(n)), r = Math.asin(Math.cos(t) * Math.sin(n) / Math.cos(s)), a = this.n * r, o = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n), i.y = o * Math.cos(a) / 1, i.x = o * Math.sin(a) / 1, this.czech || (i.y *= -1, i.x *= -1), i;
}
function WD(i) {
  var e, t, n, s, r, a, o, l, c = i.x;
  i.x = i.y, i.y = c, this.czech || (i.y *= -1, i.x *= -1), a = Math.sqrt(i.x * i.x + i.y * i.y), r = Math.atan2(i.y, i.x), s = r / Math.sin(this.s0), n = 2 * (Math.atan(Math.pow(this.ro0 / a, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(n) - Math.sin(this.ad) * Math.cos(n) * Math.cos(s)), t = Math.asin(Math.cos(n) * Math.sin(s) / Math.cos(e)), i.x = this.long0 - t / this.alfa, o = e, l = 0;
  var h = 0;
  do
    i.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(o)) / (1 - this.e * Math.sin(o)), this.e / 2)) - this.s45), Math.abs(o - i.y) < 1e-10 && (l = 1), o = i.y, h += 1;
  while (l === 0 && h < 15);
  return h >= 15 ? null : i;
}
var XD = ["Krovak", "krovak"];
const qD = {
  init: GD,
  forward: VD,
  inverse: WD,
  names: XD
};
function Vn(i, e, t, n, s) {
  return i * s - e * Math.sin(2 * s) + t * Math.sin(4 * s) - n * Math.sin(6 * s);
}
function $c(i) {
  return 1 - 0.25 * i * (1 + i / 16 * (3 + 1.25 * i));
}
function Kc(i) {
  return 0.375 * i * (1 + 0.25 * i * (1 + 0.46875 * i));
}
function Qc(i) {
  return 0.05859375 * i * i * (1 + 0.75 * i);
}
function Jc(i) {
  return i * i * i * (35 / 3072);
}
function el(i, e, t) {
  var n = e * t;
  return i / Math.sqrt(1 - n * n);
}
function zr(i) {
  return Math.abs(i) < re ? i : i - Zc(i) * Math.PI;
}
function Xu(i, e, t, n, s) {
  var r, a;
  r = i / e;
  for (var o = 0; o < 15; o++)
    if (a = (i - (e * r - t * Math.sin(2 * r) + n * Math.sin(4 * r) - s * Math.sin(6 * r))) / (e - 2 * t * Math.cos(2 * r) + 4 * n * Math.cos(4 * r) - 6 * s * Math.cos(6 * r)), r += a, Math.abs(a) <= 1e-10)
      return r;
  return NaN;
}
function YD() {
  this.sphere || (this.e0 = $c(this.es), this.e1 = Kc(this.es), this.e2 = Qc(this.es), this.e3 = Jc(this.es), this.ml0 = this.a * Vn(this.e0, this.e1, this.e2, this.e3, this.lat0));
}
function jD(i) {
  var e, t, n = i.x, s = i.y;
  if (n = Te(n - this.long0), this.sphere)
    e = this.a * Math.asin(Math.cos(s) * Math.sin(n)), t = this.a * (Math.atan2(Math.tan(s), Math.cos(n)) - this.lat0);
  else {
    var r = Math.sin(s), a = Math.cos(s), o = el(this.a, this.e, r), l = Math.tan(s) * Math.tan(s), c = n * Math.cos(s), h = c * c, u = this.es * a * a / (1 - this.es), d = this.a * Vn(this.e0, this.e1, this.e2, this.e3, s);
    e = o * c * (1 - h * l * (1 / 6 - (8 - l + 8 * u) * h / 120)), t = d - this.ml0 + o * r / a * h * (0.5 + (5 - l + 6 * u) * h / 24);
  }
  return i.x = e + this.x0, i.y = t + this.y0, i;
}
function ZD(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e = i.x / this.a, t = i.y / this.a, n, s;
  if (this.sphere) {
    var r = t + this.lat0;
    n = Math.asin(Math.sin(r) * Math.cos(e)), s = Math.atan2(Math.tan(e), Math.cos(r));
  } else {
    var a = this.ml0 / this.a + t, o = Xu(a, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(o) - re) <= Se)
      return i.x = this.long0, i.y = re, t < 0 && (i.y *= -1), i;
    var l = el(this.a, this.e, Math.sin(o)), c = l * l * l / this.a / this.a * (1 - this.es), h = Math.pow(Math.tan(o), 2), u = e * this.a / l, d = u * u;
    n = o - l * Math.tan(o) / c * u * u * (0.5 - (1 + 3 * h) * u * u / 24), s = u * (1 - d * (h / 3 + (1 + 3 * h) * h * d / 15)) / Math.cos(o);
  }
  return i.x = Te(s + this.long0), i.y = zr(n), i;
}
var $D = ["Cassini", "Cassini_Soldner", "cass"];
const KD = {
  init: YD,
  forward: jD,
  inverse: ZD,
  names: $D
};
function br(i, e) {
  var t;
  return i > 1e-7 ? (t = i * e, (1 - i * i) * (e / (1 - t * t) - 0.5 / i * Math.log((1 - t) / (1 + t)))) : 2 * e;
}
var QD = 1, JD = 2, eO = 3, tO = 4;
function nO() {
  var i = Math.abs(this.lat0);
  if (Math.abs(i - re) < Se ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(i) < Se ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
    var e;
    switch (this.qp = br(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = uO(this.es), this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp), e = Math.sin(this.lat0), this.sinb1 = br(this.e, e) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * e * e) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
        break;
    }
  } else
    this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}
function iO(i) {
  var e, t, n, s, r, a, o, l, c, h, u = i.x, d = i.y;
  if (u = Te(u - this.long0), this.sphere) {
    if (r = Math.sin(d), h = Math.cos(d), n = Math.cos(u), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (t = this.mode === this.EQUIT ? 1 + h * n : 1 + this.sinph0 * r + this.cosph0 * h * n, t <= Se)
        return null;
      t = Math.sqrt(2 / t), e = t * h * Math.sin(u), t *= this.mode === this.EQUIT ? r : this.cosph0 * r - this.sinph0 * h * n;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (n = -n), Math.abs(d + this.lat0) < Se)
        return null;
      t = _t - d * 0.5, t = 2 * (this.mode === this.S_POLE ? Math.cos(t) : Math.sin(t)), e = t * Math.sin(u), t *= n;
    }
  } else {
    switch (o = 0, l = 0, c = 0, n = Math.cos(u), s = Math.sin(u), r = Math.sin(d), a = br(this.e, r), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (o = a / this.qp, l = Math.sqrt(1 - o * o)), this.mode) {
      case this.OBLIQ:
        c = 1 + this.sinb1 * o + this.cosb1 * l * n;
        break;
      case this.EQUIT:
        c = 1 + l * n;
        break;
      case this.N_POLE:
        c = re + d, a = this.qp - a;
        break;
      case this.S_POLE:
        c = d - re, a = this.qp + a;
        break;
    }
    if (Math.abs(c) < Se)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        c = Math.sqrt(2 / c), this.mode === this.OBLIQ ? t = this.ymf * c * (this.cosb1 * o - this.sinb1 * l * n) : t = (c = Math.sqrt(2 / (1 + l * n))) * o * this.ymf, e = this.xmf * c * l * s;
        break;
      case this.N_POLE:
      case this.S_POLE:
        a >= 0 ? (e = (c = Math.sqrt(a)) * s, t = n * (this.mode === this.S_POLE ? c : -c)) : e = t = 0;
        break;
    }
  }
  return i.x = this.a * e + this.x0, i.y = this.a * t + this.y0, i;
}
function sO(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e = i.x / this.a, t = i.y / this.a, n, s, r, a, o, l, c;
  if (this.sphere) {
    var h = 0, u, d = 0;
    if (u = Math.sqrt(e * e + t * t), s = u * 0.5, s > 1)
      return null;
    switch (s = 2 * Math.asin(s), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (d = Math.sin(s), h = Math.cos(s)), this.mode) {
      case this.EQUIT:
        s = Math.abs(u) <= Se ? 0 : Math.asin(t * d / u), e *= d, t = h * u;
        break;
      case this.OBLIQ:
        s = Math.abs(u) <= Se ? this.lat0 : Math.asin(h * this.sinph0 + t * d * this.cosph0 / u), e *= d * this.cosph0, t = (h - Math.sin(s) * this.sinph0) * u;
        break;
      case this.N_POLE:
        t = -t, s = re - s;
        break;
      case this.S_POLE:
        s -= re;
        break;
    }
    n = t === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(e, t);
  } else {
    if (c = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (e /= this.dd, t *= this.dd, l = Math.sqrt(e * e + t * t), l < Se)
        return i.x = this.long0, i.y = this.lat0, i;
      a = 2 * Math.asin(0.5 * l / this.rq), r = Math.cos(a), e *= a = Math.sin(a), this.mode === this.OBLIQ ? (c = r * this.sinb1 + t * a * this.cosb1 / l, o = this.qp * c, t = l * this.cosb1 * r - t * this.sinb1 * a) : (c = t * a / l, o = this.qp * c, t = l * r);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (t = -t), o = e * e + t * t, !o)
        return i.x = this.long0, i.y = this.lat0, i;
      c = 1 - o / this.qp, this.mode === this.S_POLE && (c = -c);
    }
    n = Math.atan2(e, t), s = dO(Math.asin(c), this.apa);
  }
  return i.x = Te(this.long0 + n), i.y = s, i;
}
var rO = 0.3333333333333333, aO = 0.17222222222222222, oO = 0.10257936507936508, lO = 0.06388888888888888, cO = 0.0664021164021164, hO = 0.016415012942191543;
function uO(i) {
  var e, t = [];
  return t[0] = i * rO, e = i * i, t[0] += e * aO, t[1] = e * lO, e *= i, t[0] += e * oO, t[1] += e * cO, t[2] = e * hO, t;
}
function dO(i, e) {
  var t = i + i;
  return i + e[0] * Math.sin(t) + e[1] * Math.sin(t + t) + e[2] * Math.sin(t + t + t);
}
var fO = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const pO = {
  init: nO,
  forward: iO,
  inverse: sO,
  names: fO,
  S_POLE: QD,
  N_POLE: JD,
  EQUIT: eO,
  OBLIQ: tO
};
function Or(i) {
  return Math.abs(i) > 1 && (i = i > 1 ? 1 : -1), Math.asin(i);
}
function mO() {
  Math.abs(this.lat1 + this.lat2) < Se || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = Ms(this.e3, this.sin_po, this.cos_po), this.qs1 = br(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = Ms(this.e3, this.sin_po, this.cos_po), this.qs2 = br(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = br(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > Se ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}
function gO(i) {
  var e = i.x, t = i.y;
  this.sin_phi = Math.sin(t), this.cos_phi = Math.cos(t);
  var n = br(this.e3, this.sin_phi), s = this.a * Math.sqrt(this.c - this.ns0 * n) / this.ns0, r = this.ns0 * Te(e - this.long0), a = s * Math.sin(r) + this.x0, o = this.rh - s * Math.cos(r) + this.y0;
  return i.x = a, i.y = o, i;
}
function vO(i) {
  var e, t, n, s, r, a;
  return i.x -= this.x0, i.y = this.rh - i.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(i.x * i.x + i.y * i.y), n = 1) : (e = -Math.sqrt(i.x * i.x + i.y * i.y), n = -1), s = 0, e !== 0 && (s = Math.atan2(n * i.x, n * i.y)), n = e * this.ns0 / this.a, this.sphere ? a = Math.asin((this.c - n * n) / (2 * this.ns0)) : (t = (this.c - n * n) / this.ns0, a = this.phi1z(this.e3, t)), r = Te(s / this.ns0 + this.long0), i.x = r, i.y = a, i;
}
function _O(i, e) {
  var t, n, s, r, a, o = Or(0.5 * e);
  if (i < Se)
    return o;
  for (var l = i * i, c = 1; c <= 25; c++)
    if (t = Math.sin(o), n = Math.cos(o), s = i * t, r = 1 - s * s, a = 0.5 * r * r / n * (e / (1 - l) - t / r + 0.5 / i * Math.log((1 - s) / (1 + s))), o = o + a, Math.abs(a) <= 1e-7)
      return o;
  return null;
}
var yO = ["Albers_Conic_Equal_Area", "Albers", "aea"];
const xO = {
  init: mO,
  forward: gO,
  inverse: vO,
  names: yO,
  phi1z: _O
};
function MO() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}
function bO(i) {
  var e, t, n, s, r, a, o, l, c = i.x, h = i.y;
  return n = Te(c - this.long0), e = Math.sin(h), t = Math.cos(h), s = Math.cos(n), a = this.sin_p14 * e + this.cos_p14 * t * s, r = 1, a > 0 || Math.abs(a) <= Se ? (o = this.x0 + this.a * r * t * Math.sin(n) / a, l = this.y0 + this.a * r * (this.cos_p14 * e - this.sin_p14 * t * s) / a) : (o = this.x0 + this.infinity_dist * t * Math.sin(n), l = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * t * s)), i.x = o, i.y = l, i;
}
function SO(i) {
  var e, t, n, s, r, a;
  return i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, i.x /= this.k0, i.y /= this.k0, (e = Math.sqrt(i.x * i.x + i.y * i.y)) ? (s = Math.atan2(e, this.rc), t = Math.sin(s), n = Math.cos(s), a = Or(n * this.sin_p14 + i.y * t * this.cos_p14 / e), r = Math.atan2(i.x * t, e * this.cos_p14 * n - i.y * this.sin_p14 * t), r = Te(this.long0 + r)) : (a = this.phic0, r = 0), i.x = r, i.y = a, i;
}
var wO = ["gnom"];
const TO = {
  init: MO,
  forward: bO,
  inverse: SO,
  names: wO
};
function EO(i, e) {
  var t = 1 - (1 - i * i) / (2 * i) * Math.log((1 - i) / (1 + i));
  if (Math.abs(Math.abs(e) - t) < 1e-6)
    return e < 0 ? -1 * re : re;
  for (var n = Math.asin(0.5 * e), s, r, a, o, l = 0; l < 30; l++)
    if (r = Math.sin(n), a = Math.cos(n), o = i * r, s = Math.pow(1 - o * o, 2) / (2 * a) * (e / (1 - i * i) - r / (1 - o * o) + 0.5 / i * Math.log((1 - o) / (1 + o))), n += s, Math.abs(s) <= 1e-10)
      return n;
  return NaN;
}
function AO() {
  this.sphere || (this.k0 = Ms(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}
function CO(i) {
  var e = i.x, t = i.y, n, s, r = Te(e - this.long0);
  if (this.sphere)
    n = this.x0 + this.a * r * Math.cos(this.lat_ts), s = this.y0 + this.a * Math.sin(t) / Math.cos(this.lat_ts);
  else {
    var a = br(this.e, Math.sin(t));
    n = this.x0 + this.a * this.k0 * r, s = this.y0 + this.a * a * 0.5 / this.k0;
  }
  return i.x = n, i.y = s, i;
}
function RO(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e, t;
  return this.sphere ? (e = Te(this.long0 + i.x / this.a / Math.cos(this.lat_ts)), t = Math.asin(i.y / this.a * Math.cos(this.lat_ts))) : (t = EO(this.e, 2 * i.y * this.k0 / this.a), e = Te(this.long0 + i.x / (this.a * this.k0))), i.x = e, i.y = t, i;
}
var PO = ["cea"];
const LO = {
  init: AO,
  forward: CO,
  inverse: RO,
  names: PO
};
function IO() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}
function DO(i) {
  var e = i.x, t = i.y, n = Te(e - this.long0), s = zr(t - this.lat0);
  return i.x = this.x0 + this.a * n * this.rc, i.y = this.y0 + this.a * s, i;
}
function OO(i) {
  var e = i.x, t = i.y;
  return i.x = Te(this.long0 + (e - this.x0) / (this.a * this.rc)), i.y = zr(this.lat0 + (t - this.y0) / this.a), i;
}
var NO = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
const UO = {
  init: IO,
  forward: DO,
  inverse: OO,
  names: NO
};
var ay = 20;
function FO() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = $c(this.es), this.e1 = Kc(this.es), this.e2 = Qc(this.es), this.e3 = Jc(this.es), this.ml0 = this.a * Vn(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function BO(i) {
  var e = i.x, t = i.y, n, s, r, a = Te(e - this.long0);
  if (r = a * Math.sin(t), this.sphere)
    Math.abs(t) <= Se ? (n = this.a * a, s = -1 * this.a * this.lat0) : (n = this.a * Math.sin(r) / Math.tan(t), s = this.a * (zr(t - this.lat0) + (1 - Math.cos(r)) / Math.tan(t)));
  else if (Math.abs(t) <= Se)
    n = this.a * a, s = -1 * this.ml0;
  else {
    var o = el(this.a, this.e, Math.sin(t)) / Math.tan(t);
    n = o * Math.sin(r), s = this.a * Vn(this.e0, this.e1, this.e2, this.e3, t) - this.ml0 + o * (1 - Math.cos(r));
  }
  return i.x = n + this.x0, i.y = s + this.y0, i;
}
function kO(i) {
  var e, t, n, s, r, a, o, l, c;
  if (n = i.x - this.x0, s = i.y - this.y0, this.sphere)
    if (Math.abs(s + this.a * this.lat0) <= Se)
      e = Te(n / this.a + this.long0), t = 0;
    else {
      a = this.lat0 + s / this.a, o = n * n / this.a / this.a + a * a, l = a;
      var h;
      for (r = ay; r; --r)
        if (h = Math.tan(l), c = -1 * (a * (l * h + 1) - l - 0.5 * (l * l + o) * h) / ((l - a) / h - 1), l += c, Math.abs(c) <= Se) {
          t = l;
          break;
        }
      e = Te(this.long0 + Math.asin(n * Math.tan(l) / this.a) / Math.sin(t));
    }
  else if (Math.abs(s + this.ml0) <= Se)
    t = 0, e = Te(this.long0 + n / this.a);
  else {
    a = (this.ml0 + s) / this.a, o = n * n / this.a / this.a + a * a, l = a;
    var u, d, f, m, g;
    for (r = ay; r; --r)
      if (g = this.e * Math.sin(l), u = Math.sqrt(1 - g * g) * Math.tan(l), d = this.a * Vn(this.e0, this.e1, this.e2, this.e3, l), f = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), m = d / this.a, c = (a * (u * m + 1) - m - 0.5 * u * (m * m + o)) / (this.es * Math.sin(2 * l) * (m * m + o - 2 * a * m) / (4 * u) + (a - m) * (u * f - 2 / Math.sin(2 * l)) - f), l -= c, Math.abs(c) <= Se) {
        t = l;
        break;
      }
    u = Math.sqrt(1 - this.es * Math.pow(Math.sin(t), 2)) * Math.tan(t), e = Te(this.long0 + Math.asin(n * u / this.a) / Math.sin(t));
  }
  return i.x = e, i.y = t, i;
}
var zO = ["Polyconic", "poly"];
const HO = {
  init: FO,
  forward: BO,
  inverse: kO,
  names: zO
};
function GO() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}
function VO(i) {
  var e, t = i.x, n = i.y, s = n - this.lat0, r = t - this.long0, a = s / jl * 1e-5, o = r, l = 1, c = 0;
  for (e = 1; e <= 10; e++)
    l = l * a, c = c + this.A[e] * l;
  var h = c, u = o, d = 1, f = 0, m, g, p = 0, v = 0;
  for (e = 1; e <= 6; e++)
    m = d * h - f * u, g = f * h + d * u, d = m, f = g, p = p + this.B_re[e] * d - this.B_im[e] * f, v = v + this.B_im[e] * d + this.B_re[e] * f;
  return i.x = v * this.a + this.x0, i.y = p * this.a + this.y0, i;
}
function WO(i) {
  var e, t = i.x, n = i.y, s = t - this.x0, r = n - this.y0, a = r / this.a, o = s / this.a, l = 1, c = 0, h, u, d = 0, f = 0;
  for (e = 1; e <= 6; e++)
    h = l * a - c * o, u = c * a + l * o, l = h, c = u, d = d + this.C_re[e] * l - this.C_im[e] * c, f = f + this.C_im[e] * l + this.C_re[e] * c;
  for (var m = 0; m < this.iterations; m++) {
    var g = d, p = f, v, y, _ = a, x = o;
    for (e = 2; e <= 6; e++)
      v = g * d - p * f, y = p * d + g * f, g = v, p = y, _ = _ + (e - 1) * (this.B_re[e] * g - this.B_im[e] * p), x = x + (e - 1) * (this.B_im[e] * g + this.B_re[e] * p);
    g = 1, p = 0;
    var M = this.B_re[1], S = this.B_im[1];
    for (e = 2; e <= 6; e++)
      v = g * d - p * f, y = p * d + g * f, g = v, p = y, M = M + e * (this.B_re[e] * g - this.B_im[e] * p), S = S + e * (this.B_im[e] * g + this.B_re[e] * p);
    var w = M * M + S * S;
    d = (_ * M + x * S) / w, f = (x * M - _ * S) / w;
  }
  var E = d, b = f, A = 1, D = 0;
  for (e = 1; e <= 9; e++)
    A = A * E, D = D + this.D[e] * A;
  var B = this.lat0 + D * jl * 1e5, X = this.long0 + b;
  return i.x = X, i.y = B, i;
}
var XO = ["New_Zealand_Map_Grid", "nzmg"];
const qO = {
  init: GO,
  forward: VO,
  inverse: WO,
  names: XO
};
function YO() {
}
function jO(i) {
  var e = i.x, t = i.y, n = Te(e - this.long0), s = this.x0 + this.a * n, r = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + t / 2.5)) * 1.25;
  return i.x = s, i.y = r, i;
}
function ZO(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e = Te(this.long0 + i.x / this.a), t = 2.5 * (Math.atan(Math.exp(0.8 * i.y / this.a)) - Math.PI / 4);
  return i.x = e, i.y = t, i;
}
var $O = ["Miller_Cylindrical", "mill"];
const KO = {
  init: YO,
  forward: jO,
  inverse: ZO,
  names: $O
};
var QO = 20;
function JO() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = qg(this.es);
}
function eN(i) {
  var e, t, n = i.x, s = i.y;
  if (n = Te(n - this.long0), this.sphere) {
    if (!this.m)
      s = this.n !== 1 ? Math.asin(this.n * Math.sin(s)) : s;
    else
      for (var r = this.n * Math.sin(s), a = QO; a; --a) {
        var o = (this.m * s + Math.sin(s) - r) / (this.m + Math.cos(s));
        if (s -= o, Math.abs(o) < Se)
          break;
      }
    e = this.a * this.C_x * n * (this.m + Math.cos(s)), t = this.a * this.C_y * s;
  } else {
    var l = Math.sin(s), c = Math.cos(s);
    t = this.a * cl(s, l, c, this.en), e = this.a * n * c / Math.sqrt(1 - this.es * l * l);
  }
  return i.x = e, i.y = t, i;
}
function tN(i) {
  var e, t, n, s;
  return i.x -= this.x0, n = i.x / this.a, i.y -= this.y0, e = i.y / this.a, this.sphere ? (e /= this.C_y, n = n / (this.C_x * (this.m + Math.cos(e))), this.m ? e = Or((this.m * e + Math.sin(e)) / this.n) : this.n !== 1 && (e = Or(Math.sin(e) / this.n)), n = Te(n + this.long0), e = zr(e)) : (e = Yg(i.y / this.a, this.es, this.en), s = Math.abs(e), s < re ? (s = Math.sin(e), t = this.long0 + i.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(e)), n = Te(t)) : s - Se < re && (n = this.long0)), i.x = n, i.y = e, i;
}
var nN = ["Sinusoidal", "sinu"];
const iN = {
  init: JO,
  forward: eN,
  inverse: tN,
  names: nN
};
function sN() {
}
function rN(i) {
  for (var e = i.x, t = i.y, n = Te(e - this.long0), s = t, r = Math.PI * Math.sin(t); ; ) {
    var a = -(s + Math.sin(s) - r) / (1 + Math.cos(s));
    if (s += a, Math.abs(a) < Se)
      break;
  }
  s /= 2, Math.PI / 2 - Math.abs(t) < Se && (n = 0);
  var o = 0.900316316158 * this.a * n * Math.cos(s) + this.x0, l = 1.4142135623731 * this.a * Math.sin(s) + this.y0;
  return i.x = o, i.y = l, i;
}
function aN(i) {
  var e, t;
  i.x -= this.x0, i.y -= this.y0, t = i.y / (1.4142135623731 * this.a), Math.abs(t) > 0.999999999999 && (t = 0.999999999999), e = Math.asin(t);
  var n = Te(this.long0 + i.x / (0.900316316158 * this.a * Math.cos(e)));
  n < -Math.PI && (n = -Math.PI), n > Math.PI && (n = Math.PI), t = (2 * e + Math.sin(2 * e)) / Math.PI, Math.abs(t) > 1 && (t = 1);
  var s = Math.asin(t);
  return i.x = n, i.y = s, i;
}
var oN = ["Mollweide", "moll"];
const lN = {
  init: sN,
  forward: rN,
  inverse: aN,
  names: oN
};
function cN() {
  Math.abs(this.lat1 + this.lat2) < Se || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = $c(this.es), this.e1 = Kc(this.es), this.e2 = Qc(this.es), this.e3 = Jc(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = Ms(this.e, this.sinphi, this.cosphi), this.ml1 = Vn(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < Se ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = Ms(this.e, this.sinphi, this.cosphi), this.ml2 = Vn(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = Vn(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}
function hN(i) {
  var e = i.x, t = i.y, n;
  if (this.sphere)
    n = this.a * (this.g - t);
  else {
    var s = Vn(this.e0, this.e1, this.e2, this.e3, t);
    n = this.a * (this.g - s);
  }
  var r = this.ns * Te(e - this.long0), a = this.x0 + n * Math.sin(r), o = this.y0 + this.rh - n * Math.cos(r);
  return i.x = a, i.y = o, i;
}
function uN(i) {
  i.x -= this.x0, i.y = this.rh - i.y + this.y0;
  var e, t, n, s;
  this.ns >= 0 ? (t = Math.sqrt(i.x * i.x + i.y * i.y), e = 1) : (t = -Math.sqrt(i.x * i.x + i.y * i.y), e = -1);
  var r = 0;
  if (t !== 0 && (r = Math.atan2(e * i.x, e * i.y)), this.sphere)
    return s = Te(this.long0 + r / this.ns), n = zr(this.g - t / this.a), i.x = s, i.y = n, i;
  var a = this.g - t / this.a;
  return n = Xu(a, this.e0, this.e1, this.e2, this.e3), s = Te(this.long0 + r / this.ns), i.x = s, i.y = n, i;
}
var dN = ["Equidistant_Conic", "eqdc"];
const fN = {
  init: cN,
  forward: hN,
  inverse: uN,
  names: dN
};
function pN() {
  this.R = this.a;
}
function mN(i) {
  var e = i.x, t = i.y, n = Te(e - this.long0), s, r;
  Math.abs(t) <= Se && (s = this.x0 + this.R * n, r = this.y0);
  var a = Or(2 * Math.abs(t / Math.PI));
  (Math.abs(n) <= Se || Math.abs(Math.abs(t) - re) <= Se) && (s = this.x0, t >= 0 ? r = this.y0 + Math.PI * this.R * Math.tan(0.5 * a) : r = this.y0 + Math.PI * this.R * -Math.tan(0.5 * a));
  var o = 0.5 * Math.abs(Math.PI / n - n / Math.PI), l = o * o, c = Math.sin(a), h = Math.cos(a), u = h / (c + h - 1), d = u * u, f = u * (2 / c - 1), m = f * f, g = Math.PI * this.R * (o * (u - m) + Math.sqrt(l * (u - m) * (u - m) - (m + l) * (d - m))) / (m + l);
  n < 0 && (g = -g), s = this.x0 + g;
  var p = l + u;
  return g = Math.PI * this.R * (f * p - o * Math.sqrt((m + l) * (l + 1) - p * p)) / (m + l), t >= 0 ? r = this.y0 + g : r = this.y0 - g, i.x = s, i.y = r, i;
}
function gN(i) {
  var e, t, n, s, r, a, o, l, c, h, u, d, f;
  return i.x -= this.x0, i.y -= this.y0, u = Math.PI * this.R, n = i.x / u, s = i.y / u, r = n * n + s * s, a = -Math.abs(s) * (1 + r), o = a - 2 * s * s + n * n, l = -2 * a + 1 + 2 * s * s + r * r, f = s * s / l + (2 * o * o * o / l / l / l - 9 * a * o / l / l) / 27, c = (a - o * o / 3 / l) / l, h = 2 * Math.sqrt(-c / 3), u = 3 * f / c / h, Math.abs(u) > 1 && (u >= 0 ? u = 1 : u = -1), d = Math.acos(u) / 3, i.y >= 0 ? t = (-h * Math.cos(d + Math.PI / 3) - o / 3 / l) * Math.PI : t = -(-h * Math.cos(d + Math.PI / 3) - o / 3 / l) * Math.PI, Math.abs(n) < Se ? e = this.long0 : e = Te(this.long0 + Math.PI * (r - 1 + Math.sqrt(1 + 2 * (n * n - s * s) + r * r)) / 2 / n), i.x = e, i.y = t, i;
}
var vN = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
const _N = {
  init: pN,
  forward: mN,
  inverse: gN,
  names: vN
};
function yN() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
}
function xN(i) {
  var e = i.x, t = i.y, n = Math.sin(i.y), s = Math.cos(i.y), r = Te(e - this.long0), a, o, l, c, h, u, d, f, m, g, p, v, y, _, x, M, S, w, E, b, A, D, B;
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= Se ? (i.x = this.x0 + this.a * (re - t) * Math.sin(r), i.y = this.y0 - this.a * (re - t) * Math.cos(r), i) : Math.abs(this.sin_p12 + 1) <= Se ? (i.x = this.x0 + this.a * (re + t) * Math.sin(r), i.y = this.y0 + this.a * (re + t) * Math.cos(r), i) : (w = this.sin_p12 * n + this.cos_p12 * s * Math.cos(r), M = Math.acos(w), S = M ? M / Math.sin(M) : 1, i.x = this.x0 + this.a * S * s * Math.sin(r), i.y = this.y0 + this.a * S * (this.cos_p12 * n - this.sin_p12 * s * Math.cos(r)), i) : (a = $c(this.es), o = Kc(this.es), l = Qc(this.es), c = Jc(this.es), Math.abs(this.sin_p12 - 1) <= Se ? (h = this.a * Vn(a, o, l, c, re), u = this.a * Vn(a, o, l, c, t), i.x = this.x0 + (h - u) * Math.sin(r), i.y = this.y0 - (h - u) * Math.cos(r), i) : Math.abs(this.sin_p12 + 1) <= Se ? (h = this.a * Vn(a, o, l, c, re), u = this.a * Vn(a, o, l, c, t), i.x = this.x0 + (h + u) * Math.sin(r), i.y = this.y0 + (h + u) * Math.cos(r), i) : (d = n / s, f = el(this.a, this.e, this.sin_p12), m = el(this.a, this.e, n), g = Math.atan((1 - this.es) * d + this.es * f * this.sin_p12 / (m * s)), p = Math.atan2(Math.sin(r), this.cos_p12 * Math.tan(g) - this.sin_p12 * Math.cos(r)), p === 0 ? E = Math.asin(this.cos_p12 * Math.sin(g) - this.sin_p12 * Math.cos(g)) : Math.abs(Math.abs(p) - Math.PI) <= Se ? E = -Math.asin(this.cos_p12 * Math.sin(g) - this.sin_p12 * Math.cos(g)) : E = Math.asin(Math.sin(r) * Math.cos(g) / Math.sin(p)), v = this.e * this.sin_p12 / Math.sqrt(1 - this.es), y = this.e * this.cos_p12 * Math.cos(p) / Math.sqrt(1 - this.es), _ = v * y, x = y * y, b = E * E, A = b * E, D = A * E, B = D * E, M = f * E * (1 - b * x * (1 - x) / 6 + A / 8 * _ * (1 - 2 * x) + D / 120 * (x * (4 - 7 * x) - 3 * v * v * (1 - 7 * x)) - B / 48 * _), i.x = this.x0 + M * Math.sin(p), i.y = this.y0 + M * Math.cos(p), i));
}
function MN(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e, t, n, s, r, a, o, l, c, h, u, d, f, m, g, p, v, y, _, x, M, S, w, E;
  return this.sphere ? (e = Math.sqrt(i.x * i.x + i.y * i.y), e > 2 * re * this.a ? void 0 : (t = e / this.a, n = Math.sin(t), s = Math.cos(t), r = this.long0, Math.abs(e) <= Se ? a = this.lat0 : (a = Or(s * this.sin_p12 + i.y * n * this.cos_p12 / e), o = Math.abs(this.lat0) - re, Math.abs(o) <= Se ? this.lat0 >= 0 ? r = Te(this.long0 + Math.atan2(i.x, -i.y)) : r = Te(this.long0 - Math.atan2(-i.x, i.y)) : r = Te(this.long0 + Math.atan2(i.x * n, e * this.cos_p12 * s - i.y * this.sin_p12 * n))), i.x = r, i.y = a, i)) : (l = $c(this.es), c = Kc(this.es), h = Qc(this.es), u = Jc(this.es), Math.abs(this.sin_p12 - 1) <= Se ? (d = this.a * Vn(l, c, h, u, re), e = Math.sqrt(i.x * i.x + i.y * i.y), f = d - e, a = Xu(f / this.a, l, c, h, u), r = Te(this.long0 + Math.atan2(i.x, -1 * i.y)), i.x = r, i.y = a, i) : Math.abs(this.sin_p12 + 1) <= Se ? (d = this.a * Vn(l, c, h, u, re), e = Math.sqrt(i.x * i.x + i.y * i.y), f = e - d, a = Xu(f / this.a, l, c, h, u), r = Te(this.long0 + Math.atan2(i.x, i.y)), i.x = r, i.y = a, i) : (e = Math.sqrt(i.x * i.x + i.y * i.y), p = Math.atan2(i.x, i.y), m = el(this.a, this.e, this.sin_p12), v = Math.cos(p), y = this.e * this.cos_p12 * v, _ = -y * y / (1 - this.es), x = 3 * this.es * (1 - _) * this.sin_p12 * this.cos_p12 * v / (1 - this.es), M = e / m, S = M - _ * (1 + _) * Math.pow(M, 3) / 6 - x * (1 + 3 * _) * Math.pow(M, 4) / 24, w = 1 - _ * S * S / 2 - M * S * S * S / 6, g = Math.asin(this.sin_p12 * Math.cos(S) + this.cos_p12 * Math.sin(S) * v), r = Te(this.long0 + Math.asin(Math.sin(p) * Math.sin(S) / Math.cos(g))), E = Math.sin(g), a = Math.atan2((E - this.es * w * this.sin_p12) * Math.tan(g), E * (1 - this.es)), i.x = r, i.y = a, i));
}
var bN = ["Azimuthal_Equidistant", "aeqd"];
const SN = {
  init: yN,
  forward: xN,
  inverse: MN,
  names: bN
};
function wN() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}
function TN(i) {
  var e, t, n, s, r, a, o, l, c = i.x, h = i.y;
  return n = Te(c - this.long0), e = Math.sin(h), t = Math.cos(h), s = Math.cos(n), a = this.sin_p14 * e + this.cos_p14 * t * s, r = 1, (a > 0 || Math.abs(a) <= Se) && (o = this.a * r * t * Math.sin(n), l = this.y0 + this.a * r * (this.cos_p14 * e - this.sin_p14 * t * s)), i.x = o, i.y = l, i;
}
function EN(i) {
  var e, t, n, s, r, a, o;
  return i.x -= this.x0, i.y -= this.y0, e = Math.sqrt(i.x * i.x + i.y * i.y), t = Or(e / this.a), n = Math.sin(t), s = Math.cos(t), a = this.long0, Math.abs(e) <= Se ? (o = this.lat0, i.x = a, i.y = o, i) : (o = Or(s * this.sin_p14 + i.y * n * this.cos_p14 / e), r = Math.abs(this.lat0) - re, Math.abs(r) <= Se ? (this.lat0 >= 0 ? a = Te(this.long0 + Math.atan2(i.x, -i.y)) : a = Te(this.long0 - Math.atan2(-i.x, i.y)), i.x = a, i.y = o, i) : (a = Te(this.long0 + Math.atan2(i.x * n, e * this.cos_p14 * s - i.y * this.sin_p14 * n)), i.x = a, i.y = o, i));
}
var AN = ["ortho"];
const CN = {
  init: wN,
  forward: TN,
  inverse: EN,
  names: AN
};
var Dt = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
}, yt = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function RN() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= re - _t / 2 ? this.face = Dt.TOP : this.lat0 <= -(re - _t / 2) ? this.face = Dt.BOTTOM : Math.abs(this.long0) <= _t ? this.face = Dt.FRONT : Math.abs(this.long0) <= re + _t ? this.face = this.long0 > 0 ? Dt.RIGHT : Dt.LEFT : this.face = Dt.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}
function PN(i) {
  var e = { x: 0, y: 0 }, t, n, s, r, a, o, l = { value: 0 };
  if (i.x -= this.long0, this.es !== 0 ? t = Math.atan(this.one_minus_f_squared * Math.tan(i.y)) : t = i.y, n = i.x, this.face === Dt.TOP)
    r = re - t, n >= _t && n <= re + _t ? (l.value = yt.AREA_0, s = n - re) : n > re + _t || n <= -(re + _t) ? (l.value = yt.AREA_1, s = n > 0 ? n - Sn : n + Sn) : n > -(re + _t) && n <= -_t ? (l.value = yt.AREA_2, s = n + re) : (l.value = yt.AREA_3, s = n);
  else if (this.face === Dt.BOTTOM)
    r = re + t, n >= _t && n <= re + _t ? (l.value = yt.AREA_0, s = -n + re) : n < _t && n >= -_t ? (l.value = yt.AREA_1, s = -n) : n < -_t && n >= -(re + _t) ? (l.value = yt.AREA_2, s = -n - re) : (l.value = yt.AREA_3, s = n > 0 ? -n + Sn : -n - Sn);
  else {
    var c, h, u, d, f, m, g;
    this.face === Dt.RIGHT ? n = Oo(n, +re) : this.face === Dt.BACK ? n = Oo(n, 3.14159265359) : this.face === Dt.LEFT && (n = Oo(n, -re)), d = Math.sin(t), f = Math.cos(t), m = Math.sin(n), g = Math.cos(n), c = f * g, h = f * m, u = d, this.face === Dt.FRONT ? (r = Math.acos(c), s = ou(r, u, h, l)) : this.face === Dt.RIGHT ? (r = Math.acos(h), s = ou(r, u, -c, l)) : this.face === Dt.BACK ? (r = Math.acos(-c), s = ou(r, u, -h, l)) : this.face === Dt.LEFT ? (r = Math.acos(-h), s = ou(r, u, c, l)) : (r = s = 0, l.value = yt.AREA_0);
  }
  return o = Math.atan(12 / Sn * (s + Math.acos(Math.sin(s) * Math.cos(_t)) - re)), a = Math.sqrt((1 - Math.cos(r)) / (Math.cos(o) * Math.cos(o)) / (1 - Math.cos(Math.atan(1 / Math.cos(s))))), l.value === yt.AREA_1 ? o += re : l.value === yt.AREA_2 ? o += Sn : l.value === yt.AREA_3 && (o += 1.5 * Sn), e.x = a * Math.cos(o), e.y = a * Math.sin(o), e.x = e.x * this.a + this.x0, e.y = e.y * this.a + this.y0, i.x = e.x, i.y = e.y, i;
}
function LN(i) {
  var e = { lam: 0, phi: 0 }, t, n, s, r, a, o, l, c, h, u = { value: 0 };
  if (i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, n = Math.atan(Math.sqrt(i.x * i.x + i.y * i.y)), t = Math.atan2(i.y, i.x), i.x >= 0 && i.x >= Math.abs(i.y) ? u.value = yt.AREA_0 : i.y >= 0 && i.y >= Math.abs(i.x) ? (u.value = yt.AREA_1, t -= re) : i.x < 0 && -i.x >= Math.abs(i.y) ? (u.value = yt.AREA_2, t = t < 0 ? t + Sn : t - Sn) : (u.value = yt.AREA_3, t += re), h = Sn / 12 * Math.tan(t), a = Math.sin(h) / (Math.cos(h) - 1 / Math.sqrt(2)), o = Math.atan(a), s = Math.cos(t), r = Math.tan(n), l = 1 - s * s * r * r * (1 - Math.cos(Math.atan(1 / Math.cos(o)))), l < -1 ? l = -1 : l > 1 && (l = 1), this.face === Dt.TOP)
    c = Math.acos(l), e.phi = re - c, u.value === yt.AREA_0 ? e.lam = o + re : u.value === yt.AREA_1 ? e.lam = o < 0 ? o + Sn : o - Sn : u.value === yt.AREA_2 ? e.lam = o - re : e.lam = o;
  else if (this.face === Dt.BOTTOM)
    c = Math.acos(l), e.phi = c - re, u.value === yt.AREA_0 ? e.lam = -o + re : u.value === yt.AREA_1 ? e.lam = -o : u.value === yt.AREA_2 ? e.lam = -o - re : e.lam = o < 0 ? -o - Sn : -o + Sn;
  else {
    var d, f, m;
    d = l, h = d * d, h >= 1 ? m = 0 : m = Math.sqrt(1 - h) * Math.sin(o), h += m * m, h >= 1 ? f = 0 : f = Math.sqrt(1 - h), u.value === yt.AREA_1 ? (h = f, f = -m, m = h) : u.value === yt.AREA_2 ? (f = -f, m = -m) : u.value === yt.AREA_3 && (h = f, f = m, m = -h), this.face === Dt.RIGHT ? (h = d, d = -f, f = h) : this.face === Dt.BACK ? (d = -d, f = -f) : this.face === Dt.LEFT && (h = d, d = f, f = -h), e.phi = Math.acos(-m) - re, e.lam = Math.atan2(f, d), this.face === Dt.RIGHT ? e.lam = Oo(e.lam, -re) : this.face === Dt.BACK ? e.lam = Oo(e.lam, -3.14159265359) : this.face === Dt.LEFT && (e.lam = Oo(e.lam, +re));
  }
  if (this.es !== 0) {
    var g, p, v;
    g = e.phi < 0 ? 1 : 0, p = Math.tan(e.phi), v = this.b / Math.sqrt(p * p + this.one_minus_f_squared), e.phi = Math.atan(Math.sqrt(this.a * this.a - v * v) / (this.one_minus_f * v)), g && (e.phi = -e.phi);
  }
  return e.lam += this.long0, i.x = e.lam, i.y = e.phi, i;
}
function ou(i, e, t, n) {
  var s;
  return i < Se ? (n.value = yt.AREA_0, s = 0) : (s = Math.atan2(e, t), Math.abs(s) <= _t ? n.value = yt.AREA_0 : s > _t && s <= re + _t ? (n.value = yt.AREA_1, s -= re) : s > re + _t || s <= -(re + _t) ? (n.value = yt.AREA_2, s = s >= 0 ? s - Sn : s + Sn) : (n.value = yt.AREA_3, s += re)), s;
}
function Oo(i, e) {
  var t = i + e;
  return t < -3.14159265359 ? t += wc : t > 3.14159265359 && (t -= wc), t;
}
var IN = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const DN = {
  init: RN,
  forward: PN,
  inverse: LN,
  names: IN
};
var fm = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
], Fl = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
], Jb = 0.8487, e1 = 1.3523, t1 = fs / 5, ON = 1 / t1, wo = 18, qu = function(i, e) {
  return i[0] + e * (i[1] + e * (i[2] + e * i[3]));
}, NN = function(i, e) {
  return i[1] + e * (2 * i[2] + e * 3 * i[3]);
};
function UN(i, e, t, n) {
  for (var s = e; n; --n) {
    var r = i(s);
    if (s -= r, Math.abs(r) < t)
      break;
  }
  return s;
}
function FN() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}
function BN(i) {
  var e = Te(i.x - this.long0), t = Math.abs(i.y), n = Math.floor(t * t1);
  n < 0 ? n = 0 : n >= wo && (n = wo - 1), t = fs * (t - ON * n);
  var s = {
    x: qu(fm[n], t) * e,
    y: qu(Fl[n], t)
  };
  return i.y < 0 && (s.y = -s.y), s.x = s.x * this.a * Jb + this.x0, s.y = s.y * this.a * e1 + this.y0, s;
}
function kN(i) {
  var e = {
    x: (i.x - this.x0) / (this.a * Jb),
    y: Math.abs(i.y - this.y0) / (this.a * e1)
  };
  if (e.y >= 1)
    e.x /= fm[wo][0], e.y = i.y < 0 ? -re : re;
  else {
    var t = Math.floor(e.y * wo);
    for (t < 0 ? t = 0 : t >= wo && (t = wo - 1); ; )
      if (Fl[t][0] > e.y)
        --t;
      else if (Fl[t + 1][0] <= e.y)
        ++t;
      else
        break;
    var n = Fl[t], s = 5 * (e.y - n[0]) / (Fl[t + 1][0] - n[0]);
    s = UN(function(r) {
      return (qu(n, r) - e.y) / NN(n, r);
    }, s, Se, 100), e.x /= qu(fm[t], s), e.y = (5 * t + s) * Mn, i.y < 0 && (e.y = -e.y);
  }
  return e.x = Te(e.x + this.long0), e;
}
var zN = ["Robinson", "robin"];
const HN = {
  init: FN,
  forward: BN,
  inverse: kN,
  names: zN
};
function GN() {
  this.name = "geocent";
}
function VN(i) {
  var e = Gb(i, this.es, this.a);
  return e;
}
function WN(i) {
  var e = Vb(i, this.es, this.a, this.b);
  return e;
}
var XN = ["Geocentric", "geocentric", "geocent", "Geocent"];
const qN = {
  init: GN,
  forward: VN,
  inverse: WN,
  names: XN
};
var Pn = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
}, El = {
  h: { def: 1e5, num: !0 },
  // default is Karman line, no default in PROJ.7
  azi: { def: 0, num: !0, degrees: !0 },
  // default is North
  tilt: { def: 0, num: !0, degrees: !0 },
  // default is Nadir
  long0: { def: 0, num: !0 },
  // default is Greenwich, conversion to rad is automatic
  lat0: { def: 0, num: !0 }
  // default is Equator, conversion to rad is automatic
};
function YN() {
  if (Object.keys(El).forEach((function(t) {
    if (typeof this[t] > "u")
      this[t] = El[t].def;
    else {
      if (El[t].num && isNaN(this[t]))
        throw new Error("Invalid parameter value, must be numeric " + t + " = " + this[t]);
      El[t].num && (this[t] = parseFloat(this[t]));
    }
    El[t].degrees && (this[t] = this[t] * Mn);
  }).bind(this)), Math.abs(Math.abs(this.lat0) - re) < Se ? this.mode = this.lat0 < 0 ? Pn.S_POLE : Pn.N_POLE : Math.abs(this.lat0) < Se ? this.mode = Pn.EQUIT : (this.mode = Pn.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var i = this.tilt, e = this.azi;
  this.cg = Math.cos(e), this.sg = Math.sin(e), this.cw = Math.cos(i), this.sw = Math.sin(i);
}
function jN(i) {
  i.x -= this.long0;
  var e = Math.sin(i.y), t = Math.cos(i.y), n = Math.cos(i.x), s, r;
  switch (this.mode) {
    case Pn.OBLIQ:
      r = this.sinph0 * e + this.cosph0 * t * n;
      break;
    case Pn.EQUIT:
      r = t * n;
      break;
    case Pn.S_POLE:
      r = -e;
      break;
    case Pn.N_POLE:
      r = e;
      break;
  }
  switch (r = this.pn1 / (this.p - r), s = r * t * Math.sin(i.x), this.mode) {
    case Pn.OBLIQ:
      r *= this.cosph0 * e - this.sinph0 * t * n;
      break;
    case Pn.EQUIT:
      r *= e;
      break;
    case Pn.N_POLE:
      r *= -(t * n);
      break;
    case Pn.S_POLE:
      r *= t * n;
      break;
  }
  var a, o;
  return a = r * this.cg + s * this.sg, o = 1 / (a * this.sw * this.h1 + this.cw), s = (s * this.cg - r * this.sg) * this.cw * o, r = a * o, i.x = s * this.a, i.y = r * this.a, i;
}
function ZN(i) {
  i.x /= this.a, i.y /= this.a;
  var e = { x: i.x, y: i.y }, t, n, s;
  s = 1 / (this.pn1 - i.y * this.sw), t = this.pn1 * i.x * s, n = this.pn1 * i.y * this.cw * s, i.x = t * this.cg + n * this.sg, i.y = n * this.cg - t * this.sg;
  var r = Qn(i.x, i.y);
  if (Math.abs(r) < Se)
    e.x = 0, e.y = i.y;
  else {
    var a, o;
    switch (o = 1 - r * r * this.pfact, o = (this.p - Math.sqrt(o)) / (this.pn1 / r + r / this.pn1), a = Math.sqrt(1 - o * o), this.mode) {
      case Pn.OBLIQ:
        e.y = Math.asin(a * this.sinph0 + i.y * o * this.cosph0 / r), i.y = (a - this.sinph0 * Math.sin(e.y)) * r, i.x *= o * this.cosph0;
        break;
      case Pn.EQUIT:
        e.y = Math.asin(i.y * o / r), i.y = a * r, i.x *= o;
        break;
      case Pn.N_POLE:
        e.y = Math.asin(a), i.y = -i.y;
        break;
      case Pn.S_POLE:
        e.y = -Math.asin(a);
        break;
    }
    e.x = Math.atan2(i.x, i.y);
  }
  return i.x = e.x + this.long0, i.y = e.y, i;
}
var $N = ["Tilted_Perspective", "tpers"];
const KN = {
  init: YN,
  forward: jN,
  inverse: ZN,
  names: $N
};
function QN() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var i = 1 - this.es, e = 1 / i;
    this.radius_p = Math.sqrt(i), this.radius_p2 = i, this.radius_p_inv2 = e, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}
function JN(i) {
  var e = i.x, t = i.y, n, s, r, a;
  if (e = e - this.long0, this.shape === "ellipse") {
    t = Math.atan(this.radius_p2 * Math.tan(t));
    var o = this.radius_p / Qn(this.radius_p * Math.cos(t), Math.sin(t));
    if (s = o * Math.cos(e) * Math.cos(t), r = o * Math.sin(e) * Math.cos(t), a = o * Math.sin(t), (this.radius_g - s) * s - r * r - a * a * this.radius_p_inv2 < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    n = this.radius_g - s, this.flip_axis ? (i.x = this.radius_g_1 * Math.atan(r / Qn(a, n)), i.y = this.radius_g_1 * Math.atan(a / n)) : (i.x = this.radius_g_1 * Math.atan(r / n), i.y = this.radius_g_1 * Math.atan(a / Qn(r, n)));
  } else this.shape === "sphere" && (n = Math.cos(t), s = Math.cos(e) * n, r = Math.sin(e) * n, a = Math.sin(t), n = this.radius_g - s, this.flip_axis ? (i.x = this.radius_g_1 * Math.atan(r / Qn(a, n)), i.y = this.radius_g_1 * Math.atan(a / n)) : (i.x = this.radius_g_1 * Math.atan(r / n), i.y = this.radius_g_1 * Math.atan(a / Qn(r, n))));
  return i.x = i.x * this.a, i.y = i.y * this.a, i;
}
function eU(i) {
  var e = -1, t = 0, n = 0, s, r, a, o;
  if (i.x = i.x / this.a, i.y = i.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (n = Math.tan(i.y / this.radius_g_1), t = Math.tan(i.x / this.radius_g_1) * Qn(1, n)) : (t = Math.tan(i.x / this.radius_g_1), n = Math.tan(i.y / this.radius_g_1) * Qn(1, t));
    var l = n / this.radius_p;
    if (s = t * t + l * l + e * e, r = 2 * this.radius_g * e, a = r * r - 4 * s * this.C, a < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    o = (-r - Math.sqrt(a)) / (2 * s), e = this.radius_g + o * e, t *= o, n *= o, i.x = Math.atan2(t, e), i.y = Math.atan(n * Math.cos(i.x) / e), i.y = Math.atan(this.radius_p_inv2 * Math.tan(i.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (n = Math.tan(i.y / this.radius_g_1), t = Math.tan(i.x / this.radius_g_1) * Math.sqrt(1 + n * n)) : (t = Math.tan(i.x / this.radius_g_1), n = Math.tan(i.y / this.radius_g_1) * Math.sqrt(1 + t * t)), s = t * t + n * n + e * e, r = 2 * this.radius_g * e, a = r * r - 4 * s * this.C, a < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    o = (-r - Math.sqrt(a)) / (2 * s), e = this.radius_g + o * e, t *= o, n *= o, i.x = Math.atan2(t, e), i.y = Math.atan(n * Math.cos(i.x) / e);
  }
  return i.x = i.x + this.long0, i;
}
var tU = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const nU = {
  init: QN,
  forward: JN,
  inverse: eU,
  names: tU
};
var Zl = 1.340264, $l = -0.081106, Kl = 893e-6, Ql = 3796e-6, Yu = Math.sqrt(3) / 2;
function iU() {
  this.es = 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0;
}
function sU(i) {
  var e = Te(i.x - this.long0), t = i.y, n = Math.asin(Yu * Math.sin(t)), s = n * n, r = s * s * s;
  return i.x = e * Math.cos(n) / (Yu * (Zl + 3 * $l * s + r * (7 * Kl + 9 * Ql * s))), i.y = n * (Zl + $l * s + r * (Kl + Ql * s)), i.x = this.a * i.x + this.x0, i.y = this.a * i.y + this.y0, i;
}
function rU(i) {
  i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a;
  var e = 1e-9, t = 12, n = i.y, s, r, a, o, l, c;
  for (c = 0; c < t && (s = n * n, r = s * s * s, a = n * (Zl + $l * s + r * (Kl + Ql * s)) - i.y, o = Zl + 3 * $l * s + r * (7 * Kl + 9 * Ql * s), n -= l = a / o, !(Math.abs(l) < e)); ++c)
    ;
  return s = n * n, r = s * s * s, i.x = Yu * i.x * (Zl + 3 * $l * s + r * (7 * Kl + 9 * Ql * s)) / Math.cos(n), i.y = Math.asin(Math.sin(n) / Yu), i.x = Te(i.x + this.long0), i;
}
var aU = ["eqearth", "Equal Earth", "Equal_Earth"];
const oU = {
  init: iU,
  forward: sU,
  inverse: rU,
  names: aU
};
var Ac = 1e-10;
function lU() {
  var i;
  if (this.phi1 = this.lat1, Math.abs(this.phi1) < Ac)
    throw new Error();
  this.es ? (this.en = qg(this.es), this.m1 = cl(
    this.phi1,
    this.am1 = Math.sin(this.phi1),
    i = Math.cos(this.phi1),
    this.en
  ), this.am1 = i / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1), this.inverse = hU, this.forward = cU) : (Math.abs(this.phi1) + Ac >= re ? this.cphi1 = 0 : this.cphi1 = 1 / Math.tan(this.phi1), this.inverse = dU, this.forward = uU);
}
function cU(i) {
  var e = Te(i.x - (this.long0 || 0)), t = i.y, n, s, r;
  return n = this.am1 + this.m1 - cl(t, s = Math.sin(t), r = Math.cos(t), this.en), s = r * e / (n * Math.sqrt(1 - this.es * s * s)), i.x = n * Math.sin(s), i.y = this.am1 - n * Math.cos(s), i.x = this.a * i.x + (this.x0 || 0), i.y = this.a * i.y + (this.y0 || 0), i;
}
function hU(i) {
  i.x = (i.x - (this.x0 || 0)) / this.a, i.y = (i.y - (this.y0 || 0)) / this.a;
  var e, t, n, s;
  if (t = Qn(i.x, i.y = this.am1 - i.y), s = Yg(this.am1 + this.m1 - t, this.es, this.en), (e = Math.abs(s)) < re)
    e = Math.sin(s), n = t * Math.atan2(i.x, i.y) * Math.sqrt(1 - this.es * e * e) / Math.cos(s);
  else if (Math.abs(e - re) <= Ac)
    n = 0;
  else
    throw new Error();
  return i.x = Te(n + (this.long0 || 0)), i.y = zr(s), i;
}
function uU(i) {
  var e = Te(i.x - (this.long0 || 0)), t = i.y, n, s;
  return s = this.cphi1 + this.phi1 - t, Math.abs(s) > Ac ? (i.x = s * Math.sin(n = e * Math.cos(t) / s), i.y = this.cphi1 - s * Math.cos(n)) : i.x = i.y = 0, i.x = this.a * i.x + (this.x0 || 0), i.y = this.a * i.y + (this.y0 || 0), i;
}
function dU(i) {
  i.x = (i.x - (this.x0 || 0)) / this.a, i.y = (i.y - (this.y0 || 0)) / this.a;
  var e, t, n = Qn(i.x, i.y = this.cphi1 - i.y);
  if (t = this.cphi1 + this.phi1 - n, Math.abs(t) > re)
    throw new Error();
  return Math.abs(Math.abs(t) - re) <= Ac ? e = 0 : e = n * Math.atan2(i.x, i.y) / Math.cos(t), i.x = Te(e + (this.long0 || 0)), i.y = zr(t), i;
}
var fU = ["bonne", "Bonne (Werner lat_1=90)"];
const pU = {
  init: lU,
  names: fU
};
function mU(i) {
  i.Proj.projections.add(Su), i.Proj.projections.add(wu), i.Proj.projections.add(hD), i.Proj.projections.add(yD), i.Proj.projections.add(TD), i.Proj.projections.add(PD), i.Proj.projections.add(UD), i.Proj.projections.add(HD), i.Proj.projections.add(qD), i.Proj.projections.add(KD), i.Proj.projections.add(pO), i.Proj.projections.add(xO), i.Proj.projections.add(TO), i.Proj.projections.add(LO), i.Proj.projections.add(UO), i.Proj.projections.add(HO), i.Proj.projections.add(qO), i.Proj.projections.add(KO), i.Proj.projections.add(iN), i.Proj.projections.add(lN), i.Proj.projections.add(fN), i.Proj.projections.add(_N), i.Proj.projections.add(SN), i.Proj.projections.add(CN), i.Proj.projections.add(DN), i.Proj.projections.add(HN), i.Proj.projections.add(qN), i.Proj.projections.add(KN), i.Proj.projections.add(nU), i.Proj.projections.add(oU), i.Proj.projections.add(pU);
}
ai.defaultDatum = "WGS84";
ai.Proj = _s;
ai.WGS84 = new ai.Proj("WGS84");
ai.Point = Jo;
ai.toPoint = Wb;
ai.defs = Bn;
ai.nadgrid = dI;
ai.transform = Wu;
ai.mgrs = CI;
ai.version = "__VERSION__";
mU(ai);
function gU() {
  const i = new $m();
  return i.EnvBackground = null, i.environmentEnabled = !1, i.envChangeUse = () => i.environmentEnabled ? i.environment = i.EnvBackground : i.environment = null, i.MeshEnvMapChangeUseList = [], i.SsrMeshList = [], i;
}
function vU(i, e) {
  const t = new Zt(50, e.clientWidth / e.clientHeight, 0.1, 1e5);
  return t.position.set(10, 10, 10), t.name = "PerspectiveCamera", i.add(t), t;
}
function _U(i, e) {
  const t = new Zm(i.webglRenderParams);
  return t.setSize(e.clientWidth, e.clientHeight), t.setPixelRatio(i.pixelRatio), e.appendChild(t.domElement), t;
}
function yU(i, e) {
  const t = new $3(i, e.domElement);
  return t.enableDamping = !0, t.dampingFactor = 0.05, t.minDistance = 1, t.maxDistance = 5e3, t.minZoom = 1e3, t.maxPolarAngle = Math.PI, t;
}
function oy(i) {
  for (; i.parent.type !== "Scene"; )
    i = i.parent;
  return i;
}
function xU(i = 1, e = 16777215) {
  const t = new Pt(i, i, i), n = new on({ color: e });
  return new le(t, n);
}
function ly(i, e) {
  var n;
  const t = new pg().load(e);
  i.background = t, (n = i.backgroundLoadCallback) == null || n.call(i, t);
}
function cy(i, e) {
  const t = new pg().load(e);
  let n = null;
  Object.defineProperty(i, "EnvBackground", {
    get: () => n,
    set: (s) => {
      var r;
      n = s, (r = i.envChangeUse) == null || r.call(i), i == null || i.MeshEnvMapChangeUseList.forEach((a) => a());
    }
  }), i.EnvBackground = t;
}
function MU(i = "", e) {
  const t = new WP(), n = { progress: () => {
  }, complete: () => {
  } };
  return t.load(
    i,
    (s) => {
      n.complete(s), s.traverse((r) => {
        if (r.material) {
          let a = function(o) {
            o.side = $t, o.vertexColors = !1;
          };
          Array.isArray(r.material) ? r.material.map((o) => a(o)) : a(r.material);
        }
      }), e(s);
    },
    (s) => n.progress(s.loaded / s.total, s)
  ), n;
}
function bU(i = "", e = "/draco/", t = () => {
}) {
  const n = new n3(), s = { progress: () => {
  }, complete: () => {
  } };
  return n.setDRACOLoader(new N3().setDecoderPath(e)), n.load(
    i,
    (r) => {
      s.complete(r.scene), r.scene.animations = r.animations, t(r.scene);
    },
    (r) => s.progress(r.loaded / r.total, r),
    (r) => {
    }
  ), s;
}
function Kg(i) {
  let e = [];
  return i.traverse((t) => {
    t.isMesh && (Array.isArray(t.material) ? t.material.forEach((n) => {
      e.push(n);
    }) : e.push(t.material));
  }), i.disposeRoot = function() {
    this.traverse((t) => {
      var n;
      return t.isMesh && ((n = t.geometry) == null ? void 0 : n.dispose());
    }), this == null || this.RootMaterials.forEach((t) => {
      var n;
      t.dispose(), (n = t.map) == null || n.dispose();
    });
  }, [...new Set(e)];
}
function SU(i = "", e = () => {
}) {
  const t = new G3(), n = new V3(), s = { progress: () => {
  }, complete: () => {
  } };
  return n.load(i.replace(".obj", ".mtl"), (r) => {
    r.preload(), t.setMaterials(r), t.load(
      i,
      (a) => {
        s.complete(a), e(a);
      },
      (a) => s.progress(a.loaded / a.total, a),
      (a) => {
      }
    );
  }), s;
}
function wU(i) {
  let e = new Yl();
  return e.setMode(0), e.domElement.style.position = "absolute", e.domElement.style.top = i.getBoundingClientRect().top + "px", e.domElement.style.left = i.getBoundingClientRect().left + "px", e.setStats = () => !i.contains(e.domElement) && i.appendChild(e.domElement), e.destroy = () => i.contains(e.domElement) && i.removeChild(e.domElement), e;
}
function TU(i = 144) {
  const e = new qc();
  if (i === null) return (s) => s(e.getDelta());
  const t = 1 / i;
  let n = 0;
  return (s) => {
    const r = e.getDelta();
    n = n + r, n > t && (s(r), n = 0);
  };
}
function EU(i, e, t, n) {
  const s = new K3(e, t.domElement);
  s.name = "TransformControls", s.traverse((a) => a.text = "TransformControls"), i.add(s);
  const r = new ln();
  return s.addEventListener("dragging-changed", (a) => {
    var o;
    n.enabled = !a.value, s.drag_change_callback(a.value), (o = s.dragChangeCallback) == null || o.call(s, a.value);
  }), s.addEventListener("change", () => {
    var a;
    s.box3Helper && (["Group", "Mesh"].includes((a = s == null ? void 0 : s.object) == null ? void 0 : a.type) ? (s.box3Helper.box = r.setFromObject(s.object), s.box3Helper.visible = !0) : s.box3Helper.visible = !1);
  }), s;
}
function n1(i) {
  return new k(
    i.offsetX / i.target.clientWidth * 2 - 1,
    -(i.offsetY / i.target.clientHeight) * 2 + 1
  );
}
function AU(i, e, t) {
  const n = new Fd();
  return n.setFromCamera(i, e), n.intersectObjects(t.children).filter((r) => r.object.text !== "TransformControls" && r.object.isMesh && r.object.visible);
}
function CU(i, e, t, n) {
  const s = new cL(t), r = t.getPixelRatio();
  s.setSize(n.clientWidth, n.clientHeight), s.setPixelRatio(r), s.setRenderWay = (m = "") => {
    m === "" ? s.EffectComposerRender = () => t.render(i, e) : s.EffectComposerRender = () => s.render(), s.renderWay = m;
  }, s.setRenderWay(), s.effectPass = {};
  const a = new hL(i, e);
  s.addPass(a);
  const o = new Sc(i, e);
  o.enabled = !1, o.params.saoIntensity = 0.01, o.params.saoScale = 100, s.addPass(o), s.effectPass.saoPass = o;
  const l = new Qo(new k(n.clientWidth, n.clientHeight), 1.5, 0.4, 0.85);
  l.enabled = !1, s.addPass(l), s.effectPass.unrealBloomPass = l;
  const c = new Ns({ renderer: t, scene: i, camera: e, width: n.clientWidth, height: n.clientHeight, selects: i.SsrMeshList });
  c.thickness = 0.018, c.infiniteThick = !1, c.maxDistance = 0.01, c.opacity = 0.5, c.enabled = !1, s.addPass(c), s.effectPass.ssrPass = c;
  const h = new mr(new k(n.clientWidth, n.clientHeight), i, e);
  h.renderToScreen = !0, h.edgeStrength = 4, h.edgeGlow = 0, h.edgeThickness = 2, h.pulsePeriod = 0, h.usePatternTexture = !1, h.visibleEdgeColor.set(16449071), h.hiddenEdgeColor.set(16449071), h.overlayMaterial.blending = Fo, h.overlayMaterial.blendSrc = Lc, s.addPass(h), s.effectPass.outlinePass = h;
  const u = new dL();
  s.addPass(u);
  const d = new Gg(mL);
  d.multPixel = 1, d.resize = () => {
    d.material.uniforms.resolution.value.x = d.multPixel / (n.clientWidth * r), d.material.uniforms.resolution.value.y = d.multPixel / (n.clientHeight * r);
  }, d.resize(), s.addPass(d), s.effectPass.fxaaPass = d;
  const f = new gL();
  return f.enabled = !1, s.addPass(f), s.effectPass.screenMaskPass = f, s.resize = () => {
    s.setSize(n.clientWidth, n.clientHeight), l.setSize(n.clientWidth, n.clientHeight), d.resize();
  }, { Composer: s, outlinePass: h, unrealBloomPass: l };
}
function RU(i) {
  const e = new vL();
  return e.resize = () => {
    e.setSize(i.clientWidth, i.clientHeight), e.domElement.style.zIndex = 0, e.domElement.style.position = "relative", e.domElement.style.top = -i.clientHeight * 2 + "px", e.domElement.style.height = i.clientHeight + "px", e.domElement.style.width = i.clientWidth + "px", e.domElement.style.pointerEvents = "none";
  }, e.resize(), i.appendChild(e.domElement), { CssRender: e, CSS2DObject: Rb };
}
function PU(i) {
  const e = new xL();
  return e.resize = () => {
    e.setSize(i.clientWidth, i.clientHeight), e.domElement.style.zIndex = 0, e.domElement.style.position = "relative", e.domElement.style.top = -i.clientHeight + "px", e.domElement.style.height = i.clientHeight + "px", e.domElement.style.width = i.clientWidth + "px", e.domElement.style.pointerEvents = "none";
  }, e.resize(), i.appendChild(e.domElement), { Css3Render: e, CSS3DObject: Pb };
}
function LU(i, e, t = 0.9) {
  const n = i.distanceTo(e);
  return new T().subVectors(e, i).normalize().multiplyScalar(n * t).add(i);
}
function Cc(i, e, t = null) {
  return Hd.to(
    i,
    {
      ...e,
      //
      duration: 2,
      //
      ease: "none",
      //
      repeat: 0,
      //
      yoyo: !1,
      yoyoEase: !0,
      ...t
    }
  );
}
function IU(i, e = () => {
}) {
  const t = new qc(), n = new dM(i);
  return i.mixerRender = () => {
    const s = t.getDelta();
    e(), n.update(s);
  }, n;
}
function DU(i, e, t = 1, n = 0, s = !0) {
  const r = i.clipAction(e);
  return r.loop = s ? Bm : Fm, r.time = n, r.timeScale = t, r.clampWhenFinished = !0, r;
}
function i1(i, e, t) {
  return new T().subVectors(e, i).normalize().multiplyScalar(t).add(i);
}
function s1(i) {
  const e = new ln().setFromObject(i), { max: t, min: n } = e, s = new T();
  e.getCenter(s);
  const r = new T().subVectors(t, n).length() / 2;
  return { max: t, min: n, center: s, radius: r };
}
function r1(i, e = 2.5) {
  const { center: t, max: n } = s1(i), s = new T().subVectors(n, t).length() * e;
  return { position: i1(t, n, s), target: t };
}
function a1(i, e = "fence") {
  const t = i.length, n = e === "fence" ? i.map((d, f) => f - 1 > -1 && f + 1 < t && (f % 2 === 0 ? [f, f + 1, f - 1] : [f, f - 1, f + 1])).filter((d) => d).reduce((d, f) => [...d, ...f], []) : i.map((d, f) => f >= 2 ? [0, f - 1, f] : !1).filter((d) => d).reduce((d, f) => [...d, ...f], []), s = i.reduce((d, f) => [...d, f.x, f.y, f.z], []), r = i.reduce((d, f) => ({ x: [...d.x, f.x], y: [...d.y, f.y], z: [...d.z, f.z] }), { x: [], y: [], z: [] }), a = new T(Math.max(...r.x), Math.max(...r.y), Math.max(...r.z)), o = new T(Math.min(...r.x), Math.min(...r.y), Math.min(...r.z)), l = a.x - o.x, c = a.y - o.y, h = l > c ? l : c, u = i.map((d, f, m) => new k((d.x - o.x) / h, (d.y - o.y) / h)).reduce((d, f) => [...d, ...f], []);
  return { indexGroup: n, faceGroup: s, uvGroup: u };
}
function o1(i, e, t) {
  const n = new Be(), s = new Float32Array(i);
  if (n.setAttribute("position", new dt(s, 3)), e) {
    let r = new Uint16Array(e);
    n.index = new dt(r, 1);
  }
  return t && (n.attributes.uv = new ye(t, 2)), n.computeVertexNormals(), n;
}
function l1(i, e, t, n) {
  i.setIndex(t), i.setAttribute("position", new ye(e, 3)), i.setAttribute("uv", new ye(n, 2)), delete i.attributes.normal, i.computeVertexNormals();
}
function OU(i) {
  const e = document.createElement("video");
  return e.crossOrigin = "anonymous", e.src = i, e.muted = !0, e.loop = !0, e.play(), new Gx(e);
}
function c1(i) {
  new ln().setFromObject(i).getCenter(i.position), i.geometry.center();
}
function h1(i) {
  new ln().setFromObject(i).getCenter(i.position), i.translationOriginDiff = i.position.clone(), i.getTransformedVector = (t) => {
    const n = t.clone();
    return n.sub(i.translationOriginDiff), n.multiply(i.scale), n.applyEuler(i.rotation), n.add(i.position), n;
  }, i.traverse((t) => {
    t.isMesh && t.position.sub(i.position), t.initTranslate = t.position.clone();
  }), i.position.set(0, 0, 0);
}
function pm(i, e = 1e4) {
  const [t, n] = i, [s, r] = ai("EPSG:4326", "EPSG:3857", [t, n]);
  return new k(s / e, r / e);
}
function NU(i, e = 1e4) {
  const [t, n] = i, [s, r] = ai("EPSG:4326", "EPSG:3857", [t, n]);
  return new T(s / e, r / e, 0);
}
function UU(i) {
  const e = new Vg({
    color: 0,
    linewidth: 1e-3,
    vertexColors: !1,
    dashed: !1,
    alphaToCoverage: !1
  }), t = new Ib().setPositions(i), n = new wL(t, e);
  return n.computeLineDistances(), n;
}
function FU(i, e) {
  return Array.isArray(i.material) ? i.material.forEach((t) => mm(t, e)) : mm(i.material, e), i.meshRevertMaterial = () => {
    Array.isArray(i.material) ? i.material.forEach((t) => t.revertMaterial()) : i.material.revertMaterial();
  }, i;
}
function BU(i, e) {
  let t = [];
  return i.traverse((n) => n.isMesh && !t.includes(n.material) && t.push(n.material)), t.forEach((n) => mm(n, e)), i.meshRevertMaterial = () => t.forEach((n) => n.revertMaterial()), i;
}
function mm(i, e = {}) {
  const t = hy(i, e);
  return i.revertMaterial = () => {
    hy(i, t);
  }, i;
}
function hy(i, e = {}) {
  const t = {};
  return Object.keys(e).forEach((n) => {
    n === "color" || n === "emissive" ? (t[n] = i[n].getHex(), i[n].set(e[n])) : (t[n] = i[n], i[n] = e[n]);
  }), i.needsUpdate = !0, t;
}
function kU(i, e = {}) {
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = { x: i[n].x, y: i[n].y, z: i[n].z }, i[n].set(e[n].x, e[n].y, e[n].z);
  }), i.meshRevertTransform = () => {
    Object.keys(t).forEach((n) => {
      i[n].set(t[n].x, t[n].y, t[n].z);
    });
  }, i;
}
function zU(i) {
  i.traverse((e) => {
    e.isCloneMaterial = !0, e.isMesh && (e.originMaterial = e.material, Array.isArray(e.material) ? e.material = e.material.map((t) => t.clone()) : e.material = e.material.clone());
  });
}
function HU(i, e = 1, t) {
  return {
    id: Date.now(),
    curve: i,
    time: 0,
    pause: !1,
    speed: e,
    start: function() {
      t.indexOf(this) > -1 || (t.push(this), this.pause = !1);
    },
    destroy: function() {
      const n = t.indexOf(this);
      n > -1 && t.splice(n, 1), delete this.start, delete this.destroy;
    },
    frameCallback: null,
    frameEndCallback: null,
    frameAnimationRender: function() {
      var n, s;
      if (!this.pause) {
        if (this.time += this.speed / 1e3, this.time > 1 || this.time < 0)
          return this.time = this.time > 1 ? 1 : 0, this.pause = !0, (n = this.frameEndCallback) == null ? void 0 : n.call(this, "end");
        (s = this.frameCallback) == null || s.call(this, this.curve.getPointAt(this.time));
      }
    }
  };
}
function GU(i, e) {
  return i.multiply(e.scale), i.applyEuler(e.rotation), i.add(e.position), i;
}
function No(i) {
  const { position: e, rotation: t, scale: n } = i;
  return {
    position: { x: e.x, y: e.y, z: e.z },
    rotation: { x: t.x, y: t.y, z: t.z },
    scale: { x: n.x, y: n.y, z: n.z }
  };
}
function ju(i, e) {
  if (!e) return;
  const { position: t, rotation: n, scale: s } = e;
  i.position.set(t.x, t.y, t.z), i.rotation.set(n.x, n.y, n.z), i.scale.set(s.x, s.y, s.z);
}
function Qg(i, e, t, n) {
  const { mode: s, query: r } = n;
  ju(i, e);
  const a = ["position", "rotation", "scale"].map((o) => new Promise((l) => {
    Hd[s](i[o], {
      x: t[o].x,
      y: t[o].y,
      z: t[o].z,
      ...r,
      onComplete: l
    });
  }));
  return Promise.all(a);
}
function VU(i, e) {
  const { mode: t, query: n } = e;
  return {
    name: "",
    _transformInfo: i._transformInfo,
    transformInfo_: No(i),
    gsapParams: {
      mode: t,
      query: { ...n }
    }
  };
}
function WU(i) {
  var e, t;
  i.children.forEach((n) => {
    i.remove(n), n.traverse((s) => {
      var r, a;
      (r = s.dispose) == null || r.call(s), s instanceof le && (s.geometry.dispose(), s.material && (Array.isArray(s.material) ? s.material.forEach((o) => {
        var l;
        o.dispose(), (l = o.map) == null || l.dispose();
      }) : (s.material.dispose(), (a = s.material.map) == null || a.dispose())));
    });
  }), (e = i.EnvBackground) == null || e.dispose(), (t = i.background) == null || t.dispose(), i.children.length = 0;
}
function XU(i, e = "") {
  i.children.forEach((t) => {
    (["Group", "Mesh"].includes(t.type) || t.isLight) && (e === "" || e.some((n) => t.name.indexOf(n) !== -1) ? t.visible = !0 : t.visible = !1);
  });
}
function u1(i, e, t = null) {
  const n = new X3();
  return new Promise((s) => {
    n.load(
      i,
      (r) => s(new Db(e, {
        font: r,
        size: 1,
        depth: 0.2,
        height: 0.2,
        curveSegments: 12,
        bevelEnabled: !0,
        bevelThickness: 0,
        bevelSize: 0,
        bevelSegments: 5,
        ...t
      }))
    );
  });
}
function qU(i, e = 50) {
  const { center: t, radius: n, max: s } = s1(i), r = i.getWorldDirection(new T()), a = n / Math.tan(Math.PI * e / 360), o = r.multiplyScalar(a), l = o.clone().add(t), c = o.clone().applyAxisAngle(new T(0, 1, 0), -Math.PI / 2).add(t), h = o.clone().applyAxisAngle(new T(0, 1, 0), Math.PI / 2).add(t), u = o.clone().applyAxisAngle(new T(1, 0, 0), -Math.PI / 2).add(t), d = o.clone().applyAxisAngle(new T(1, 0, 0), Math.PI / 2).add(t), f = o.clone().applyAxisAngle(new T(0, 1, 0), Math.PI).add(t), m = i1(t, s, t.distanceTo(s) / Math.tan(Math.PI * e / 360));
  return { frontView: l, leftView: c, rightView: h, topView: u, bottomView: d, backView: f, maxView: m, target: t };
}
function YU(i) {
  const e = ws(i), t = () => e.iTime.value += e.speed.value, n = {
    vertexHeader: Ts,
    fragHeader: Xn(e) + `varying vec2 vUv; 
`,
    fragBody: `
            vec3 c;
            float l,z=iTime;
            for(int i=0;i<3;i++) {
                vec2 uv,p=gl_FragCoord.xy/iResolution/2.0;
                uv=p;
                p-=.3;
                if(hasUv) uv=vUv;
                z+=.07;
                l=length(p);
                uv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z-z));
                c[i]=.01/length(mod(uv,1.)-.5);
            }
        `,
    pointFragIn: "vec3 effect_color = c;",
    lightFragEnd: "vec4 diffuseColor = vec4( mix(diffuse, c * mixColor * vec3(intensity, intensity, intensity) , mixRatio), opacity );"
  };
  return { uniforms: e, glslProps: n, ShaderAnimateRender: t, shaderProgramsCodeName: "" };
}
function jU(i) {
  const e = {
    ...ws(i),
    TAU: { type: "number", unit: "float", value: 6.28318530718 },
    MAX_ITER: { type: "number", unit: "int", value: 5 }
  }, t = () => e.iTime.value += e.speed.value, n = {
    vertexHeader: Ts,
    fragHeader: Xn(e) + `varying vec2 vUv; 
`,
    fragBody: `
            float time = iTime * .5+23.0;
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            if(hasUv) uv = vUv;
            #ifdef SHOW_TILING
                vec2 p = mod(uv*TAU*2.0, TAU)-250.0;
            #else
                vec2 p = mod(uv*TAU, TAU)-250.0;
            #endif
            vec2 i = vec2(p);
            float c = 1.0;
            float inten = .005;
            for (int n = 0; n < MAX_ITER; n++) 
            {
                float t = time * (1.0 - (3.5 / float(n+1)));
                i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));
                c += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));
            }
            c /= float(MAX_ITER);
            c = 1.17-pow(c, 1.4);
            vec3 colour = vec3(pow(abs(c), 8.0));
            colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);
            #ifdef SHOW_TILING
            // Flash tile borders...
            vec2 pixel = 2.0 / iResolution.xy;
            uv *= 2.0;
            float f = floor(mod(iTime*.5, 2.0)); 	// Flash value.
            vec2 first = step(pixel, uv) * f;		   	// Rule out first screen pixels and flash.
            uv  = step(fract(uv), pixel);				// Add one line of pixels per tile.
            colour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line
            #endif
        `,
    pointFragIn: "vec3 effect_color = colour;",
    lightFragEnd: "vec4 diffuseColor = vec4( mix(diffuse, colour * mixColor * vec3(intensity, intensity, intensity) , mixRatio), opacity );"
  };
  return { uniforms: e, glslProps: n, ShaderAnimateRender: t, shaderProgramsCodeName: "" };
}
function ZU() {
  const i = {
    innerCircleWidth: { value: 1, type: "number", unit: "float" },
    circleWidth: { value: 2, type: "number", unit: "float" },
    circleMax: { value: 2, type: "number", unit: "float" },
    opacityScale: { type: "number", unit: "float", value: 1, min: 0, max: 8 },
    reverseOpacity: { type: "bool", unit: "bool", value: !0 },
    circleSpeed: { value: 0.01, type: "number", unit: "float" },
    diff: { value: new Q(0, 0, 1), type: "color", unit: "vec3" },
    color3: { value: new Q(0, 0, 1), type: "color", unit: "vec3" },
    center: { value: new T(0, 0, 0), type: "position", unit: "vec3" },
    intensity: { value: 1, type: "number", unit: "float" },
    isDisCard: { value: !1, type: "bool", unit: "bool" }
  }, e = () => i.innerCircleWidth.value < i.circleMax.value ? i.innerCircleWidth.value += i.circleSpeed.value : i.innerCircleWidth.value = 0, t = {
    vertexHeader: `
            varying vec2 vUv;
            varying vec3 v_position;
            void main() {
                vUv = uv;
                v_position = position;
        `,
    fragHeader: Xn(i) + `
varying vec3 v_position; varying vec2 vUv;
`,
    fragBody: `
            float dis = length(v_position - center);
            vec4 diffuseColor;
            if(dis < (innerCircleWidth + circleWidth) && dis > innerCircleWidth) {
                float r = (dis - innerCircleWidth) / circleWidth;
                float cOpacity = reverseOpacity ? (innerCircleWidth / circleMax) : 1. - ( innerCircleWidth / circleMax );
                #ifdef USE_MAP
                    vec3 textureColor = texture2D(map, vUv).rgb;
                    if(isDisCard && textureColor.r < 0.1 && textureColor.g < 0.1  && textureColor.b < 0.1 ) discard;
                #endif
                diffuseColor = vec4( mix(diff, color3, r) * vec3(intensity, intensity, intensity)  , opacity * cOpacity * opacityScale);
            }
            else {
                if(isDisCard)  discard ;
                else diffuseColor = vec4( diffuse, opacity );
            }
        `
  };
  return { uniforms: i, glslProps: t, ShaderAnimateRender: e, shaderProgramsCodeName: "" };
}
const $U = (i) => {
  const e = ws(i), t = () => e.iTime.value += e.speed.value, n = {
    vertexHeader: `
            varying vec3 v_position;
            varying vec2 vUv;
            void main() {
                vUv = uv;
                v_position  =  (projectionMatrix  * vec4(position, 1.0)).xyz;
        `,
    fragHeader: Xn(e) + `varying vec3 v_position; 
varying vec2 vUv; 
`,
    fragFunc: `
            float gTime = 0.;
            const float REPEAT = 5.0;

            // 
            mat2 rot(float a) {
                float c = cos(a), s = sin(a);
                return mat2(c,s,-s,c);
            }

            float sdBox( vec3 p, vec3 b )
            {
                vec3 q = abs(p) - b;
                return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
            }

            float box(vec3 pos, float scale) {
                pos *= scale;
                float base = sdBox(pos, vec3(.4,.4,.1)) /1.5;
                pos.xy *= 5.;
                pos.y -= 3.5;
                pos.xy *= rot(.75);
                float result = -base;
                return result;
            }

            float box_set(vec3 pos, float iTime) {
                vec3 pos_origin = pos;
                pos = pos_origin;
                pos .y += sin(gTime * 0.4) * 2.5;
                pos.xy *=   rot(.8);
                float box1 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);
                pos = pos_origin;
                pos .y -=sin(gTime * 0.4) * 2.5;
                pos.xy *=   rot(.8);
                float box2 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);
                pos = pos_origin;
                pos .x +=sin(gTime * 0.4) * 2.5;
                pos.xy *=   rot(.8);
                float box3 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);	
                pos = pos_origin;
                pos .x -=sin(gTime * 0.4) * 2.5;
                pos.xy *=   rot(.8);
                float box4 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);	
                pos = pos_origin;
                pos.xy *=   rot(.8);
                float box5 = box(pos,.5) * 6.;	
                pos = pos_origin;
                float box6 = box(pos,.5) * 6.;	
                float result = max(max(max(max(max(box1,box2),box3),box4),box5),box6);
                return result;
            }
            float mapf(vec3 pos, float iTime) {
                vec3 pos_origin = pos;
                float box_set1 = box_set(pos, iTime);

                return box_set1;
            }
        `,
    fragBody: `
            vec2 p = v_position.xy/v_position.z;
            if(hasUv) p = vUv;
            vec3 ro = vec3(0., -0.2 ,iTime * 4.);
            vec3 ray = normalize(vec3(p, 1.5));
            ray.xy = ray.xy * rot(sin(iTime * .03) * 5.);
            ray.yz = ray.yz * rot(sin(iTime * .05) * .2);
            float t = 0.1;
            vec3 col = vec3(0.);
            float ac = 0.0;
            for (int i = 0; i < 99; i++){
                vec3 pos = ro + ray * t;
                pos = mod(pos-2., 4.) -2.;
                gTime = iTime -float(i) * 0.01;
                
                float d = mapf(pos, iTime);

                d = max(abs(d), 0.01);
                ac += exp(-d*23.);

                t += d* 0.55;
            }
            col = vec3(ac * 0.02);
            col +=vec3(0.,0.2 * abs(sin(iTime)),0.5 + sin(iTime) * 0.2);  
        `,
    pointFragIn: "vec3 effect_color = col;",
    lightFragEnd: "vec4 diffuseColor = vec4( mix(diffuse, col * mixColor , mixRatio), opacity );"
  };
  return { uniforms: e, glslProps: n, ShaderAnimateRender: t, shaderProgramsCodeName: "" };
};
function KU(i) {
  const e = {
    iResolution: { type: "vec2", value: new k(i.clientWidth, i.clientHeight), unit: "vec2" },
    iTime: { type: "number", value: 1, unit: "float" },
    speed: { type: "number", value: 0.05, unit: "float" },
    intensity: { type: "number", unit: "float", value: 2 },
    density: { type: "number", unit: "float", value: 5 },
    mixColor: { type: "color", unit: "vec3", value: new Q(16777215) },
    high: { type: "number", unit: "float", value: 0.5 },
    medium: { type: "number", unit: "float", value: 0.4 }
  }, t = () => e.iTime.value += e.speed.value, n = {
    vertexHeader: Ts,
    fragHeader: Xn(e) + `varying vec2 vUv; 
`,
    fragBody: `
            vec4 fragColor = vec4(0.);
            float sin = sin((vUv.y - iTime * speed) * 10. * density);
            if (sin > high) {
              fragColor = vec4( mixColor, (1. - sin) / (1. - high));
            } else if(sin > medium) {
               fragColor = vec4(mixColor, mix(1., 0., 1.-(sin - medium) / (high - medium)));
            } else {
               fragColor = vec4(mixColor, 0.);
            }
            fragColor = mix(fragColor, vec4(mix(mixColor, vec3(0., 0., 0.), vUv.y), 1.), 0.);
        `,
    lightFragEnd: " vec4 diffuseColor = vec4(fragColor.rgb * vec3(intensity, intensity, intensity), fragColor.a * opacity * (1. - vUv.y));"
  };
  return { uniforms: e, glslProps: n, ShaderAnimateRender: t, shaderProgramsCodeName: "" };
}
function QU(i) {
  const e = ws(i), t = () => e.iTime.value += e.speed.value, n = {
    vertexHeader: `
            precision lowp float;
            varying vec2 vUv;
            void main() {
                vUv = uv;
        `,
    fragHeader: Xn(e) + ` varying vec2 vUv; 
`,
    fragFunc: `
            mat2 rot(float a) {
                float c = cos(a), s = sin(a);
                return mat2(c,s,-s,c);
            }

            const float pi = acos(-1.0);
            const float pi2 = pi*2.0;

            vec2 pmod(vec2 p, float r) {
                float a = atan(p.x, p.y) + pi/r;
                float n = pi2 / r;
                a = floor(a/n)*n;
                return p*rot(-a);
            }

            float box( vec3 p, vec3 b ) {
                vec3 d = abs(p) - b;
                return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
            }

            float ifsBox(vec3 p) {
                for (int i=0; i<5; i++) {
                    p = abs(p) - 1.0;
                    p.xy *= rot(iTime*0.3);
                    p.xz *= rot(iTime*0.1);
                }
                p.xz *= rot(iTime);
                return box(p, vec3(0.4,0.8,0.3));
            }

            float mapSnow(vec3 p, vec3 cPos) {
                vec3 p1 = p;
                p1.x = mod(p1.x-5., 10.) - 5.;
                p1.y = mod(p1.y-5., 10.) - 5.;
                p1.z = mod(p1.z, 16.)-8.;
                p1.xy = pmod(p1.xy, 5.0);
                return ifsBox(p1);
            }  
        `,
    fragBody: `
            vec2 p = (gl_FragCoord.xy * 2.0  - iResolution.xy) / min(iResolution.x, iResolution.y);
            if(hasUv) p = vUv;
            vec3 cPos = vec3(0.0,0.0, -3.0 * iTime);
            vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));
            vec3 cUp  = vec3(sin(iTime), 1.0, 0.0);
            vec3 cSide = cross(cDir, cUp);
            vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);
            float acc = 0.0;
            float acc2 = 0.0;
            float t = 0.0;
            for (int i = 0; i < 99; i++) {
                vec3 pos = cPos + ray * t;
                float dist = mapSnow(pos, cPos);
                dist = max(abs(dist), 0.02);
                float a = exp(-dist*3.0);
                if (mod(length(pos)+24.0*iTime, 30.0) < 3.0) {
                    a *= 2.0;
                    acc2 += a;
                }
                acc += a;
                t += dist * 0.5;
            }
            vec3 col = vec3(acc * 0.01, acc * 0.011 + acc2*0.002, acc * 0.012+ acc2*0.005);
        `,
    pointFragIn: "vec3 effect_color = col;",
    lightFragEnd: "vec4 diffuseColor = vec4( mix(diffuse, col * mixColor * vec3(intensity, intensity, intensity) , mixRatio), opacity );"
  };
  return { uniforms: e, glslProps: n, ShaderAnimateRender: t, shaderProgramsCodeName: "" };
}
function JU(i) {
  const e = ws(i), t = () => e.iTime.value += e.speed.value, n = {
    vertexHeader: Ts,
    fragHeader: Xn(e) + ` varying vec2 vUv; 
`,
    fragBody: `
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            vec3 wave_color = vec3(0.0);
            float wave_width = 0.0;
            uv  = -3.0 + 2.0 * uv;
            uv.y += 0.0;
            if(hasUv) uv = vUv;
            for(float i = 0.0; i <= 28.0; i++) {
                uv.y += (0.2+(0.9*sin(iTime*0.4) * sin(uv.x + i/3.0 + 3.0 *iTime )));
                uv.x += 1.7* sin(iTime*0.4);
                wave_width = abs(1.0 / (200.0*abs(cos(iTime)) * uv.y));
                wave_color += vec3(wave_width *( 0.4+((i+1.0)/18.0)), wave_width * (i / 9.0), wave_width * ((i+1.0)/ 8.0) * 1.9);
            }
        `,
    pointFragIn: "vec3 effect_color = wave_color;",
    lightFragEnd: "vec4 diffuseColor = vec4( mix(diffuse, wave_color * mixColor * vec3(intensity, intensity, intensity) , mixRatio), opacity );"
  };
  return { uniforms: e, glslProps: n, ShaderAnimateRender: t, shaderProgramsCodeName: "" };
}
function eF(i) {
  const e = {
    iResolution: { type: "vec2", value: new k(i.clientWidth, i.clientHeight), unit: "vec2" },
    iTime: { type: "number", value: 1, unit: "float" },
    speed: { type: "number", value: 0.05, unit: "float" },
    intensity: { type: "number", unit: "float", value: 2 },
    density: { type: "number", unit: "float", value: 5 },
    mixColor: { type: "color", unit: "vec3", value: new Q(16777215) },
    high: { type: "number", unit: "float", value: 0.5 }
  }, t = () => e.iTime.value += e.speed.value, n = {
    vertexHeader: Ts,
    fragHeader: Xn(e) + `varying vec2 vUv; 
`,
    fragBody: `
            float t = gl_FragCoord.y / iResolution.y;
            vec4 fragColor = vec4(0.);
            float siny = sin((vUv.y - iTime * speed) * 10. * density);
            if (siny > high) {
              fragColor = vec4( mixColor, (siny - high));
            }  else {
               fragColor = vec4(mixColor, 0.);
            }
            fragColor = mix(fragColor, vec4(mix(mixColor, vec3(0., 0., 0.), vUv.y), 1.), 0.);
        `,
    lightFragEnd: " vec4 diffuseColor = vec4(fragColor.rgb * vec3(intensity, intensity, intensity),  fragColor.a * opacity * (1. - vUv.y));"
  };
  return { uniforms: e, glslProps: n, ShaderAnimateRender: t, shaderProgramsCodeName: "2" };
}
function tF(i) {
  const e = ws(i), t = () => e.iTime.value += e.speed.value, n = {
    vertexHeader: Ts,
    fragHeader: Xn(e) + `varying vec2 vUv; 
`,
    fragFunc: `
            vec3 hsv2rgb( vec3 c ){
                vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                                        6.0)-3.0)-1.0,
                                0.0,
                                1.0 );
                rgb = rgb*rgb*(3.0-2.0*rgb);
                return c.z * mix(vec3(1.0), rgb, c.y);
            }
            float rands(vec2 v){
                v = fract(v * vec2(70.26593, 1.6682));
                v += dot(v, v+23.45);
                return fract(v.x*v.y);
            }
            vec2 rand_2(vec2 v){
                float n = rands(v);
                return vec2(n, rands(v + n));
            }
            float dist_line(vec2 which, vec2 p1, vec2 p2){
                float r = clamp(dot(which - p1, p2 - p1) / dot(p2 - p1, p2 - p1), .0, 1.);
                return length((which - p1)-(p2 - p1)*r);
            }
            float drawline(vec2 which, vec2 p1, vec2 p2, float w){
                float dis = dist_line(which, p1, p2);
                return smoothstep(.015*w, .005*w, dis)*smoothstep(.8, .0, distance(p1, p2)-.25);
            }
            vec2 Getpos(vec2 v){
                vec2 p = rand_2(v);
                return vec2(.5)+.4*vec2(cos(p.x*(iTime+5.)), sin(p.y*(iTime+5.)));
            }
            vec3 layer(vec2 uv, float w){
                float m=.0;
                vec2 fl_uv = floor(uv);
                vec2 fr_uv = fract(uv);
                vec2 id = Getpos(fl_uv);
                m = smoothstep(.08*w, .01*w, distance(fr_uv, id))*abs(sin((iTime+id.x)*4.));
                vec2 p[9];
                int num = 0;
                for(float i=-1.; i<=1.; i++){
                    for(float j=-1.; j<=1.; j++){
                        p[num++] = vec2(i,j)+Getpos(fl_uv + vec2(i,j));
                    }
                }
                for(int i=0; i<9; i++){
                m += drawline(fr_uv, p[4], p[i], w);
                }
                m += drawline(fr_uv, p[1], p[3], w);
                m += drawline(fr_uv, p[1], p[5], w);
                m += drawline(fr_uv, p[3], p[7], w);
                m += drawline(fr_uv, p[5], p[7], w);
                return vec3(m);
            }
        `,
    fragBody: `
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            if(hasUv) uv *= vUv;
            float yy = uv.y;
            uv -= .5;
            uv.x *= iResolution.x / iResolution.y;
            uv *= .5;
            float t = iTime*.1;
            float rs = sin(2.*t);
            float rc = cos(2.*t);
            uv *= mat2(rc, -rs, rs, rc);
            float m = .0;
            vec3 v3 = vec3(1.);
            vec2 fl_uv = floor(uv);
            vec2 fr_uv = fract(uv);
            
            vec2 id = Getpos(fl_uv);
            vec3 col = vec3(.0);
            
            for(float i=.0; i<1.; i+=1./8.){
                float z = fract(i+t);
                float size = mix(10., .5, z);
                float al = smoothstep(.0, .8, z) * smoothstep(1., .8, z);
                v3 = 0.5 + 0.5*cos(-1.2*z+iTime+uv.xyx+vec3(0,2,4));
            col += layer(uv*size + i*27.385, 1.)*al*v3;
            col += layer(uv*size + i*27.385, .4)*pow(al, 2.);
            }
            //col *= smoothstep(1., .7, yy)*smoothstep(.0, .3, yy);
            v3 = 0.5 + 0.5*cos(iTime-1.2+uv.xyx+vec3(0,2,4));
            col += vec3(.8*yy)*.3*v3;
            col += vec3(.2*(1.-yy))*.3*v3;
        `,
    pointFragIn: "vec3 effect_color = col;",
    lightFragEnd: "vec4 diffuseColor = vec4( mix(diffuse, col * mixColor * vec3(intensity, intensity, intensity) , mixRatio), opacity );"
  };
  return { uniforms: e, glslProps: n, ShaderAnimateRender: t, shaderProgramsCodeName: "" };
}
const nF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getBrilliantLineShader: tF,
  getCircularRayLight: ZU,
  getCrystalShader: $U,
  getFenceShader: KU,
  getGradientFenceShader: eF,
  getRainbowShader: YU,
  getSelfGlowShader: JU,
  getSnowShader: QU,
  getWaterLinesShader: jU
}, Symbol.toStringTag, { value: "Module" }));
function iF(i) {
  const e = ws(i), t = () => e.iTime.value += e.speed.value, n = {
    vertexHeader: Ts,
    fragHeader: Xn(e) + `varying vec2 vUv; 
`,
    fragFunc: `
            float hash11(float p)
            {
                p = fract(p * .1031);
                p *= p + 33.33;
                p *= p + p;
                return fract(p);
            }
            float hash12(vec2 p)
            {
                vec3 p3 = fract(vec3(p.xyx) * .1031);
                p3 += dot(p3, p3.yzx + 33.33);
                return fract((p3.x + p3.y) * p3.z);
            }
            mat2 rotate2d(float theta)
            {
                float c = cos(theta);
                float s = sin(theta);
                return mat2(
                    c, -s,
                    s, c
                );
            }
            float noise(vec2 p)
            {
                vec2 ip = floor(p);
                vec2 fp = fract(p);
                float a = hash12(ip);
                float b = hash12(ip + vec2(1, 0));
                float c = hash12(ip + vec2(0, 1));
                float d = hash12(ip + vec2(1, 1));
                
                vec2 t = smoothstep(0.0, 1.0, fp);
                return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);
            }
            float fbm(vec2 p)
            {
                float value = 0.0;
                float amplitude = 0.5;
                for (int i = 0; i < 8; ++i)
                {
                    value += amplitude * noise(p);
                    p *= rotate2d(0.45);
                    p *= 2.0;
                    amplitude *= 0.5;
                }
                return value;
            }
        `,
    fragBody: `
            vec2 uv = gl_FragCoord.xy / iResolution.xy; 
            if (hasUv) uv *= vUv;
            uv = 2.0 * uv - 1.0;
            uv.x *= iResolution.x / iResolution.y;
            uv += 2.0 * fbm(uv+0.8*iTime) - 1.0;
            float dist = abs(uv.x);
            vec3 col = vec3(0.2, 0.3, 0.8) * pow(mix(0.0, 0.07, hash11(iTime)) / dist, 1.0);
            col = pow(col, vec3(1.0));  
        `,
    pointFragIn: "vec3 effect_color = col;",
    lightFragEnd: " vec4 diffuseColor = vec4( mix(diffuse, col * mixColor * vec3(intensity, intensity, intensity) , mixRatio), opacity );"
  };
  return { uniforms: e, glslProps: n, ShaderAnimateRender: t, shaderProgramsCodeName: "" };
}
function sF(i) {
  const e = ws(i), t = () => e.iTime.value += e.speed.value, n = {
    vertexHeader: Ts,
    fragHeader: Xn(e) + `varying vec2 vUv; 
`,
    fragFunc: `
            const vec3 c = vec3(1, 0, -1);
            const mat2 m = .4 * mat2(4, 3, -3, 4);
            float hash12(vec2 p)
            {
                vec3 p3  = fract(vec3(p.xyx) * .1031);
                p3 += dot(p3, p3.yzx + 33.33);
                return fract(dot(p3.xy, p3.zz));
            }
            float lfnoise(vec2 t)
            {
                vec2 i = floor(t);
                t = c.xx * smoothstep(0., 1., fract(t));
                vec2 v1 = 2. * mix(vec2(hash12(i), hash12(i + c.xy)), vec2(hash12(i + c.yx), hash12(i + c.xx)), t.y) - 1.;
                return mix(v1.x, v1.y, t.x);
            }
            float fbm(vec2 uv)
            {
                vec2 uv0 = uv;
                uv = uv * vec2(5., 2.) - vec2(-2., -.25) - 3.1 * iTime * c.yx;
                float f = 1.,
                    a = .5,
                    c = 2.5;
                
                for(int i = 0; i < 5; ++i) {
                    uv.x -= .15 * clamp(1. - pow(uv0.y, 4.), 0., 1.) * lfnoise(c * (uv + float(i) * .612 + iTime));
                    c *= 2.;
                    f += a * lfnoise(uv + float(i) * .415);
                    a /= 2.;
                    uv *= m;
                }
                return f / 2.;
            }
            `,
    fragBody: `
            vec2 uv = gl_FragCoord.xy / iResolution.xy; 
            if (hasUv) uv *= vUv;
            vec3 col = clamp(1.5 * pow(clamp(pow(fbm(uv), 1. + 4. * clamp(uv.y * uv.y, 0., 1.)) * 1.5, 0., 1.) * c.xxx, vec3(1, 3, 6)), 0., 1.);
        `,
    pointFragIn: "vec3 effect_color = col;",
    lightFragEnd: "vec4 diffuseColor = vec4( mix(diffuse, col * mixColor * vec3(intensity, intensity, intensity) , mixRatio), opacity );"
  };
  return { uniforms: e, glslProps: n, ShaderAnimateRender: t, shaderProgramsCodeName: "" };
}
function rF(i) {
  const e = ws(i), t = () => e.iTime.value += e.speed.value, n = {
    vertexHeader: Ts,
    fragHeader: Xn(e) + `varying vec2 vUv; 
`,
    fragFunc: `
            vec3 palette( float t ) {
                vec3 a = vec3(0.5, 0.5, 0.5);
                vec3 b = vec3(0.5, 0.5, 0.5);
                vec3 c = vec3(1.0, 1.0, 1.0);
                vec3 d = vec3(0.263,0.416,0.557);
            
                return a + b*cos( 6.28318*(c*t+d) );
            }
        `,
    fragBody: `
            vec2 vv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
            if (hasUv) vv = vUv;
            vec2 vv0 = vv;
            vec3 finalColor = vec3(0.0);
            for (float i = 0.0; i < 4.0; i++) {
                vv = fract(vv * 1.5) - 0.5;
                float d = length(vv) * exp(-length(vv0));
                vec3 col = palette(length(vv0) + i*.4 + iTime*.4);
                d = sin(d*8. + iTime)/8.;
                d = abs(d);
                d = pow(0.01 / d, 1.2);
                finalColor += col * d;
            }
        `,
    pointFragIn: "vec3 effect_color = finalColor;",
    lightFragEnd: "vec4 diffuseColor = vec4( mix(diffuse, finalColor * mixColor * vec3(intensity, intensity, intensity) , mixRatio), opacity );"
  };
  return { uniforms: e, glslProps: n, ShaderAnimateRender: t, shaderProgramsCodeName: "" };
}
function aF(i) {
  const e = {
    topColor: { value: new Q(30719), type: "color", unit: "vec3" },
    bottomColor: { value: new Q("aliceblue"), type: "color", unit: "vec3" },
    offset: { value: 400, type: "number", unit: "float" },
    exponent: { value: 0.6, type: "number", unit: "float" },
    ...ws(i)
  }, t = () => e.iTime.value += e.speed.value, n = {
    vertexHeader: `
            varying vec3 vWorldPosition;
            void main() {
                vec4 sworldPosition = modelMatrix * vec4( position, 1.0 );
                vWorldPosition = sworldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`,
    fragHeader: Xn(e) + `varying vec2 vUv; 
varying vec3 vWorldPosition; 
`,
    fragBody: `
            float h = normalize( vWorldPosition + offset ).y;
            vec4 diffuseColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0 ), exponent ), 0.0 ) ), 1.0 );
        `
  };
  return { uniforms: e, glslProps: n, ShaderAnimateRender: t, shaderProgramsCodeName: "" };
}
function oF(i) {
  const e = {
    EPSILON: { value: 1e-3, type: "number", unit: "float" },
    SEA_BASE: { value: new Q(0.11, 0.19, 0.22), type: "color", unit: "vec3" },
    SEA_WATER_COLOR: { value: new Q(0.55, 0.9, 0.7), type: "color", unit: "vec3" },
    NUM_STEPS: { value: 6, type: "number", unit: "int" },
    ITER_GEOMETRY: { value: 2, type: "number", unit: "int" },
    ITER_FRAGMENT: { value: 5, type: "number", unit: "int" },
    SEA_HEIGHT: { value: 0.5, type: "number", unit: "float" },
    SEA_CHOPPY: { value: 3, type: "number", unit: "float" },
    SEA_SPEED: { value: 1.9, type: "number", unit: "float" },
    SEA_FREQ: { value: 0.24, type: "number", unit: "float" },
    iResolution: { type: "vec2", value: new k(i.clientWidth, i.clientHeight), unit: "vec2" },
    iTime: { type: "number", value: 1, unit: "float" },
    speed: { type: "number", value: 0.01, unit: "float" },
    intensity: { type: "number", unit: "float", value: 1 },
    hasUv: { type: "bool", unit: "bool", value: !1 }
  }, t = () => e.iTime.value += e.speed.value, n = {
    vertexHeader: Ts,
    fragHeader: Xn(e) + `varying vec2 vUv; 
`,
    fragFunc: `
            #define  EPSILON_NRM (1. / iResolution.x)
            #define SEA_TIME (iTime * SEA_SPEED)
            mat2 octave_m = mat2(1.7,1.2,-1.2,1.4);
            const float KEY_SP    = 32.5/256.0;
            vec3 rgb2hsv(vec3 c)
            {
                vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
                vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
                float d = q.x - min(q.w, q.y);
                float e = 1.0e-10;
                return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
            }
            vec3 hsv2rgb(vec3 c)
            {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            mat3 fromEuler(vec3 ang) {
                vec2 a1 = vec2(sin(ang.x),cos(ang.x));
                vec2 a2 = vec2(sin(ang.y),cos(ang.y));
                vec2 a3 = vec2(sin(ang.z),cos(ang.z));
                mat3 m;
                m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);
                m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);
                m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);
                return m;
            }
            float hash( vec2 p ) {
                float h = dot(p,vec2(127.1,311.7));	
                return fract(sin(h)*83758.5453123);
            }
            
            float noise( in vec2 p ) {
                vec2 i = floor( p );
                vec2 f = fract( p );	
                vec2 u = f*f*(3.0-2.0*f);
                return -1.0+2.0*mix( 
                            mix( hash( i + vec2(0.0,0.0) ), 
                                hash( i + vec2(1.0,0.0) ), 
                                    u.x),
                            mix( hash( i + vec2(0.0,1.0) ), 
                                hash( i + vec2(1.0,1.0) ), 
                                    u.x), 
                            u.y);
            }
            float diffuseL(vec3 n,vec3 l,float p) {
                return pow(dot(n,l) * 0.4 + 0.6,p);
            }
            float specularS(vec3 n,vec3 l,vec3 e,float s) {    
                float nrm = (s + 8.0) / (3.1415 * 8.0);
                return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;
            }
            
            float sea_octave(vec2 uv, float choppy) {
                uv += noise(uv);
                vec2 wv = 1.0-abs(sin(uv)); 
                vec2 swv = abs(cos(uv));  
                wv = mix(wv,swv,wv);
                return pow(1.0-pow(wv.x * wv.y,0.65),choppy);
            }
            float mapL(vec3 p) {
                float freq = SEA_FREQ;
                float amp = SEA_HEIGHT;
                float choppy = SEA_CHOPPY;
                vec2 uv = p.xz; uv.x *= 0.75;
                
                float d, h = 0.0;    
                for(int i = 0; i < ITER_GEOMETRY; i++) {
                    d = sea_octave((uv+iTime)*freq,choppy);
                    h += d * amp; 
                    uv *=  octave_m;   
                    freq *= 1.9; 
                    amp *= 0.22;
                    choppy = mix(choppy,1.0,0.2);
                }
                return p.y - h;
            }
            float map_detailed(vec3 p) {
                float freq = SEA_FREQ;
                float amp = SEA_HEIGHT;
                float choppy = SEA_CHOPPY;
                vec2 uv = p.xz; uv.x *= 0.75;
                float d, h = 0.0;    
                for(int i = 0; i < ITER_FRAGMENT; i++) {
                    d = sea_octave((uv+iTime)*freq,choppy);
                    d += sea_octave((uv-iTime)*freq,choppy);
                    h += d * amp; 
                    uv *= octave_m/1.2;
                    freq *= 1.9;
                    amp *= 0.22;
                    choppy = mix(choppy,1.0,0.2);
                }
                return p.y - h;
            }
            vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  
                float fresnel = 1.0 - max(dot(n,-eye),0.0);
                fresnel = pow(fresnel,3.0) * 0.45;
                vec3 refracted = SEA_BASE + diffuseL(n,l,80.0) * SEA_WATER_COLOR * 0.27; 
                vec3 color = refracted;
                float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);
                color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.15 * atten;
                color += vec3(specularS(n,l,eye,90.0))*0.5;
                return color;
            }
            vec3 getNormal(vec3 p, float eps) {
                vec3 n;
                n.y = map_detailed(p);
                n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y; 
                n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;
                n.y = eps; 
                return normalize(n);
            }
            float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
                float tm = 0.0;
                float tx = 500.0; 
                float hx = mapL(ori + dir * tx);
                if(hx > 0.0) return tx;   
                float hm = mapL(ori + dir * tm); 
                float tmid = 0.0;
                for(int i = 0; i < NUM_STEPS; i++) { 
                    tmid = mix(tm,tx, hm/(hm-hx));
                    p = ori + dir * tmid; 
                            
                    float hmid = mapL(p); 
                    if(hmid < 0.0) { 
                        tx = tmid;
                        hx = hmid;
                    } else {
                        tm = tmid;
                        hm = hmid;
                    }
                }
                return tmid;
            }
        `,
    fragBody: `
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            uv.y -= 2.0;
            if (hasUv) uv = vUv;
            float time = iTime * 0.0;
            float roll = PI + sin(iTime)/14.0 + cos(iTime/2.0)/14.0 ;
            float pitch = PI*1.021 + (sin(iTime/2.0)+ cos(iTime))/40.0 
                + (1./iResolution.y - .8)*PI/3.0  ;
            float yaw = 1./iResolution.x * PI * 4.0;
            vec3 ang = vec3(roll,pitch,yaw);
            vec3 ori = vec3(0.0,3.5,time*3.0);
            vec3 dir = normalize(vec3(uv.xy,-1.6)); 
            dir = normalize(dir) * fromEuler(ang);
            vec3 p;
            heightMapTracing(ori,dir,p);
            vec3 dist = p - ori;
            vec3 n = getNormal(p,  dot(dist,dist)  * EPSILON_NRM  );
            vec3 light = normalize(vec3(0.0,1.0,0.8)); 
            vec3 seaColor = getSeaColor(p,n,light,dir,dist);
        `,
    lightFragEnd: "vec4 diffuseColor = vec4( seaColor * vec3(intensity, intensity, intensity), opacity );"
  };
  return { uniforms: e, glslProps: n, ShaderAnimateRender: t, shaderProgramsCodeName: "" };
}
function d1(i, e) {
  const t = {
    iResolution: { type: "vec2", value: new k(i.clientWidth, i.clientHeight), unit: "vec2" },
    iTime: { type: "number", value: 1, unit: "float" },
    speed: { type: "number", value: 0.01, unit: "float" },
    intensity: { type: "number", unit: "float", value: 1 },
    mixRatio: { type: "number", unit: "float", value: 0.5 },
    mixColor: { type: "color", unit: "vec3", value: new Q(16777215) },
    hasUv: { type: "bool", unit: "bool", value: !1 },
    HEAT_MAX: { value: 10, type: "number", unit: "float" },
    PointRadius: { value: 0.42, type: "number", unit: "float" },
    PointsCount: { value: 1, type: "number-array", unit: "int" },
    c1: { value: new Q(0), type: "color", unit: "vec3" },
    c2: { value: new Q(0), type: "color", unit: "vec3" },
    uvY: { value: 1, type: "number", unit: "float" },
    uvX: { value: 1, type: "number", unit: "float" }
  }, n = { Points: { value: [new T(0, 0, 10)], type: "vec3-array", unit: "vec3" } }, s = { ...t, ...n };
  e && Object.keys(e).forEach((l) => s[l].value = e[l].value);
  const r = () => s.iTime.value += s.speed.value, a = {
    vertexHeader: `varying vec2 vUv; 
 void main() { 
 vUv = uv;`,
    fragHeader: Object.keys(t).map((l) => "uniform " + s[l].unit + " " + l + ";").join(`
`) + `varying vec2 vUv; 
uniform vec3 Points[` + t.PointsCount.value + `];
             vec3 gradient(float w, vec2 uv) {
                w = pow(clamp(w, 0., 1.) * 3.14159 * .5, .9);
                return vec3(sin(w), sin(w * 2.), cos(w))* 1.1 + mix(c1, c2, w) * 1.1; 
            }
        `,
    fragBody: `
            vec2 uv = (2. * gl_FragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);
            if (hasUv) uv = vUv;
            uv.xy *= vec2(uvX, uvY);
            float d = 0.;
            for (int i = 0; i < PointsCount; i++) {
                vec3 v = Points[i];
                float intensity = v.z / HEAT_MAX;
                float pd = (1. - length(uv - v.xy) / PointRadius) * intensity;
                d += pow(max(0., pd), 2.);
            }
            vec3 c = gradient(d, uv);
        `,
    lightFragEnd: "vec4 diffuseColor = vec4( mix(diffuse, c * mixColor * vec3(intensity, intensity, intensity) , mixRatio), opacity );"
  };
  function o(l) {
    return d1(i, l);
  }
  return { uniforms: s, glslProps: a, ShaderAnimateRender: r, updateShaderProgram: o, shaderProgramsCodeName: "" };
}
const lF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getFireShader: sF,
  getHeatMapShader: d1,
  getLightningShader: iF,
  getShaderSky: aF,
  getShaderWaterPlane: oF,
  getStreamerGrid: rF
}, Symbol.toStringTag, { value: "Module" })), It = { ...nF, ...lF }, Zu = {
  : It.getRainbowShader,
  : It.getWaterLinesShader,
  : It.getCircularRayLight,
  : It.getCrystalShader,
  : It.getFenceShader,
  2: It.getGradientFenceShader,
  : It.getSnowShader,
  : It.getSelfGlowShader,
  : It.getBrilliantLineShader,
  : It.getLightningShader,
  : It.getFireShader,
  : It.getStreamerGrid,
  : It.getShaderSky,
  : It.getShaderWaterPlane,
  : It.getHeatMapShader
}, f1 = {
  : It.getRainbowShader,
  : It.getWaterLinesShader,
  : It.getSnowShader,
  : It.getSelfGlowShader,
  : It.getBrilliantLineShader,
  : It.getLightningShader,
  : It.getFireShader,
  : It.getStreamerGrid
};
function Jg(i, e) {
  let t;
  if (i.RootMaterials ? t = i.RootMaterials : i.material && (Array.isArray(i.material) ? t = i.material : t = [i.material]), !t) return;
  const { glslProps: n, uniforms: s, ShaderAnimateRender: r } = e;
  return i.ShaderAnimateRender = r, i.uniforms = s, t.forEach((a) => uy(a, s, n)), i.destroyShaderProgram = () => {
    t.forEach((a) => {
      a.onBeforeCompile = () => {
      }, a.dispose(), a.needsUpdate = !0;
    }), delete i.ShaderAnimateRender, delete i.destroyShaderProgram;
  }, i.updateShaderProgram = () => {
    let a = e.updateShaderProgram(i.uniforms);
    t.forEach((o) => uy(o, a.uniforms, a.glslProps));
  }, i;
}
function uy(i, e, t) {
  return i.dispose(), i.onBeforeCompile = (n) => {
    Object.keys(e).forEach((s) => n.uniforms[s] = e[s]), t.vertexHeader && (n.vertexShader = n.vertexShader.replace("void main() {", t.vertexHeader)), n.fragmentShader = n.fragmentShader.replace(/#include <common>/, t.fragHeader + `
#include <common>
` + (t.fragFunc || "")), n.fragmentShader = n.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );", t.fragBody + (t.lightFragEnd || ""));
  }, i.needsUpdate = !0, i;
}
function ws(i) {
  return {
    iResolution: { type: "vec2", value: new k(i.clientWidth, i.clientHeight), unit: "vec2" },
    iTime: { type: "number", value: 1, unit: "float" },
    speed: { type: "number", value: 0.01, unit: "float" },
    intensity: { type: "number", unit: "float", value: 1 },
    mixRatio: { type: "number", unit: "float", value: 0.5 },
    mixColor: { type: "color", unit: "vec3", value: new Q(16777215) },
    hasUv: { type: "bool", unit: "bool", value: !1 }
  };
}
const Ts = `varying vec2 vUv; 
 void main() { 
 vUv = uv;`;
function Xn(i) {
  return Object.keys(i).map((e) => "uniform " + i[e].unit + " " + e + ";").join(`
`);
}
function p1(i) {
  if (i)
    return Object.keys(i).filter(
      (e) => ["color", "position", "opacity", "number", "bool"].includes(i[e].type)
    ).reduce(
      (e, t) => ({ ...e, [t]: i[t].value }),
      {}
    );
}
function m1(i, e) {
  e && Object.keys(e).forEach((t) => {
    if (i[t]) switch (i[t].type) {
      case "color":
        i[t].value.set(e[t]);
        break;
      case "number":
        i[t].value = e[t];
        break;
      case "opacity":
        i[t].value = e[t];
        break;
      case "position":
        i[t].value.set(e[t].x, e[t].y, e[t].z);
        break;
      case "bool":
        i[t].value = e[t];
        break;
    }
  });
}
function gm(i, e) {
  return Object.keys(i).forEach((t) => {
    switch (i[t].type) {
      case "number":
        const n = e.add(i[t], "value").name(t);
        Reflect.has(i[t], "min") && n.min(i[t].min), Reflect.has(i[t], "max") && n.max(i[t].max);
        break;
      case "color":
        e.addColor({ value: i[t].value.getHex() }, "value").onChange((s) => i[t].value = new Q(s)).name(t);
        break;
      case "opacity":
        e.add(i[t], "value").min(0).max(1).name(t);
        break;
      case "position":
        ["x", "y", "z"].forEach((s) => e.add(i[t].value, s).name(t + "-" + s));
        break;
      case "bool":
        e.add(i[t], "value").name(t);
        break;
    }
  }), e;
}
const $u = {
  DOM: null,
  ShaderList: null
};
function cF(i, e) {
  $u.ShaderList = i, $u.DOM = e;
}
function hF(i) {
  const { blendShaderPrograms: e } = i;
  if (e)
    return {
      shaderProgramsCodeName: e.shaderProgramsCodeName,
      isBlendShaderPrograms: e.isBlendShaderPrograms,
      uniforms: p1(i.uniforms)
    };
}
function uF(i, e) {
  if (!e) return;
  i.blendShaderPrograms = e;
  const { DOM: t, ShaderList: n } = $u, { shaderProgramsCodeName: s, isBlendShaderPrograms: r, uniforms: a } = e;
  if (!r) return;
  const o = Zu[s](t);
  n.push(Jg(i, o)), m1(i.uniforms, a);
}
function e0(i, e) {
  i.blendShaderPrograms = {
    shaderProgramsCodeName: e,
    isBlendShaderPrograms: !0,
    uniforms: null
  };
  const { DOM: t, ShaderList: n } = $u, s = Zu[e](t);
  n.push(Jg(i, s));
}
function g1(i, e, t, n) {
  let s = null;
  t.blendShaderPrograms ? t.uniforms && (s = gm(t.uniforms, n.addFolder(t.blendShaderPrograms.shaderProgramsCodeName + ""))) : t.blendShaderPrograms = {
    shaderProgramsCodeName: "",
    isBlendShaderPrograms: !1,
    uniforms: null
  };
  const { blendShaderPrograms: r } = t;
  n.add(r, "shaderProgramsCodeName", Object.keys(Zu)).name(""), n.add(r, "isBlendShaderPrograms").name("").onChange((a) => {
    if (a) {
      if (r.shaderProgramsCodeName) {
        const o = Zu[r.shaderProgramsCodeName](e);
        i.push(Jg(t, o)), s = gm(o.uniforms, n.addFolder(r.shaderProgramsCodeName + ""));
      }
    } else {
      const o = i.findIndex((l) => l.uuid == t.uuid);
      o !== -1 && (i.splice(o, 1), t.destroyShaderProgram(), s && n.removeFolder(s));
    }
  });
}
function dF(i) {
  if (!(typeof window > "u")) {
    var e = document.createElement("style");
    return e.setAttribute("type", "text/css"), e.innerHTML = i, document.head.appendChild(e), i;
  }
}
function To(i, e) {
  var t = i.__state.conversionName.toString(), n = Math.round(i.r), s = Math.round(i.g), r = Math.round(i.b), a = i.a, o = Math.round(i.h), l = i.s.toFixed(1), c = i.v.toFixed(1);
  if (e || t === "THREE_CHAR_HEX" || t === "SIX_CHAR_HEX") {
    for (var h = i.hex.toString(16); h.length < 6; )
      h = "0" + h;
    return "#" + h;
  } else {
    if (t === "CSS_RGB")
      return "rgb(" + n + "," + s + "," + r + ")";
    if (t === "CSS_RGBA")
      return "rgba(" + n + "," + s + "," + r + "," + a + ")";
    if (t === "HEX")
      return "0x" + i.hex.toString(16);
    if (t === "RGB_ARRAY")
      return "[" + n + "," + s + "," + r + "]";
    if (t === "RGBA_ARRAY")
      return "[" + n + "," + s + "," + r + "," + a + "]";
    if (t === "RGB_OBJ")
      return "{r:" + n + ",g:" + s + ",b:" + r + "}";
    if (t === "RGBA_OBJ")
      return "{r:" + n + ",g:" + s + ",b:" + r + ",a:" + a + "}";
    if (t === "HSV_OBJ")
      return "{h:" + o + ",s:" + l + ",v:" + c + "}";
    if (t === "HSVA_OBJ")
      return "{h:" + o + ",s:" + l + ",v:" + c + ",a:" + a + "}";
  }
  return "unknown format";
}
var dy = Array.prototype.forEach, Al = Array.prototype.slice, ne = {
  BREAK: {},
  extend: function(e) {
    return this.each(Al.call(arguments, 1), function(t) {
      var n = this.isObject(t) ? Object.keys(t) : [];
      n.forEach((function(s) {
        this.isUndefined(t[s]) || (e[s] = t[s]);
      }).bind(this));
    }, this), e;
  },
  defaults: function(e) {
    return this.each(Al.call(arguments, 1), function(t) {
      var n = this.isObject(t) ? Object.keys(t) : [];
      n.forEach((function(s) {
        this.isUndefined(e[s]) && (e[s] = t[s]);
      }).bind(this));
    }, this), e;
  },
  compose: function() {
    var e = Al.call(arguments);
    return function() {
      for (var t = Al.call(arguments), n = e.length - 1; n >= 0; n--)
        t = [e[n].apply(this, t)];
      return t[0];
    };
  },
  each: function(e, t, n) {
    if (e) {
      if (dy && e.forEach && e.forEach === dy)
        e.forEach(t, n);
      else if (e.length === e.length + 0) {
        var s = void 0, r = void 0;
        for (s = 0, r = e.length; s < r; s++)
          if (s in e && t.call(n, e[s], s) === this.BREAK)
            return;
      } else
        for (var a in e)
          if (t.call(n, e[a], a) === this.BREAK)
            return;
    }
  },
  defer: function(e) {
    setTimeout(e, 0);
  },
  debounce: function(e, t, n) {
    var s = void 0;
    return function() {
      var r = this, a = arguments;
      function o() {
        s = null, n || e.apply(r, a);
      }
      var l = n || !s;
      clearTimeout(s), s = setTimeout(o, t), l && e.apply(r, a);
    };
  },
  toArray: function(e) {
    return e.toArray ? e.toArray() : Al.call(e);
  },
  isUndefined: function(e) {
    return e === void 0;
  },
  isNull: function(e) {
    return e === null;
  },
  isNaN: function(i) {
    function e(t) {
      return i.apply(this, arguments);
    }
    return e.toString = function() {
      return i.toString();
    }, e;
  }(function(i) {
    return isNaN(i);
  }),
  isArray: Array.isArray || function(i) {
    return i.constructor === Array;
  },
  isObject: function(e) {
    return e === Object(e);
  },
  isNumber: function(e) {
    return e === e + 0;
  },
  isString: function(e) {
    return e === e + "";
  },
  isBoolean: function(e) {
    return e === !1 || e === !0;
  },
  isFunction: function(e) {
    return e instanceof Function;
  }
}, fF = [
  {
    litmus: ne.isString,
    conversions: {
      THREE_CHAR_HEX: {
        read: function(e) {
          var t = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
          return t === null ? !1 : {
            space: "HEX",
            hex: parseInt("0x" + t[1].toString() + t[1].toString() + t[2].toString() + t[2].toString() + t[3].toString() + t[3].toString(), 0)
          };
        },
        write: To
      },
      SIX_CHAR_HEX: {
        read: function(e) {
          var t = e.match(/^#([A-F0-9]{6})$/i);
          return t === null ? !1 : {
            space: "HEX",
            hex: parseInt("0x" + t[1].toString(), 0)
          };
        },
        write: To
      },
      CSS_RGB: {
        read: function(e) {
          var t = e.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
          return t === null ? !1 : {
            space: "RGB",
            r: parseFloat(t[1]),
            g: parseFloat(t[2]),
            b: parseFloat(t[3])
          };
        },
        write: To
      },
      CSS_RGBA: {
        read: function(e) {
          var t = e.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
          return t === null ? !1 : {
            space: "RGB",
            r: parseFloat(t[1]),
            g: parseFloat(t[2]),
            b: parseFloat(t[3]),
            a: parseFloat(t[4])
          };
        },
        write: To
      }
    }
  },
  {
    litmus: ne.isNumber,
    conversions: {
      HEX: {
        read: function(e) {
          return {
            space: "HEX",
            hex: e,
            conversionName: "HEX"
          };
        },
        write: function(e) {
          return e.hex;
        }
      }
    }
  },
  {
    litmus: ne.isArray,
    conversions: {
      RGB_ARRAY: {
        read: function(e) {
          return e.length !== 3 ? !1 : {
            space: "RGB",
            r: e[0],
            g: e[1],
            b: e[2]
          };
        },
        write: function(e) {
          return [e.r, e.g, e.b];
        }
      },
      RGBA_ARRAY: {
        read: function(e) {
          return e.length !== 4 ? !1 : {
            space: "RGB",
            r: e[0],
            g: e[1],
            b: e[2],
            a: e[3]
          };
        },
        write: function(e) {
          return [e.r, e.g, e.b, e.a];
        }
      }
    }
  },
  {
    litmus: ne.isObject,
    conversions: {
      RGBA_OBJ: {
        read: function(e) {
          return ne.isNumber(e.r) && ne.isNumber(e.g) && ne.isNumber(e.b) && ne.isNumber(e.a) ? {
            space: "RGB",
            r: e.r,
            g: e.g,
            b: e.b,
            a: e.a
          } : !1;
        },
        write: function(e) {
          return {
            r: e.r,
            g: e.g,
            b: e.b,
            a: e.a
          };
        }
      },
      RGB_OBJ: {
        read: function(e) {
          return ne.isNumber(e.r) && ne.isNumber(e.g) && ne.isNumber(e.b) ? {
            space: "RGB",
            r: e.r,
            g: e.g,
            b: e.b
          } : !1;
        },
        write: function(e) {
          return {
            r: e.r,
            g: e.g,
            b: e.b
          };
        }
      },
      HSVA_OBJ: {
        read: function(e) {
          return ne.isNumber(e.h) && ne.isNumber(e.s) && ne.isNumber(e.v) && ne.isNumber(e.a) ? {
            space: "HSV",
            h: e.h,
            s: e.s,
            v: e.v,
            a: e.a
          } : !1;
        },
        write: function(e) {
          return {
            h: e.h,
            s: e.s,
            v: e.v,
            a: e.a
          };
        }
      },
      HSV_OBJ: {
        read: function(e) {
          return ne.isNumber(e.h) && ne.isNumber(e.s) && ne.isNumber(e.v) ? {
            space: "HSV",
            h: e.h,
            s: e.s,
            v: e.v
          } : !1;
        },
        write: function(e) {
          return {
            h: e.h,
            s: e.s,
            v: e.v
          };
        }
      }
    }
  }
], Cl = void 0, lu = void 0, vm = function() {
  lu = !1;
  var e = arguments.length > 1 ? ne.toArray(arguments) : arguments[0];
  return ne.each(fF, function(t) {
    if (t.litmus(e))
      return ne.each(t.conversions, function(n, s) {
        if (Cl = n.read(e), lu === !1 && Cl !== !1)
          return lu = Cl, Cl.conversionName = s, Cl.conversion = n, ne.BREAK;
      }), ne.BREAK;
  }), lu;
}, fy = void 0, Ku = {
  hsv_to_rgb: function(e, t, n) {
    var s = Math.floor(e / 60) % 6, r = e / 60 - Math.floor(e / 60), a = n * (1 - t), o = n * (1 - r * t), l = n * (1 - (1 - r) * t), c = [[n, l, a], [o, n, a], [a, n, l], [a, o, n], [l, a, n], [n, a, o]][s];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function(e, t, n) {
    var s = Math.min(e, t, n), r = Math.max(e, t, n), a = r - s, o = void 0, l = void 0;
    if (r !== 0)
      l = a / r;
    else
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    return e === r ? o = (t - n) / a : t === r ? o = 2 + (n - e) / a : o = 4 + (e - t) / a, o /= 6, o < 0 && (o += 1), {
      h: o * 360,
      s: l,
      v: r / 255
    };
  },
  rgb_to_hex: function(e, t, n) {
    var s = this.hex_with_component(0, 2, e);
    return s = this.hex_with_component(s, 1, t), s = this.hex_with_component(s, 0, n), s;
  },
  component_from_hex: function(e, t) {
    return e >> t * 8 & 255;
  },
  hex_with_component: function(e, t, n) {
    return n << (fy = t * 8) | e & ~(255 << fy);
  }
}, pF = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
  return typeof i;
} : function(i) {
  return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i;
}, Yi = function(i, e) {
  if (!(i instanceof e))
    throw new TypeError("Cannot call a class as a function");
}, ji = /* @__PURE__ */ function() {
  function i(e, t) {
    for (var n = 0; n < t.length; n++) {
      var s = t[n];
      s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, s.key, s);
    }
  }
  return function(e, t, n) {
    return t && i(e.prototype, t), n && i(e, n), e;
  };
}(), Nr = function i(e, t, n) {
  e === null && (e = Function.prototype);
  var s = Object.getOwnPropertyDescriptor(e, t);
  if (s === void 0) {
    var r = Object.getPrototypeOf(e);
    return r === null ? void 0 : i(r, t, n);
  } else {
    if ("value" in s)
      return s.value;
    var a = s.get;
    return a === void 0 ? void 0 : a.call(n);
  }
}, Hr = function(i, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  i.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: i,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(i, e) : i.__proto__ = e);
}, Gr = function(i, e) {
  if (!i)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : i;
}, mn = function() {
  function i() {
    if (Yi(this, i), this.__state = vm.apply(this, arguments), this.__state === !1)
      throw new Error("Failed to interpret color arguments");
    this.__state.a = this.__state.a || 1;
  }
  return ji(i, [{
    key: "toString",
    value: function() {
      return To(this);
    }
  }, {
    key: "toHexString",
    value: function() {
      return To(this, !0);
    }
  }, {
    key: "toOriginal",
    value: function() {
      return this.__state.conversion.write(this);
    }
  }]), i;
}();
function t0(i, e, t) {
  Object.defineProperty(i, e, {
    get: function() {
      return this.__state.space === "RGB" ? this.__state[e] : (mn.recalculateRGB(this, e, t), this.__state[e]);
    },
    set: function(s) {
      this.__state.space !== "RGB" && (mn.recalculateRGB(this, e, t), this.__state.space = "RGB"), this.__state[e] = s;
    }
  });
}
function n0(i, e) {
  Object.defineProperty(i, e, {
    get: function() {
      return this.__state.space === "HSV" ? this.__state[e] : (mn.recalculateHSV(this), this.__state[e]);
    },
    set: function(n) {
      this.__state.space !== "HSV" && (mn.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = n;
    }
  });
}
mn.recalculateRGB = function(i, e, t) {
  if (i.__state.space === "HEX")
    i.__state[e] = Ku.component_from_hex(i.__state.hex, t);
  else if (i.__state.space === "HSV")
    ne.extend(i.__state, Ku.hsv_to_rgb(i.__state.h, i.__state.s, i.__state.v));
  else
    throw new Error("Corrupted color state");
};
mn.recalculateHSV = function(i) {
  var e = Ku.rgb_to_hsv(i.r, i.g, i.b);
  ne.extend(i.__state, {
    s: e.s,
    v: e.v
  }), ne.isNaN(e.h) ? ne.isUndefined(i.__state.h) && (i.__state.h = 0) : i.__state.h = e.h;
};
mn.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"];
t0(mn.prototype, "r", 2);
t0(mn.prototype, "g", 1);
t0(mn.prototype, "b", 0);
n0(mn.prototype, "h");
n0(mn.prototype, "s");
n0(mn.prototype, "v");
Object.defineProperty(mn.prototype, "a", {
  get: function() {
    return this.__state.a;
  },
  set: function(e) {
    this.__state.a = e;
  }
});
Object.defineProperty(mn.prototype, "hex", {
  get: function() {
    return this.__state.space !== "HEX" && (this.__state.hex = Ku.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex;
  },
  set: function(e) {
    this.__state.space = "HEX", this.__state.hex = e;
  }
});
var Ha = function() {
  function i(e, t) {
    Yi(this, i), this.initialValue = e[t], this.domElement = document.createElement("div"), this.object = e, this.property = t, this.__onChange = void 0, this.__onFinishChange = void 0;
  }
  return ji(i, [{
    key: "onChange",
    value: function(t) {
      return this.__onChange = t, this;
    }
  }, {
    key: "onFinishChange",
    value: function(t) {
      return this.__onFinishChange = t, this;
    }
  }, {
    key: "setValue",
    value: function(t) {
      return this.object[this.property] = t, this.__onChange && this.__onChange.call(this, t), this.updateDisplay(), this;
    }
  }, {
    key: "getValue",
    value: function() {
      return this.object[this.property];
    }
  }, {
    key: "updateDisplay",
    value: function() {
      return this;
    }
  }, {
    key: "isModified",
    value: function() {
      return this.initialValue !== this.getValue();
    }
  }]), i;
}(), mF = {
  HTMLEvents: ["change"],
  MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
  KeyboardEvents: ["keydown"]
}, v1 = {};
ne.each(mF, function(i, e) {
  ne.each(i, function(t) {
    v1[t] = e;
  });
});
var gF = /(\d+(\.\d+)?)px/;
function is(i) {
  if (i === "0" || ne.isUndefined(i))
    return 0;
  var e = i.match(gF);
  return ne.isNull(e) ? 0 : parseFloat(e[1]);
}
var V = {
  makeSelectable: function(e, t) {
    e === void 0 || e.style === void 0 || (e.onselectstart = t ? function() {
      return !1;
    } : function() {
    }, e.style.MozUserSelect = t ? "auto" : "none", e.style.KhtmlUserSelect = t ? "auto" : "none", e.unselectable = t ? "on" : "off");
  },
  makeFullscreen: function(e, t, n) {
    var s = n, r = t;
    ne.isUndefined(r) && (r = !0), ne.isUndefined(s) && (s = !0), e.style.position = "absolute", r && (e.style.left = 0, e.style.right = 0), s && (e.style.top = 0, e.style.bottom = 0);
  },
  fakeEvent: function(e, t, n, s) {
    var r = n || {}, a = v1[t];
    if (!a)
      throw new Error("Event type " + t + " not supported.");
    var o = document.createEvent(a);
    switch (a) {
      case "MouseEvents": {
        var l = r.x || r.clientX || 0, c = r.y || r.clientY || 0;
        o.initMouseEvent(
          t,
          r.bubbles || !1,
          r.cancelable || !0,
          window,
          r.clickCount || 1,
          0,
          0,
          l,
          c,
          !1,
          !1,
          !1,
          !1,
          0,
          null
        );
        break;
      }
      case "KeyboardEvents": {
        var h = o.initKeyboardEvent || o.initKeyEvent;
        ne.defaults(r, {
          cancelable: !0,
          ctrlKey: !1,
          altKey: !1,
          shiftKey: !1,
          metaKey: !1,
          keyCode: void 0,
          charCode: void 0
        }), h(t, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode);
        break;
      }
      default: {
        o.initEvent(t, r.bubbles || !1, r.cancelable || !0);
        break;
      }
    }
    ne.defaults(o, s), e.dispatchEvent(o);
  },
  bind: function(e, t, n, s) {
    var r = s || !1;
    return e.addEventListener ? e.addEventListener(t, n, r) : e.attachEvent && e.attachEvent("on" + t, n), V;
  },
  unbind: function(e, t, n, s) {
    var r = s || !1;
    return e.removeEventListener ? e.removeEventListener(t, n, r) : e.detachEvent && e.detachEvent("on" + t, n), V;
  },
  addClass: function(e, t) {
    if (e.className === void 0)
      e.className = t;
    else if (e.className !== t) {
      var n = e.className.split(/ +/);
      n.indexOf(t) === -1 && (n.push(t), e.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""));
    }
    return V;
  },
  removeClass: function(e, t) {
    if (t)
      if (e.className === t)
        e.removeAttribute("class");
      else {
        var n = e.className.split(/ +/), s = n.indexOf(t);
        s !== -1 && (n.splice(s, 1), e.className = n.join(" "));
      }
    else
      e.className = void 0;
    return V;
  },
  hasClass: function(e, t) {
    return new RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1;
  },
  getWidth: function(e) {
    var t = getComputedStyle(e);
    return is(t["border-left-width"]) + is(t["border-right-width"]) + is(t["padding-left"]) + is(t["padding-right"]) + is(t.width);
  },
  getHeight: function(e) {
    var t = getComputedStyle(e);
    return is(t["border-top-width"]) + is(t["border-bottom-width"]) + is(t["padding-top"]) + is(t["padding-bottom"]) + is(t.height);
  },
  getOffset: function(e) {
    var t = e, n = { left: 0, top: 0 };
    if (t.offsetParent)
      do
        n.left += t.offsetLeft, n.top += t.offsetTop, t = t.offsetParent;
      while (t);
    return n;
  },
  isActive: function(e) {
    return e === document.activeElement && (e.type || e.href);
  }
}, _1 = function(i) {
  Hr(e, i);
  function e(t, n) {
    Yi(this, e);
    var s = Gr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), r = s;
    s.__prev = s.getValue(), s.__checkbox = document.createElement("input"), s.__checkbox.setAttribute("type", "checkbox");
    function a() {
      r.setValue(!r.__prev);
    }
    return V.bind(s.__checkbox, "change", a, !1), s.domElement.appendChild(s.__checkbox), s.updateDisplay(), s;
  }
  return ji(e, [{
    key: "setValue",
    value: function(n) {
      var s = Nr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, n);
      return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), s;
    }
  }, {
    key: "updateDisplay",
    value: function() {
      return this.getValue() === !0 ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), Nr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
    }
  }]), e;
}(Ha), vF = function(i) {
  Hr(e, i);
  function e(t, n, s) {
    Yi(this, e);
    var r = Gr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), a = s, o = r;
    if (r.__select = document.createElement("select"), ne.isArray(a)) {
      var l = {};
      ne.each(a, function(c) {
        l[c] = c;
      }), a = l;
    }
    return ne.each(a, function(c, h) {
      var u = document.createElement("option");
      u.innerHTML = h, u.setAttribute("value", c), o.__select.appendChild(u);
    }), r.updateDisplay(), V.bind(r.__select, "change", function() {
      var c = this.options[this.selectedIndex].value;
      o.setValue(c);
    }), r.domElement.appendChild(r.__select), r;
  }
  return ji(e, [{
    key: "setValue",
    value: function(n) {
      var s = Nr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, n);
      return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), s;
    }
  }, {
    key: "updateDisplay",
    value: function() {
      return V.isActive(this.__select) ? this : (this.__select.value = this.getValue(), Nr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this));
    }
  }]), e;
}(Ha), _F = function(i) {
  Hr(e, i);
  function e(t, n) {
    Yi(this, e);
    var s = Gr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), r = s;
    function a() {
      r.setValue(r.__input.value);
    }
    function o() {
      r.__onFinishChange && r.__onFinishChange.call(r, r.getValue());
    }
    return s.__input = document.createElement("input"), s.__input.setAttribute("type", "text"), V.bind(s.__input, "keyup", a), V.bind(s.__input, "change", a), V.bind(s.__input, "blur", o), V.bind(s.__input, "keydown", function(l) {
      l.keyCode === 13 && this.blur();
    }), s.updateDisplay(), s.domElement.appendChild(s.__input), s;
  }
  return ji(e, [{
    key: "updateDisplay",
    value: function() {
      return V.isActive(this.__input) || (this.__input.value = this.getValue()), Nr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
    }
  }]), e;
}(Ha);
function py(i) {
  var e = i.toString();
  return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0;
}
var y1 = function(i) {
  Hr(e, i);
  function e(t, n, s) {
    Yi(this, e);
    var r = Gr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), a = s || {};
    return r.__min = a.min, r.__max = a.max, r.__step = a.step, ne.isUndefined(r.__step) ? r.initialValue === 0 ? r.__impliedStep = 1 : r.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r.initialValue)) / Math.LN10)) / 10 : r.__impliedStep = r.__step, r.__precision = py(r.__impliedStep), r;
  }
  return ji(e, [{
    key: "setValue",
    value: function(n) {
      var s = n;
      return this.__min !== void 0 && s < this.__min ? s = this.__min : this.__max !== void 0 && s > this.__max && (s = this.__max), this.__step !== void 0 && s % this.__step !== 0 && (s = Math.round(s / this.__step) * this.__step), Nr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, s);
    }
  }, {
    key: "min",
    value: function(n) {
      return this.__min = n, this;
    }
  }, {
    key: "max",
    value: function(n) {
      return this.__max = n, this;
    }
  }, {
    key: "step",
    value: function(n) {
      return this.__step = n, this.__impliedStep = n, this.__precision = py(n), this;
    }
  }]), e;
}(Ha);
function yF(i, e) {
  var t = Math.pow(10, e);
  return Math.round(i * t) / t;
}
var Qu = function(i) {
  Hr(e, i);
  function e(t, n, s) {
    Yi(this, e);
    var r = Gr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, s));
    r.__truncationSuspended = !1;
    var a = r, o = void 0;
    function l() {
      var m = parseFloat(a.__input.value);
      ne.isNaN(m) || a.setValue(m);
    }
    function c() {
      a.__onFinishChange && a.__onFinishChange.call(a, a.getValue());
    }
    function h() {
      c();
    }
    function u(m) {
      var g = o - m.clientY;
      a.setValue(a.getValue() + g * a.__impliedStep), o = m.clientY;
    }
    function d() {
      V.unbind(window, "mousemove", u), V.unbind(window, "mouseup", d), c();
    }
    function f(m) {
      V.bind(window, "mousemove", u), V.bind(window, "mouseup", d), o = m.clientY;
    }
    return r.__input = document.createElement("input"), r.__input.setAttribute("type", "text"), V.bind(r.__input, "change", l), V.bind(r.__input, "blur", h), V.bind(r.__input, "mousedown", f), V.bind(r.__input, "keydown", function(m) {
      m.keyCode === 13 && (a.__truncationSuspended = !0, this.blur(), a.__truncationSuspended = !1, c());
    }), r.updateDisplay(), r.domElement.appendChild(r.__input), r;
  }
  return ji(e, [{
    key: "updateDisplay",
    value: function() {
      return this.__input.value = this.__truncationSuspended ? this.getValue() : yF(this.getValue(), this.__precision), Nr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
    }
  }]), e;
}(y1);
function my(i, e, t, n, s) {
  return n + (s - n) * ((i - e) / (t - e));
}
var _m = function(i) {
  Hr(e, i);
  function e(t, n, s, r, a) {
    Yi(this, e);
    var o = Gr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, { min: s, max: r, step: a })), l = o;
    o.__background = document.createElement("div"), o.__foreground = document.createElement("div"), V.bind(o.__background, "mousedown", c), V.bind(o.__background, "touchstart", d), V.addClass(o.__background, "slider"), V.addClass(o.__foreground, "slider-fg");
    function c(g) {
      document.activeElement.blur(), V.bind(window, "mousemove", h), V.bind(window, "mouseup", u), h(g);
    }
    function h(g) {
      g.preventDefault();
      var p = l.__background.getBoundingClientRect();
      return l.setValue(my(g.clientX, p.left, p.right, l.__min, l.__max)), !1;
    }
    function u() {
      V.unbind(window, "mousemove", h), V.unbind(window, "mouseup", u), l.__onFinishChange && l.__onFinishChange.call(l, l.getValue());
    }
    function d(g) {
      g.touches.length === 1 && (V.bind(window, "touchmove", f), V.bind(window, "touchend", m), f(g));
    }
    function f(g) {
      var p = g.touches[0].clientX, v = l.__background.getBoundingClientRect();
      l.setValue(my(p, v.left, v.right, l.__min, l.__max));
    }
    function m() {
      V.unbind(window, "touchmove", f), V.unbind(window, "touchend", m), l.__onFinishChange && l.__onFinishChange.call(l, l.getValue());
    }
    return o.updateDisplay(), o.__background.appendChild(o.__foreground), o.domElement.appendChild(o.__background), o;
  }
  return ji(e, [{
    key: "updateDisplay",
    value: function() {
      var n = (this.getValue() - this.__min) / (this.__max - this.__min);
      return this.__foreground.style.width = n * 100 + "%", Nr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
    }
  }]), e;
}(y1), x1 = function(i) {
  Hr(e, i);
  function e(t, n, s) {
    Yi(this, e);
    var r = Gr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), a = r;
    return r.__button = document.createElement("div"), r.__button.innerHTML = s === void 0 ? "Fire" : s, V.bind(r.__button, "click", function(o) {
      return o.preventDefault(), a.fire(), !1;
    }), V.addClass(r.__button, "button"), r.domElement.appendChild(r.__button), r;
  }
  return ji(e, [{
    key: "fire",
    value: function() {
      this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue());
    }
  }]), e;
}(Ha), ym = function(i) {
  Hr(e, i);
  function e(t, n) {
    Yi(this, e);
    var s = Gr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
    s.__color = new mn(s.getValue()), s.__temp = new mn(0);
    var r = s;
    s.domElement = document.createElement("div"), V.makeSelectable(s.domElement, !1), s.__selector = document.createElement("div"), s.__selector.className = "selector", s.__saturation_field = document.createElement("div"), s.__saturation_field.className = "saturation-field", s.__field_knob = document.createElement("div"), s.__field_knob.className = "field-knob", s.__field_knob_border = "2px solid ", s.__hue_knob = document.createElement("div"), s.__hue_knob.className = "hue-knob", s.__hue_field = document.createElement("div"), s.__hue_field.className = "hue-field", s.__input = document.createElement("input"), s.__input.type = "text", s.__input_textShadow = "0 1px 1px ", V.bind(s.__input, "keydown", function(g) {
      g.keyCode === 13 && u.call(this);
    }), V.bind(s.__input, "blur", u), V.bind(s.__selector, "mousedown", function() {
      V.addClass(this, "drag").bind(window, "mouseup", function() {
        V.removeClass(r.__selector, "drag");
      });
    }), V.bind(s.__selector, "touchstart", function() {
      V.addClass(this, "drag").bind(window, "touchend", function() {
        V.removeClass(r.__selector, "drag");
      });
    });
    var a = document.createElement("div");
    ne.extend(s.__selector.style, {
      width: "122px",
      height: "102px",
      padding: "3px",
      backgroundColor: "#222",
      boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
    }), ne.extend(s.__field_knob.style, {
      position: "absolute",
      width: "12px",
      height: "12px",
      border: s.__field_knob_border + (s.__color.v < 0.5 ? "#fff" : "#000"),
      boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
      borderRadius: "12px",
      zIndex: 1
    }), ne.extend(s.__hue_knob.style, {
      position: "absolute",
      width: "15px",
      height: "2px",
      borderRight: "4px solid #fff",
      zIndex: 1
    }), ne.extend(s.__saturation_field.style, {
      width: "100px",
      height: "100px",
      border: "1px solid #555",
      marginRight: "3px",
      display: "inline-block",
      cursor: "pointer"
    }), ne.extend(a.style, {
      width: "100%",
      height: "100%",
      background: "none"
    }), gy(a, "top", "rgba(0,0,0,0)", "#000"), ne.extend(s.__hue_field.style, {
      width: "15px",
      height: "100px",
      border: "1px solid #555",
      cursor: "ns-resize",
      position: "absolute",
      top: "3px",
      right: "3px"
    }), MF(s.__hue_field), ne.extend(s.__input.style, {
      outline: "none",
      textAlign: "center",
      color: "#fff",
      border: 0,
      fontWeight: "bold",
      textShadow: s.__input_textShadow + "rgba(0,0,0,0.7)"
    }), V.bind(s.__saturation_field, "mousedown", o), V.bind(s.__saturation_field, "touchstart", o), V.bind(s.__field_knob, "mousedown", o), V.bind(s.__field_knob, "touchstart", o), V.bind(s.__hue_field, "mousedown", l), V.bind(s.__hue_field, "touchstart", l);
    function o(g) {
      f(g), V.bind(window, "mousemove", f), V.bind(window, "touchmove", f), V.bind(window, "mouseup", c), V.bind(window, "touchend", c);
    }
    function l(g) {
      m(g), V.bind(window, "mousemove", m), V.bind(window, "touchmove", m), V.bind(window, "mouseup", h), V.bind(window, "touchend", h);
    }
    function c() {
      V.unbind(window, "mousemove", f), V.unbind(window, "touchmove", f), V.unbind(window, "mouseup", c), V.unbind(window, "touchend", c), d();
    }
    function h() {
      V.unbind(window, "mousemove", m), V.unbind(window, "touchmove", m), V.unbind(window, "mouseup", h), V.unbind(window, "touchend", h), d();
    }
    function u() {
      var g = vm(this.value);
      g !== !1 ? (r.__color.__state = g, r.setValue(r.__color.toOriginal())) : this.value = r.__color.toString();
    }
    function d() {
      r.__onFinishChange && r.__onFinishChange.call(r, r.__color.toOriginal());
    }
    s.__saturation_field.appendChild(a), s.__selector.appendChild(s.__field_knob), s.__selector.appendChild(s.__saturation_field), s.__selector.appendChild(s.__hue_field), s.__hue_field.appendChild(s.__hue_knob), s.domElement.appendChild(s.__input), s.domElement.appendChild(s.__selector), s.updateDisplay();
    function f(g) {
      g.type.indexOf("touch") === -1 && g.preventDefault();
      var p = r.__saturation_field.getBoundingClientRect(), v = g.touches && g.touches[0] || g, y = v.clientX, _ = v.clientY, x = (y - p.left) / (p.right - p.left), M = 1 - (_ - p.top) / (p.bottom - p.top);
      return M > 1 ? M = 1 : M < 0 && (M = 0), x > 1 ? x = 1 : x < 0 && (x = 0), r.__color.v = M, r.__color.s = x, r.setValue(r.__color.toOriginal()), !1;
    }
    function m(g) {
      g.type.indexOf("touch") === -1 && g.preventDefault();
      var p = r.__hue_field.getBoundingClientRect(), v = g.touches && g.touches[0] || g, y = v.clientY, _ = 1 - (y - p.top) / (p.bottom - p.top);
      return _ > 1 ? _ = 1 : _ < 0 && (_ = 0), r.__color.h = _ * 360, r.setValue(r.__color.toOriginal()), !1;
    }
    return s;
  }
  return ji(e, [{
    key: "updateDisplay",
    value: function() {
      var n = vm(this.getValue());
      if (n !== !1) {
        var s = !1;
        ne.each(mn.COMPONENTS, function(o) {
          if (!ne.isUndefined(n[o]) && !ne.isUndefined(this.__color.__state[o]) && n[o] !== this.__color.__state[o])
            return s = !0, {};
        }, this), s && ne.extend(this.__color.__state, n);
      }
      ne.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
      var r = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0, a = 255 - r;
      ne.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + "px",
        marginTop: 100 * (1 - this.__color.v) - 7 + "px",
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + "rgb(" + r + "," + r + "," + r + ")"
      }), this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + "px", this.__temp.s = 1, this.__temp.v = 1, gy(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), ne.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: "rgb(" + r + "," + r + "," + r + ")",
        textShadow: this.__input_textShadow + "rgba(" + a + "," + a + "," + a + ",.7)"
      });
    }
  }]), e;
}(Ha), xF = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
function gy(i, e, t, n) {
  i.style.background = "", ne.each(xF, function(s) {
    i.style.cssText += "background: " + s + "linear-gradient(" + e + ", " + t + " 0%, " + n + " 100%); ";
  });
}
function MF(i) {
  i.style.background = "", i.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", i.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", i.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", i.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", i.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
}
var bF = {
  load: function(e, t) {
    var n = t || document, s = n.createElement("link");
    s.type = "text/css", s.rel = "stylesheet", s.href = e, n.getElementsByTagName("head")[0].appendChild(s);
  },
  inject: function(e, t) {
    var n = t || document, s = document.createElement("style");
    s.type = "text/css", s.innerHTML = e;
    var r = n.getElementsByTagName("head")[0];
    try {
      r.appendChild(s);
    } catch {
    }
  }
}, SF = `<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`, wF = function(e, t) {
  var n = e[t];
  return ne.isArray(arguments[2]) || ne.isObject(arguments[2]) ? new vF(e, t, arguments[2]) : ne.isNumber(n) ? ne.isNumber(arguments[2]) && ne.isNumber(arguments[3]) ? ne.isNumber(arguments[4]) ? new _m(e, t, arguments[2], arguments[3], arguments[4]) : new _m(e, t, arguments[2], arguments[3]) : ne.isNumber(arguments[4]) ? new Qu(e, t, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new Qu(e, t, { min: arguments[2], max: arguments[3] }) : ne.isString(n) ? new _F(e, t) : ne.isFunction(n) ? new x1(e, t, "") : ne.isBoolean(n) ? new _1(e, t) : null;
};
function TF(i) {
  setTimeout(i, 1e3 / 60);
}
var EF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || TF, AF = function() {
  function i() {
    Yi(this, i), this.backgroundElement = document.createElement("div"), ne.extend(this.backgroundElement.style, {
      backgroundColor: "rgba(0,0,0,0.8)",
      top: 0,
      left: 0,
      display: "none",
      zIndex: "1000",
      opacity: 0,
      WebkitTransition: "opacity 0.2s linear",
      transition: "opacity 0.2s linear"
    }), V.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), ne.extend(this.domElement.style, {
      position: "fixed",
      display: "none",
      zIndex: "1001",
      opacity: 0,
      WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
      transition: "transform 0.2s ease-out, opacity 0.2s linear"
    }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
    var e = this;
    V.bind(this.backgroundElement, "click", function() {
      e.hide();
    });
  }
  return ji(i, [{
    key: "show",
    value: function() {
      var t = this;
      this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), ne.defer(function() {
        t.backgroundElement.style.opacity = 1, t.domElement.style.opacity = 1, t.domElement.style.webkitTransform = "scale(1)";
      });
    }
  }, {
    key: "hide",
    value: function() {
      var t = this, n = function s() {
        t.domElement.style.display = "none", t.backgroundElement.style.display = "none", V.unbind(t.domElement, "webkitTransitionEnd", s), V.unbind(t.domElement, "transitionend", s), V.unbind(t.domElement, "oTransitionEnd", s);
      };
      V.bind(this.domElement, "webkitTransitionEnd", n), V.bind(this.domElement, "transitionend", n), V.bind(this.domElement, "oTransitionEnd", n), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)";
    }
  }, {
    key: "layout",
    value: function() {
      this.domElement.style.left = window.innerWidth / 2 - V.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - V.getHeight(this.domElement) / 2 + "px";
    }
  }]), i;
}(), CF = dF(`.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
`);
bF.inject(CF);
var vy = "dg", _y = 72, yy = 20, Rc = "Default", Bl = function() {
  try {
    return !!window.localStorage;
  } catch {
    return !1;
  }
}(), Jl = void 0, xy = !0, po = void 0, ip = !1, M1 = [], Tt = function i(e) {
  var t = this, n = e || {};
  this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), V.addClass(this.domElement, vy), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], n = ne.defaults(n, {
    closeOnTop: !1,
    autoPlace: !0,
    width: i.DEFAULT_WIDTH
  }), n = ne.defaults(n, {
    resizable: n.autoPlace,
    hideable: n.autoPlace
  }), ne.isUndefined(n.load) ? n.load = { preset: Rc } : n.preset && (n.load.preset = n.preset), ne.isUndefined(n.parent) && n.hideable && M1.push(this), n.resizable = ne.isUndefined(n.parent) && n.resizable, n.autoPlace && ne.isUndefined(n.scrollable) && (n.scrollable = !0);
  var s = Bl && localStorage.getItem(mo(this, "isLocal")) === "true", r = void 0, a = void 0;
  if (Object.defineProperties(
    this,
    {
      parent: {
        get: function() {
          return n.parent;
        }
      },
      scrollable: {
        get: function() {
          return n.scrollable;
        }
      },
      autoPlace: {
        get: function() {
          return n.autoPlace;
        }
      },
      closeOnTop: {
        get: function() {
          return n.closeOnTop;
        }
      },
      preset: {
        get: function() {
          return t.parent ? t.getRoot().preset : n.load.preset;
        },
        set: function(d) {
          t.parent ? t.getRoot().preset = d : n.load.preset = d, IF(this), t.revert();
        }
      },
      width: {
        get: function() {
          return n.width;
        },
        set: function(d) {
          n.width = d, bm(t, d);
        }
      },
      name: {
        get: function() {
          return n.name;
        },
        set: function(d) {
          n.name = d, a && (a.innerHTML = n.name);
        }
      },
      closed: {
        get: function() {
          return n.closed;
        },
        set: function(d) {
          n.closed = d, n.closed ? V.addClass(t.__ul, i.CLASS_CLOSED) : V.removeClass(t.__ul, i.CLASS_CLOSED), this.onResize(), t.__closeButton && (t.__closeButton.innerHTML = d ? i.TEXT_OPEN : i.TEXT_CLOSED);
        }
      },
      load: {
        get: function() {
          return n.load;
        }
      },
      useLocalStorage: {
        get: function() {
          return s;
        },
        set: function(d) {
          Bl && (s = d, d ? V.bind(window, "unload", r) : V.unbind(window, "unload", r), localStorage.setItem(mo(t, "isLocal"), d));
        }
      }
    }
  ), ne.isUndefined(n.parent)) {
    if (this.closed = n.closed || !1, V.addClass(this.domElement, i.CLASS_MAIN), V.makeSelectable(this.domElement, !1), Bl && s) {
      t.useLocalStorage = !0;
      var o = localStorage.getItem(mo(this, "gui"));
      o && (n.load = JSON.parse(o));
    }
    this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = i.TEXT_CLOSED, V.addClass(this.__closeButton, i.CLASS_CLOSE_BUTTON), n.closeOnTop ? (V.addClass(this.__closeButton, i.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (V.addClass(this.__closeButton, i.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), V.bind(this.__closeButton, "click", function() {
      t.closed = !t.closed;
    });
  } else {
    n.closed === void 0 && (n.closed = !0);
    var l = document.createTextNode(n.name);
    V.addClass(l, "controller-name"), a = i0(t, l);
    var c = function(d) {
      return d.preventDefault(), t.closed = !t.closed, !1;
    };
    V.addClass(this.__ul, i.CLASS_CLOSED), V.addClass(a, "title"), V.bind(a, "click", c), n.closed || (this.closed = !1);
  }
  n.autoPlace && (ne.isUndefined(n.parent) && (xy && (po = document.createElement("div"), V.addClass(po, vy), V.addClass(po, i.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(po), xy = !1), po.appendChild(this.domElement), V.addClass(this.domElement, i.CLASS_AUTO_PLACE)), this.parent || bm(t, n.width)), this.__resizeHandler = function() {
    t.onResizeDebounced();
  }, V.bind(window, "resize", this.__resizeHandler), V.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), V.bind(this.__ul, "transitionend", this.__resizeHandler), V.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), n.resizable && LF(this), r = function() {
    Bl && localStorage.getItem(mo(t, "isLocal")) === "true" && localStorage.setItem(mo(t, "gui"), JSON.stringify(t.getSaveObject()));
  }, this.saveToLocalStorageIfPossible = r;
  function h() {
    var u = t.getRoot();
    u.width += 1, ne.defer(function() {
      u.width -= 1;
    });
  }
  n.parent || h();
};
Tt.toggleHide = function() {
  ip = !ip, ne.each(M1, function(i) {
    i.domElement.style.display = ip ? "none" : "";
  });
};
Tt.CLASS_AUTO_PLACE = "a";
Tt.CLASS_AUTO_PLACE_CONTAINER = "ac";
Tt.CLASS_MAIN = "main";
Tt.CLASS_CONTROLLER_ROW = "cr";
Tt.CLASS_TOO_TALL = "taller-than-window";
Tt.CLASS_CLOSED = "closed";
Tt.CLASS_CLOSE_BUTTON = "close-button";
Tt.CLASS_CLOSE_TOP = "close-top";
Tt.CLASS_CLOSE_BOTTOM = "close-bottom";
Tt.CLASS_DRAG = "drag";
Tt.DEFAULT_WIDTH = 245;
Tt.TEXT_CLOSED = "Close Controls";
Tt.TEXT_OPEN = "Open Controls";
Tt._keydownHandler = function(i) {
  document.activeElement.type !== "text" && (i.which === _y || i.keyCode === _y) && Tt.toggleHide();
};
V.bind(window, "keydown", Tt._keydownHandler, !1);
ne.extend(
  Tt.prototype,
  {
    add: function(e, t) {
      return ec(this, e, t, {
        factoryArgs: Array.prototype.slice.call(arguments, 2)
      });
    },
    addColor: function(e, t) {
      return ec(this, e, t, {
        color: !0
      });
    },
    remove: function(e) {
      this.__ul.removeChild(e.__li), this.__controllers.splice(this.__controllers.indexOf(e), 1);
      var t = this;
      ne.defer(function() {
        t.onResize();
      });
    },
    destroy: function() {
      if (this.parent)
        throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
      this.autoPlace && po.removeChild(this.domElement);
      var e = this;
      ne.each(this.__folders, function(t) {
        e.removeFolder(t);
      }), V.unbind(window, "keydown", Tt._keydownHandler, !1), My(this);
    },
    addFolder: function(e) {
      if (this.__folders[e] !== void 0)
        throw new Error('You already have a folder in this GUI by the name "' + e + '"');
      var t = { name: e, parent: this };
      t.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[e] && (t.closed = this.load.folders[e].closed, t.load = this.load.folders[e]);
      var n = new Tt(t);
      this.__folders[e] = n;
      var s = i0(this, n.domElement);
      return V.addClass(s, "folder"), n;
    },
    removeFolder: function(e) {
      this.__ul.removeChild(e.domElement.parentElement), delete this.__folders[e.name], this.load && this.load.folders && this.load.folders[e.name] && delete this.load.folders[e.name], My(e);
      var t = this;
      ne.each(e.__folders, function(n) {
        e.removeFolder(n);
      }), ne.defer(function() {
        t.onResize();
      });
    },
    open: function() {
      this.closed = !1;
    },
    close: function() {
      this.closed = !0;
    },
    hide: function() {
      this.domElement.style.display = "none";
    },
    show: function() {
      this.domElement.style.display = "";
    },
    onResize: function() {
      var e = this.getRoot();
      if (e.scrollable) {
        var t = V.getOffset(e.__ul).top, n = 0;
        ne.each(e.__ul.childNodes, function(s) {
          e.autoPlace && s === e.__save_row || (n += V.getHeight(s));
        }), window.innerHeight - t - yy < n ? (V.addClass(e.domElement, Tt.CLASS_TOO_TALL), e.__ul.style.height = window.innerHeight - t - yy + "px") : (V.removeClass(e.domElement, Tt.CLASS_TOO_TALL), e.__ul.style.height = "auto");
      }
      e.__resize_handle && ne.defer(function() {
        e.__resize_handle.style.height = e.__ul.offsetHeight + "px";
      }), e.__closeButton && (e.__closeButton.style.width = e.width + "px");
    },
    onResizeDebounced: ne.debounce(function() {
      this.onResize();
    }, 50),
    remember: function() {
      if (ne.isUndefined(Jl) && (Jl = new AF(), Jl.domElement.innerHTML = SF), this.parent)
        throw new Error("You can only call remember on a top level GUI.");
      var e = this;
      ne.each(Array.prototype.slice.call(arguments), function(t) {
        e.__rememberedObjects.length === 0 && PF(e), e.__rememberedObjects.indexOf(t) === -1 && e.__rememberedObjects.push(t);
      }), this.autoPlace && bm(this, this.width);
    },
    getRoot: function() {
      for (var e = this; e.parent; )
        e = e.parent;
      return e;
    },
    getSaveObject: function() {
      var e = this.load;
      return e.closed = this.closed, this.__rememberedObjects.length > 0 && (e.preset = this.preset, e.remembered || (e.remembered = {}), e.remembered[this.preset] = cu(this)), e.folders = {}, ne.each(this.__folders, function(t, n) {
        e.folders[n] = t.getSaveObject();
      }), e;
    },
    save: function() {
      this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = cu(this), xm(this, !1), this.saveToLocalStorageIfPossible();
    },
    saveAs: function(e) {
      this.load.remembered || (this.load.remembered = {}, this.load.remembered[Rc] = cu(this, !0)), this.load.remembered[e] = cu(this), this.preset = e, Mm(this, e, !0), this.saveToLocalStorageIfPossible();
    },
    revert: function(e) {
      ne.each(this.__controllers, function(t) {
        this.getRoot().load.remembered ? b1(e || this.getRoot(), t) : t.setValue(t.initialValue), t.__onFinishChange && t.__onFinishChange.call(t, t.getValue());
      }, this), ne.each(this.__folders, function(t) {
        t.revert(t);
      }), e || xm(this.getRoot(), !1);
    },
    listen: function(e) {
      var t = this.__listening.length === 0;
      this.__listening.push(e), t && S1(this.__listening);
    },
    updateDisplay: function() {
      ne.each(this.__controllers, function(e) {
        e.updateDisplay();
      }), ne.each(this.__folders, function(e) {
        e.updateDisplay();
      });
    }
  }
);
function i0(i, e, t) {
  var n = document.createElement("li");
  return e && n.appendChild(e), t ? i.__ul.insertBefore(n, t) : i.__ul.appendChild(n), i.onResize(), n;
}
function My(i) {
  V.unbind(window, "resize", i.__resizeHandler), i.saveToLocalStorageIfPossible && V.unbind(window, "unload", i.saveToLocalStorageIfPossible);
}
function xm(i, e) {
  var t = i.__preset_select[i.__preset_select.selectedIndex];
  e ? t.innerHTML = t.value + "*" : t.innerHTML = t.value;
}
function RF(i, e, t) {
  if (t.__li = e, t.__gui = i, ne.extend(t, {
    options: function(a) {
      if (arguments.length > 1) {
        var o = t.__li.nextElementSibling;
        return t.remove(), ec(i, t.object, t.property, {
          before: o,
          factoryArgs: [ne.toArray(arguments)]
        });
      }
      if (ne.isArray(a) || ne.isObject(a)) {
        var l = t.__li.nextElementSibling;
        return t.remove(), ec(i, t.object, t.property, {
          before: l,
          factoryArgs: [a]
        });
      }
    },
    name: function(a) {
      return t.__li.firstElementChild.firstElementChild.innerHTML = a, t;
    },
    listen: function() {
      return t.__gui.listen(t), t;
    },
    remove: function() {
      return t.__gui.remove(t), t;
    }
  }), t instanceof _m) {
    var n = new Qu(t.object, t.property, { min: t.__min, max: t.__max, step: t.__step });
    ne.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(r) {
      var a = t[r], o = n[r];
      t[r] = n[r] = function() {
        var l = Array.prototype.slice.call(arguments);
        return o.apply(n, l), a.apply(t, l);
      };
    }), V.addClass(e, "has-slider"), t.domElement.insertBefore(n.domElement, t.domElement.firstElementChild);
  } else if (t instanceof Qu) {
    var s = function(a) {
      if (ne.isNumber(t.__min) && ne.isNumber(t.__max)) {
        var o = t.__li.firstElementChild.firstElementChild.innerHTML, l = t.__gui.__listening.indexOf(t) > -1;
        t.remove();
        var c = ec(i, t.object, t.property, {
          before: t.__li.nextElementSibling,
          factoryArgs: [t.__min, t.__max, t.__step]
        });
        return c.name(o), l && c.listen(), c;
      }
      return a;
    };
    t.min = ne.compose(s, t.min), t.max = ne.compose(s, t.max);
  } else t instanceof _1 ? (V.bind(e, "click", function() {
    V.fakeEvent(t.__checkbox, "click");
  }), V.bind(t.__checkbox, "click", function(r) {
    r.stopPropagation();
  })) : t instanceof x1 ? (V.bind(e, "click", function() {
    V.fakeEvent(t.__button, "click");
  }), V.bind(e, "mouseover", function() {
    V.addClass(t.__button, "hover");
  }), V.bind(e, "mouseout", function() {
    V.removeClass(t.__button, "hover");
  })) : t instanceof ym && (V.addClass(e, "color"), t.updateDisplay = ne.compose(function(r) {
    return e.style.borderLeftColor = t.__color.toString(), r;
  }, t.updateDisplay), t.updateDisplay());
  t.setValue = ne.compose(function(r) {
    return i.getRoot().__preset_select && t.isModified() && xm(i.getRoot(), !0), r;
  }, t.setValue);
}
function b1(i, e) {
  var t = i.getRoot(), n = t.__rememberedObjects.indexOf(e.object);
  if (n !== -1) {
    var s = t.__rememberedObjectIndecesToControllers[n];
    if (s === void 0 && (s = {}, t.__rememberedObjectIndecesToControllers[n] = s), s[e.property] = e, t.load && t.load.remembered) {
      var r = t.load.remembered, a = void 0;
      if (r[i.preset])
        a = r[i.preset];
      else if (r[Rc])
        a = r[Rc];
      else
        return;
      if (a[n] && a[n][e.property] !== void 0) {
        var o = a[n][e.property];
        e.initialValue = o, e.setValue(o);
      }
    }
  }
}
function ec(i, e, t, n) {
  if (e[t] === void 0)
    throw new Error('Object "' + e + '" has no property "' + t + '"');
  var s = void 0;
  if (n.color)
    s = new ym(e, t);
  else {
    var r = [e, t].concat(n.factoryArgs);
    s = wF.apply(i, r);
  }
  n.before instanceof Ha && (n.before = n.before.__li), b1(i, s), V.addClass(s.domElement, "c");
  var a = document.createElement("span");
  V.addClass(a, "property-name"), a.innerHTML = s.property;
  var o = document.createElement("div");
  o.appendChild(a), o.appendChild(s.domElement);
  var l = i0(i, o, n.before);
  return V.addClass(l, Tt.CLASS_CONTROLLER_ROW), s instanceof ym ? V.addClass(l, "color") : V.addClass(l, pF(s.getValue())), RF(i, l, s), i.__controllers.push(s), s;
}
function mo(i, e) {
  return document.location.href + "." + e;
}
function Mm(i, e, t) {
  var n = document.createElement("option");
  n.innerHTML = e, n.value = e, i.__preset_select.appendChild(n), t && (i.__preset_select.selectedIndex = i.__preset_select.length - 1);
}
function by(i, e) {
  e.style.display = i.useLocalStorage ? "block" : "none";
}
function PF(i) {
  var e = i.__save_row = document.createElement("li");
  V.addClass(i.domElement, "has-save"), i.__ul.insertBefore(e, i.__ul.firstChild), V.addClass(e, "save-row");
  var t = document.createElement("span");
  t.innerHTML = "&nbsp;", V.addClass(t, "button gears");
  var n = document.createElement("span");
  n.innerHTML = "Save", V.addClass(n, "button"), V.addClass(n, "save");
  var s = document.createElement("span");
  s.innerHTML = "New", V.addClass(s, "button"), V.addClass(s, "save-as");
  var r = document.createElement("span");
  r.innerHTML = "Revert", V.addClass(r, "button"), V.addClass(r, "revert");
  var a = i.__preset_select = document.createElement("select");
  if (i.load && i.load.remembered ? ne.each(i.load.remembered, function(u, d) {
    Mm(i, d, d === i.preset);
  }) : Mm(i, Rc, !1), V.bind(a, "change", function() {
    for (var u = 0; u < i.__preset_select.length; u++)
      i.__preset_select[u].innerHTML = i.__preset_select[u].value;
    i.preset = this.value;
  }), e.appendChild(a), e.appendChild(t), e.appendChild(n), e.appendChild(s), e.appendChild(r), Bl) {
    var o = document.getElementById("dg-local-explain"), l = document.getElementById("dg-local-storage"), c = document.getElementById("dg-save-locally");
    c.style.display = "block", localStorage.getItem(mo(i, "isLocal")) === "true" && l.setAttribute("checked", "checked"), by(i, o), V.bind(l, "change", function() {
      i.useLocalStorage = !i.useLocalStorage, by(i, o);
    });
  }
  var h = document.getElementById("dg-new-constructor");
  V.bind(h, "keydown", function(u) {
    u.metaKey && (u.which === 67 || u.keyCode === 67) && Jl.hide();
  }), V.bind(t, "click", function() {
    h.innerHTML = JSON.stringify(i.getSaveObject(), void 0, 2), Jl.show(), h.focus(), h.select();
  }), V.bind(n, "click", function() {
    i.save();
  }), V.bind(s, "click", function() {
    var u = prompt("Enter a new preset name.");
    u && i.saveAs(u);
  }), V.bind(r, "click", function() {
    i.revert();
  });
}
function LF(i) {
  var e = void 0;
  i.__resize_handle = document.createElement("div"), ne.extend(i.__resize_handle.style, {
    width: "6px",
    marginLeft: "-3px",
    height: "200px",
    cursor: "ew-resize",
    position: "absolute"
  });
  function t(r) {
    return r.preventDefault(), i.width += e - r.clientX, i.onResize(), e = r.clientX, !1;
  }
  function n() {
    V.removeClass(i.__closeButton, Tt.CLASS_DRAG), V.unbind(window, "mousemove", t), V.unbind(window, "mouseup", n);
  }
  function s(r) {
    return r.preventDefault(), e = r.clientX, V.addClass(i.__closeButton, Tt.CLASS_DRAG), V.bind(window, "mousemove", t), V.bind(window, "mouseup", n), !1;
  }
  V.bind(i.__resize_handle, "mousedown", s), V.bind(i.__closeButton, "mousedown", s), i.domElement.insertBefore(i.__resize_handle, i.domElement.firstElementChild);
}
function bm(i, e) {
  i.domElement.style.width = e + "px", i.__save_row && i.autoPlace && (i.__save_row.style.width = e + "px"), i.__closeButton && (i.__closeButton.style.width = e + "px");
}
function cu(i, e) {
  var t = {};
  return ne.each(i.__rememberedObjects, function(n, s) {
    var r = {}, a = i.__rememberedObjectIndecesToControllers[s];
    ne.each(a, function(o, l) {
      r[l] = e ? o.initialValue : o.getValue();
    }), t[s] = r;
  }), t;
}
function IF(i) {
  for (var e = 0; e < i.__preset_select.length; e++)
    i.__preset_select[e].value === i.preset && (i.__preset_select.selectedIndex = e);
}
function S1(i) {
  i.length !== 0 && EF.call(window, function() {
    S1(i);
  }), ne.each(i, function(e) {
    e.updateDisplay();
  });
}
var sp = Tt;
function DF(i, e) {
  var s;
  sp.TEXT_CLOSED = "", sp.TEXT_OPEN = "";
  const t = {
    open: () => t,
    close: () => t,
    destroy: () => t,
    add: () => t,
    remove: () => t,
    addFolder: () => t,
    removeFolder: () => t,
    addColor: () => t,
    removeColor: () => t,
    min: () => t,
    max: () => t,
    step: () => t,
    name: () => t,
    listen: () => t,
    onChange: () => t,
    onFinishChange: () => t,
    addFolder: () => t,
    updateDisplay: () => t,
    domElement: () => t
  }, n = i ? t : new sp({ autoPlace: e });
  return (s = n.__closeButton) == null || s.remove(), n;
}
function Vr(i) {
  const { name: e, visible: t, castShadow: n, receiveShadow: s, position: r, rotation: a, scale: o, renderOrder: l, transformAnimationList: c, isSsr: h } = i;
  return {
    name: e,
    visible: t,
    renderOrder: l,
    castShadow: n,
    receiveShadow: s,
    position: {
      x: r.x,
      y: r.y,
      z: r.z
    },
    rotation: {
      x: a.x,
      y: a.y,
      z: a.z
    },
    scale: {
      x: o.x,
      y: o.y,
      z: o.z
    },
    blendShaderPrograms: hF(i),
    transformAnimationList: c,
    isSsr: h
  };
}
function Wr(i, e) {
  if (!e) return;
  const { name: t, visible: n, castShadow: s, receiveShadow: r, position: a, rotation: o, scale: l, renderOrder: c, blendShaderPrograms: h, transformAnimationList: u, isSsr: d } = e;
  if (i.name = t, i.visible = n, i.renderOrder = c, i.castShadow = s, i.receiveShadow = r, i.position.set(a.x, a.y, a.z), i.rotation.set(o.x, o.y, o.z), i.scale.set(l.x, l.y, l.z), uF(i, h), i.transformAnimationList = u, d) {
    i.isSsr = d;
    let f = i;
    do
      f = f.parent;
    while (f.type !== "Scene");
    f.SsrMeshList.push(i);
  }
}
function $s(i, e) {
  e.add(i, "name").name(""), e.add(i, "visible").name(""), Reflect.has(i, "isSsr") || (i.isSsr = !1), e.add(i, "isSsr").name("SSR").onChange((t) => {
    let n = i;
    do
      n = n.parent;
    while (n.type !== "Scene");
    if (t) n.SsrMeshList.push(i);
    else {
      const s = n.SsrMeshList.indexOf(i);
      s !== -1 && n.SsrMeshList.splice(s, 1);
    }
  }), e.add(i, "renderOrder").name("").step(1), e.add(i, "castShadow").name(""), e.add(i, "receiveShadow").name(""), ["x", "y", "z"].forEach((t) => e.add(i.position, t).name("" + t)), ["x", "y", "z"].forEach((t) => e.add(i.rotation, t).name("" + t)), ["x", "y", "z"].forEach((t) => e.add(i.scale, t).name("" + t));
}
function OF(i) {
  const { mapType: e, mapUrl: t, map: n } = i;
  if (!(!t || !n))
    return {
      mapType: e,
      mapUrl: t,
      map: {
        wrapS: n.wrapS,
        wrapT: n.wrapT,
        rotation: n.rotation,
        center: n.center,
        repeat: n.repeat,
        offset: n.offset,
        textureAnimation: n.textureAnimation
      }
    };
}
function w1(i, e, t) {
  var n;
  if (!e.mapUrl) return e.map = null;
  e.mapType == "" ? e.map = OU(e.mapUrl) : e.map = new Ys().load(e.mapUrl), t && (e.map.wrapS = t.wrapS, e.map.wrapT = t.wrapT, e.map.repeat.set(t.repeat.x, t.repeat.y), e.map.offset.set(t.offset.x, t.offset.y), e.map.center.set(t.center.x, t.center.y), e.map.rotation = t.rotation, (n = t.textureAnimation) != null && n.isTextureAnimation && (e.map.textureAnimation = t.textureAnimation, e.map.frameAnimationRender = function() {
    e.map.offset.x += t.textureAnimation.offset.x, e.map.offset.y += t.textureAnimation.offset.y, e.map.rotation += t.textureAnimation.rotation;
  }, i.push(e.map))), e.map.center.set(0.5, 0.5), e.isCustomTexture = !0, e.needsUpdate = !0;
}
function NF(i, e, t) {
  !Reflect.has(e, "mapUrl") && (e.mapUrl = ""), t.add(e, "mapUrl").name(""), !Reflect.has(e, "mapType") && (e.mapType = ""), t.add(e, "mapType", ["", ""]).name(""), t.add({ updateMap: () => w1(i, e) }, "updateMap").name("");
}
function UF(i, e) {
  e.add(i, "wrapS", [Kt, Tn, Er]).name("").onChange((t) => i.needsUpdate = !0), e.add(i, "wrapT", [Kt, Tn, Er]).name("").onChange((t) => i.needsUpdate = !0), e.add(i, "rotation").name("").min(0).max(Math.PI * 2), e.add(i.repeat, "x").name("x"), e.add(i.repeat, "y").name("y"), e.add(i.offset, "x").name("x").min(0).max(1), e.add(i.offset, "y").name("y").min(0).max(1), e.add(i.center, "x").name("x").min(0).max(1), e.add(i.center, "y").name("y").min(0).max(1);
}
function FF(i, e, t) {
  Reflect.has(e, "textureAnimation") || (e.textureAnimation = {
    isTextureAnimation: !1,
    offset: { x: 0, y: 0 },
    rotation: 0
  }), t.add(e.textureAnimation, "isTextureAnimation").name("").onChange((n) => {
    n ? (e.frameAnimationRender = function() {
      e.offset.x += e.textureAnimation.offset.x, e.offset.y += e.textureAnimation.offset.y, e.rotation += e.textureAnimation.rotation;
    }, i.push(e)) : (delete e.frameAnimationRender, i.splice(i.findIndex((s) => s.uuid == e.uuid), 1));
  }), t.add(e.textureAnimation, "rotation").name(""), t.add(e.textureAnimation.offset, "x").name("x"), t.add(e.textureAnimation.offset, "y").name("y");
}
function s0(i) {
  const { visible: e, color: t, opacity: n, transparent: s, wireframe: r, metalness: a, roughness: o } = i;
  return { visible: e, color: t, opacity: n, transparent: s, wireframe: r, metalness: a, roughness: o };
}
function r0(i, e) {
  if (!e) return;
  const { visible: t, color: n, opacity: s, transparent: r, wireframe: a, metalness: o, roughness: l } = e;
  i.visible = t, i.wireframe = a, i.transparent = r, i.opacity = s, i.color.set(n), i.metalness = o, i.roughness = l;
}
function BF(i, e) {
  i.isShaderMaterial || (e.add(i, "name").name(""), e.add(i, "visible").name(""), e.add(i, "wireframe").name(""), e.add(i, "transparent").name(""), e.add(i, "opacity", 0, 1).name(""), e.addColor({ color: i.color.getHex() }, "color").name("").onChange((t) => i.color.setHex(t)), i.metalness != null && e.add(i, "metalness", 0, 1).name(""), i.roughness != null && e.add(i, "roughness", 0, 1).name(""));
}
function kF(i, e) {
  e.add({ transparent: !1 }, "transparent").name("").onChange((t) => i.forEach((n) => n.transparent = t)), e.add({ opacity: 1 }, "opacity").min(0).max(1).name("").onChange((t) => i.forEach((n) => n.opacity = t)), e.add({ wireframe: !1 }, "wireframe").name("").onChange((t) => i.forEach((n) => n.wireframe = t)), e.addColor({ color: 16777215 }, "color").name("").onChange((t) => i.forEach((n) => n.color.set(t))), e.add({ metalness: 0 }, "metalness").min(0).max(1).name("").onChange((t) => i.forEach((n) => n.metalness != null && (n.metalness = t))), e.add({ roughness: 0 }, "roughness").min(0).max(1).name("").onChange((t) => i.forEach((n) => n.roughness != null && (n.roughness = t))), e.add({ fn: () => i.forEach((t) => t.needsUpdate = !0) }, "fn").name("");
}
class Vd extends le {
  constructor(e, t = {}) {
    super(e), this.isReflector = !0, this.type = "Reflector", this.camera = new Zt();
    const n = this, s = t.color !== void 0 ? new Q(t.color) : new Q(8355711), r = t.textureWidth || 512, a = t.textureHeight || 512, o = t.clipBias || 0, l = t.shader || Vd.ReflectorShader, c = t.multisample !== void 0 ? t.multisample : 4, h = new as(), u = new T(), d = new T(), f = new T(), m = new _e(), g = new T(0, 0, -1), p = new tt(), v = new T(), y = new T(), _ = new tt(), x = new _e(), M = this.camera, S = new xt(r, a, { samples: c, type: zt }), w = new mt({
      name: l.name !== void 0 ? l.name : "unspecified",
      uniforms: cn.clone(l.uniforms),
      fragmentShader: l.fragmentShader,
      vertexShader: l.vertexShader
    });
    w.uniforms.tDiffuse.value = S.texture, w.uniforms.color.value = s, w.uniforms.textureMatrix.value = x, this.material = w, this.onBeforeRender = function(E, b, A) {
      if (d.setFromMatrixPosition(n.matrixWorld), f.setFromMatrixPosition(A.matrixWorld), m.extractRotation(n.matrixWorld), u.set(0, 0, 1), u.applyMatrix4(m), v.subVectors(d, f), v.dot(u) > 0) return;
      v.reflect(u).negate(), v.add(d), m.extractRotation(A.matrixWorld), g.set(0, 0, -1), g.applyMatrix4(m), g.add(f), y.subVectors(d, g), y.reflect(u).negate(), y.add(d), M.position.copy(v), M.up.set(0, 1, 0), M.up.applyMatrix4(m), M.up.reflect(u), M.lookAt(y), M.far = A.far, M.updateMatrixWorld(), M.projectionMatrix.copy(A.projectionMatrix), x.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      ), x.multiply(M.projectionMatrix), x.multiply(M.matrixWorldInverse), x.multiply(n.matrixWorld), h.setFromNormalAndCoplanarPoint(u, d), h.applyMatrix4(M.matrixWorldInverse), p.set(h.normal.x, h.normal.y, h.normal.z, h.constant);
      const D = M.projectionMatrix;
      _.x = (Math.sign(p.x) + D.elements[8]) / D.elements[0], _.y = (Math.sign(p.y) + D.elements[9]) / D.elements[5], _.z = -1, _.w = (1 + D.elements[10]) / D.elements[14], p.multiplyScalar(2 / p.dot(_)), D.elements[2] = p.x, D.elements[6] = p.y, D.elements[10] = p.z + 1 - o, D.elements[14] = p.w, n.visible = !1;
      const B = E.getRenderTarget(), X = E.xr.enabled, L = E.shadowMap.autoUpdate;
      E.xr.enabled = !1, E.shadowMap.autoUpdate = !1, E.setRenderTarget(S), E.state.buffers.depth.setMask(!0), E.autoClear === !1 && E.clear(), E.render(b, M), E.xr.enabled = X, E.shadowMap.autoUpdate = L, E.setRenderTarget(B);
      const F = A.viewport;
      F !== void 0 && E.state.viewport(F), n.visible = !0;
    }, this.getRenderTarget = function() {
      return S;
    }, this.dispose = function() {
      S.dispose(), n.material.dispose();
    };
  }
}
Vd.ReflectorShader = {
  name: "ReflectorShader",
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
function T1(i, e) {
  const { DOM: t, renderer: n } = e, s = new Vd(i || new Fr(100, 100), {
    clipBias: 0.03,
    textureWidth: t.clientWidth * n.getPixelRatio(),
    textureHeight: t.clientHeight * n.getPixelRatio(),
    color: 12700619
  });
  return s.rotateX(-Math.PI / 2), s;
}
function zF(i, e) {
  const { material: t } = i;
  e.addColor({ color: t.uniforms.color.value.getHex() }, "color").name("").onChange((n) => t.uniforms.color.value.setHex(n));
}
const Sm = [
  { name: "", createFunc: T1, setPanel: zF }
], HF = Sm.map((i) => i.name);
function GF(i, e, t, n, s) {
  n.designPrograms || (n.designPrograms = {
    designProgramsCodeName: "",
    isDesignPrograms: !1,
    designParams: null
  }), s.add(n.designPrograms, "isDesignPrograms").name("").onChange((r) => {
    if (r) {
      const { geometry: a } = n, o = T1(a, { renderer: e, DOM: t });
      o.position.copy(n.position), o.rotation.copy(n.rotation), o.scale.copy(n.scale), n.visible = !1, i.add(o);
    }
  }), s.add(n.designPrograms, "designProgramsCodeName", HF).name("");
}
function VF(i, e, t, n, s, r, a) {
  a.selectPanel = a.addFolder("#:" + r.name + ""), $s(r, a.selectPanel.addFolder("")), Array.isArray(r.material) ? r.material.forEach((l, c) => o(a.selectPanel, l, c)) : o(a.selectPanel, r.material), g1(t, n, r, a.selectPanel.addFolder("")), GF(i, e, n, r, a.selectPanel.addFolder(""));
  function o(l, c, h = "") {
    BF(c, l.addFolder("" + h)), c.isCustomTexture && c.map && (UF(c.map, l.addFolder("" + h)), FF(s, c.map, l.addFolder("" + h)));
  }
}
function WF(i, e, t, n, s) {
  if (!t.RootMaterials) return s(t);
  n.selectPanel = n.addFolder("$:" + t.name + ""), $s(t, n.selectPanel.addFolder("")), kF(t.RootMaterials, n.selectPanel.addFolder("")), g1(i, e, t, n.selectPanel.addFolder(""));
}
function XF(i, e, t, n, s, r) {
  r.createSelectMeshPanel = (o) => {
    a(), VF(i, e, t, n, s, o, r);
  }, r.createSelectRootGroupPanel = (o) => {
    a(), WF(t, n, o, r, (l) => {
      l.isMesh && r.createSelectMeshPanel(l);
    });
  };
  function a() {
    r.selectPanel && (r.removeFolder(r.selectPanel), r.selectPanel = null);
  }
}
function qF(i) {
  return {
    outputColorSpace: i.outputColorSpace,
    toneMapping: i.toneMapping,
    toneMappingExposure: i.toneMappingExposure,
    shadowMap: {
      enabled: i.shadowMap.enabled,
      type: i.shadowMap.type
    },
    color: i.getClearColor(new Q()).getHex(),
    opacity: i.getClearAlpha(),
    sortObjects: i.sortObjects
  };
}
function YF(i, e) {
  e && (i.outputColorSpace = e.outputColorSpace, i.toneMapping = e.toneMapping, i.toneMappingExposure = e.toneMappingExposure, i.shadowMap.enabled = e.shadowMap.enabled, i.shadowMap.type = e.shadowMap.type, i.setClearColor(e.color, e.opacity), i.sortObjects = e.sortObjects);
}
function jF(i, e) {
  e.addColor({ color: i.getClearColor(new Q()).getHex() }, "color").onChange((t) => i.setClearColor(t, i.getClearAlpha())).name(""), e.add({ opacity: i.getClearAlpha() }, "opacity").min(0).max(1).onChange((t) => i.setClearAlpha(t)).name(""), e.add(i, "outputColorSpace", [ft, en]).name(""), e.add(i, "toneMapping", [0, 1, 2, 3, 4]).name("").onChange((t) => i.toneMapping = [ps, od, ld, cd, hd][t]), e.add(i, "toneMappingExposure").min(0).max(50).name(""), e.add(i.shadowMap, "enabled").name(""), e.add(i.shadowMap, "type", [0, 1, 2, 3]).name("").onChange((t) => i.shadowMap.type = [zy, nd, Am, zi][t]), e.add(i, "sortObjects").name("");
}
function ZF(i) {
  return {
    fov: i.fov,
    near: i.near,
    far: i.far,
    zoom: i.zoom,
    position: {
      x: i.position.x,
      y: i.position.y,
      z: i.position.z
    }
  };
}
function $F(i, e) {
  e && (i.fov = e.fov, i.near = e.near, i.far = e.far, i.zoom = e.zoom, i.position.set(e.position.x, e.position.y, e.position.z), i.updateProjectionMatrix());
}
function KF(i, e) {
  const t = () => i.updateProjectionMatrix();
  e.add(i, "fov").min(0).name("").onChange(t), e.add(i, "near").min(1e-3).name("").onChange(t), e.add(i, "far").min(0).name("").onChange(t), e.add(i, "zoom").min(0).name("").onChange(t), e.add(i.position, "x").name("x"), e.add(i.position, "y").name("y"), e.add(i.position, "z").name("z");
}
function QF(i) {
  return {
    maxPolarAngle: i.maxPolarAngle,
    autoRotate: i.autoRotate,
    autoRotateSpeed: i.autoRotateSpeed,
    rotateSpeed: i.rotateSpeed,
    panSpeed: i.panSpeed,
    zoomSpeed: i.zoomSpeed,
    enableDamping: i.enableDamping,
    dampingFactor: i.dampingFactor,
    minDistance: i.minDistance,
    maxDistance: i.maxDistance,
    target: { x: i.target.x, y: i.target.y, z: i.target.z },
    viewAngleList: i.viewAngleList
  };
}
function JF(i, e) {
  e && (i.maxPolarAngle = e.maxPolarAngle, i.autoRotate = e.autoRotate, i.autoRotateSpeed = e.autoRotateSpeed, i.rotateSpeed = e.rotateSpeed, i.panSpeed = e.panSpeed, i.zoomSpeed = e.zoomSpeed, i.enableDamping = e.enableDamping, i.dampingFactor = e.dampingFactor, i.minDistance = e.minDistance, i.maxDistance = e.maxDistance, i.target.set(e.target.x, e.target.y, e.target.z), i.viewAngleList = e.viewAngleList, i.update());
}
function eB(i, e) {
  e.add(i, "autoRotate").name(""), e.add(i, "autoRotateSpeed", 0, 10).name(""), e.add(i, "enableDamping").name(""), e.add(i, "dampingFactor", 0, 1).name(""), e.add(i, "minDistance", 0).name(""), e.add(i, "maxDistance", 0).name(""), e.add(i, "maxPolarAngle", 0, Math.PI * 2).name(""), e.add(i, "rotateSpeed").name(""), e.add(i, "panSpeed").name(""), e.add(i, "zoomSpeed").name(""), e.add(i.target, "x").name("x"), e.add(i.target, "y").name("y"), e.add(i.target, "z").name("z");
}
function tB(i, e) {
  if (e.open(), !!i)
    return e.add(i, "colorSpace", [ft, en]).name("").onChange(() => i.needsUpdate = !0), e;
}
function nB(i) {
  if (i)
    return {
      colorSpace: i.colorSpace
    };
}
function iB(i, e) {
  e && (i.colorSpace = e.colorSpace);
}
function sB(i) {
  if (i)
    return {
      name: i.name,
      type: i instanceof sl ? "linear" : "exp2",
      density: i.density,
      color: i.color.getHex(),
      near: i.near,
      far: i.far
    };
}
function wm(i, ...e) {
  return i === "linear" ? new sl(...e) : new il(...e);
}
function rB(i, e) {
  if (!e) return;
  const t = wm(e.type);
  t.name = e.name, t.color.set(e.color), e.type === "linear" ? (t.near = e.near, t.far = e.far) : t.density = e.density, i.fog = t;
}
function aB(i, e) {
  let t = null;
  const n = { type: i.fog instanceof il ? "exp2" : "linear", enable: !!i.fog };
  e.add(n, "type", ["linear", "exp2"]).name("").onChange((r) => {
    var a;
    i.fog = wm(r, (a = i.fog) == null ? void 0 : a.color), s(r);
  }), e.add(n, "enable").name("").onChange((r) => {
    r ? i.fog = wm(n.type) : i.fog = null, s(n.type);
  }), n.enable && s(n.type);
  function s(r) {
    t && (e.removeFolder(t), t = null), i.fog && (t = e.addFolder(r + ""), t.addColor({ color: i.fog.color.getHex() }, "color").name("").onChange((a) => i.fog.color.set(a)), r === "linear" ? (t.add(i.fog, "near").name(""), t.add(i.fog, "far").name("")) : t.add(i.fog, "density").name(""));
  }
}
function oB(i) {
  const { background: e } = i;
  return {
    fog: sB(i.fog),
    environmentEnabled: i.environmentEnabled,
    background: nB(e)
  };
}
function lB(i, e) {
  e && (rB(i, e.fog), i.environmentEnabled = e.environmentEnabled, i.backgroundLoadCallback = (t) => iB(t, e.background));
}
function cB(i, e) {
  if (!e) return;
  aB(i, e.addFolder("")), e.add(i, "environmentEnabled").name("").onChange((n) => {
    i.environment = n ? i.EnvBackground : null;
  });
  let t = null;
  e.add({
    fn: () => {
      t || (t = tB(i.background, e.addFolder("")));
    }
  }, "fn").name("");
}
function hB(i) {
  if (!i) return;
  const { camera: e } = i;
  return {
    bias: i.bias,
    radius: i.radius,
    mapSize: i.mapSize,
    normalBias: i.normalBias,
    camera: e ? {
      near: e.near,
      far: e.far,
      fov: e.fov,
      left: e.left,
      right: e.right,
      top: e.top,
      bottom: e.bottom
    } : null
  };
}
function uB(i, e) {
  if (!e) return;
  i.bias = e.bias, i.radius = e.radius, i.mapSize.set(e.mapSize.x, e.mapSize.y), i.normalBias = e.normalBias;
  const { camera: t } = e;
  t && i.camera && (Object.keys(t).forEach((n) => i.camera[n] = t[n]), i.camera.updateProjectionMatrix());
}
function dB(i, e) {
  e.add(i, "bias").name(""), e.add(i, "radius").name(""), e.add(i, "normalBias").name(""), e.add(i.mapSize, "width").name(""), e.add(i.mapSize, "height").name("");
  const t = e.addFolder("");
  t.add(i.camera, "near").name("").onChange(() => i.camera.updateProjectionMatrix()), t.add(i.camera, "far").name("").onChange(() => i.camera.updateProjectionMatrix()), i.camera.isOrthographicCamera ? (t.add(i.camera, "left").name("").onChange(() => i.camera.updateProjectionMatrix()), t.add(i.camera, "right").name("").onChange(() => i.camera.updateProjectionMatrix()), t.add(i.camera, "top").name("").onChange(() => i.camera.updateProjectionMatrix()), t.add(i.camera, "bottom").name("").onChange(() => i.camera.updateProjectionMatrix())) : t.add(i.camera, "fov").name("").onChange(() => i.camera.updateProjectionMatrix());
}
function fB(i) {
  switch (i.type) {
    case "PointLight":
      return {
        distance: i.distance,
        decay: i.decay,
        power: i.power
      };
    case "SpotLight":
      return {
        distance: i.distance,
        decay: i.decay,
        power: i.power,
        angle: i.angle,
        penumbra: i.penumbra
      };
    case "HemisphereLight":
      return {
        groundColor: i.groundColor
      };
    case "RectAreaLight":
      return {
        width: i.width,
        height: i.height,
        rotation: { x: i.rotation.x, y: i.rotation.y, z: i.rotation.z }
      };
  }
}
function pB(i, e) {
  if (e)
    switch (i.type) {
      case "PointLight":
        i.distance = e.distance, i.decay = e.decay, i.power = e.power;
        break;
      case "SpotLight":
        i.distance = e.distance, i.decay = e.decay, i.power = e.power, i.angle = e.angle, i.penumbra = e.penumbra;
        break;
      case "HemisphereLight":
        i.groundColor.set(e.groundColor);
        break;
      case "RectAreaLight":
        i.width = e.width, i.height = e.height, i.rotation.set(e.rotation.x, e.rotation.y, e.rotation.z);
        break;
    }
}
function mB(i, e) {
  switch (i.type) {
    case "PointLight":
      e.add(i, "distance").name(""), e.add(i, "decay").name(""), e.add(i, "power").name("");
      break;
    case "SpotLight":
      e.add(i, "distance").name(""), e.add(i, "decay").name(""), e.add(i, "power").name(""), e.add(i, "angle").name(""), e.add(i, "penumbra").name("");
      break;
    case "HemisphereLight":
      e.addColor({ color: i.groundColor.getHex() }, "color").name("").onChange((t) => i.groundColor.set(t));
      break;
    case "RectAreaLight":
      e.add(i.rotation, "x").name("X").min(-Math.PI / 2).max(Math.PI / 2), e.add(i.rotation, "y").name("y").min(-Math.PI / 2).max(Math.PI / 2), e.add(i.rotation, "z").name("z").min(-Math.PI / 2).max(Math.PI / 2), e.add(i, "width").name(""), e.add(i, "height").name("");
      break;
  }
}
function E1(i, e = {}) {
  let t = null;
  switch (i) {
    case "AmbientLight":
      t = gB(e);
      break;
    case "DirectionalLight":
      t = vB(e);
      break;
    case "PointLight":
      t = _B(e);
      break;
    case "SpotLight":
      t = yB(e);
      break;
    case "HemisphereLight":
      t = xB(e);
      break;
    case "RectAreaLight":
      t = MB(e);
      break;
  }
  return t;
}
function gB(i = {}) {
  return new Nd(i.color || 16777215, i.intensity || 1);
}
function vB(i = {}) {
  return new Xc(i.color || 16777215, i.intensity || 1);
}
function _B(i = {}) {
  return new Xo(i.color || 16777215, i.intensity || 1, i.distance || 0, i.decay || 0);
}
function yB(i = {}) {
  return new Wc(i.color || 16777215, i.intensity || 1, i.distance || 0, i.angle || Math.PI / 3, i.penumbra || 0, i.decay || 0);
}
function xB(i = {}) {
  return new mg(i.color || 16777215, i.groundColor || 0, i.intensity || 1);
}
function MB(i = {}) {
  return new vg(i.color || 16777215, i.intensity || 1, i.width || 100, i.height || 100);
}
function bB(i) {
  const { name: e, type: t, visible: n, position: s, color: r, intensity: a, castShadow: o, shadow: l } = i;
  return {
    name: e,
    type: t,
    visible: n,
    position: s,
    color: r,
    intensity: a,
    castShadow: o,
    shadow: hB(l),
    ...fB(i)
  };
}
function SB(i, e) {
  e && (i.name = e.name, i.visible = e.visible, i.color.set(e.color), i.intensity = e.intensity, i.castShadow = e.castShadow, i.position.set(e.position.x, e.position.y, e.position.z), uB(i.shadow, e.shadow), pB(i, e));
}
function Sy(i, e, t) {
  if (e.add(i, "visible").name(""), e.add(i, "name").name(""), e.addColor({ color: i.color.getHex() }, "color").name("").onChange((r) => i.color.set(r)), e.add(i, "intensity").name(""), e.add({ fn: () => t.attach(i) }, "fn").name(""), e.add({
    fn: () => {
      t.detach(), i.parent.remove(i), i.dispose(), e.parent.removeFolder(e);
    }
  }, "fn").name(""), i.shadow) {
    e.add(i, "castShadow").name("");
    const r = e.addFolder("");
    dB(i.shadow, r);
  }
  const n = e.addFolder("");
  n.add(i.position, "x").name("X"), n.add(i.position, "y").name("y"), n.add(i.position, "z").name("z");
  const s = e.addFolder("");
  mB(i, s);
}
function wB(i) {
  return i.map((e) => bB(e));
}
function TB(i, e) {
  e && e.forEach((t) => {
    const n = E1(t.type);
    SB(n, t), i.add(n);
  });
}
function EB(i, e, t) {
  const n = { lightType: "AmbientLight" };
  e.add(n, "lightType", ["AmbientLight", "DirectionalLight", "PointLight", "SpotLight", "HemisphereLight", "RectAreaLight"]).name(""), e.add({
    fn: function() {
      const s = E1(n.lightType);
      i.add(s), Sy(s, e.addFolder(s.type + s.id), t), t.attach(s);
    }
  }, "fn").name(""), i.children.forEach((s) => {
    s instanceof Ss && Sy(s, e.addFolder(s.type + s.id), t);
  });
}
function AB(i) {
  return {
    enabled: i.enabled,
    strength: i.strength,
    radius: i.radius,
    threshold: i.threshold
  };
}
function CB(i, e) {
  e && (i.enabled = e.enabled, i.strength = e.strength, i.radius = e.radius, i.threshold = e.threshold);
}
function RB(i, e) {
  e.add(i, "enabled").name(""), e.add(i, "strength").min(0).max(3).name(""), e.add(i, "radius").min(0).max(1).name(""), e.add(i, "threshold").min(0).max(1).name("");
}
const a0 = [vt, Gi, Ta, Tu, Eu, Fo], PB = [mi, Cm, Rm, Au, Cu], LB = [Bo, Lc, id, sd, Sr, wr, Ic, rd, Dc, ad, Pm], IB = [Bo, Lc, id, sd, Sr, wr, Ic, rd, Dc, ad];
function DB(i) {
  const { visible: e, color: t, wireframe: n, transparent: s, opacity: r, alphaTest: a, blending: o } = i;
  return {
    visible: e,
    color: t,
    wireframe: n,
    transparent: s,
    opacity: r,
    alphaTest: a,
    blending: o,
    ...OF(i)
  };
}
function OB(i, e, t) {
  const { visible: n, color: s, wireframe: r, transparent: a, opacity: o, alphaTest: l, blending: c, map: h, mapUrl: u, mapType: d } = t;
  e.visible = n, e.color.setHex(s), e.wireframe = r, e.transparent = a, e.opacity = o, e.alphaTest = l, e.blending = c, u && (e.mapUrl = u, e.mapType = d, w1(i, e, h));
}
function NB(i, e, t) {
  t.add(e, "visible").name(""), t.addColor({ color: e.color.getHex() }, "color").name("").onChange((n) => e.color.setHex(n)), t.add(e, "wireframe").name(""), t.add(e, "transparent").name(""), t.add(e, "opacity", 0, 1).name(""), t.add(e, "alphaTest", 0, 1).name(""), t.add(e, "blending", [0, 1, 2, 3, 4, 5]).name("").onChange((n) => {
    e.blending = a0[n], e.needsUpdate = !0;
  }), NF(i, e, t.addFolder(""));
}
function UB(i) {
  return {
    enabled: i.enabled,
    edgeStrength: i.edgeStrength,
    edgeGlow: i.edgeGlow,
    edgeThickness: i.edgeThickness,
    pulsePeriod: i.pulsePeriod,
    usePatternTexture: i.usePatternTexture,
    visibleEdgeColor: i.visibleEdgeColor.getHex(),
    hiddenEdgeColor: i.hiddenEdgeColor.getHex(),
    overlayMaterial: kB(i.overlayMaterial)
  };
}
function FB(i, e) {
  e && (i.enabled = e.enabled, i.edgeStrength = e.edgeStrength, i.edgeGlow = e.edgeGlow, i.edgeThickness = e.edgeThickness, i.pulsePeriod = e.pulsePeriod, i.usePatternTexture = e.usePatternTexture, i.visibleEdgeColor.setHex(e.visibleEdgeColor), i.hiddenEdgeColor.setHex(e.hiddenEdgeColor), zB(i.overlayMaterial, e.overlayMaterial));
}
function BB(i, e) {
  e.add(i, "enabled").name(""), e.add(i, "edgeStrength").name(""), e.add(i, "edgeGlow").name(""), e.add(i, "edgeThickness").name(""), e.add(i, "pulsePeriod").min(0).max(5).name(""), e.add(i, "usePatternTexture").name(""), e.addColor({ color: i.visibleEdgeColor.getHex() }, "color").onChange((t) => i.visibleEdgeColor.set(t)).name(""), e.addColor({ color: i.hiddenEdgeColor.getHex() }, "color").onChange((t) => i.hiddenEdgeColor.set(t)).name(""), HB(i.overlayMaterial, e.addFolder(""));
}
function kB(i) {
  return {
    blending: i.blending,
    blendEquation: i.blendEquation,
    blendSrc: i.blendSrc,
    blendDst: i.blendDst
  };
}
function zB(i, e) {
  e && (i.blending = e.blending, i.blendEquation = e.blendEquation, i.blendSrc = e.blendSrc, i.blendDst = e.blendDst);
}
function HB(i, e) {
  e.add(i, "blending", a0).name("").onChange((t) => i.blending = Number(t)), e.add(i, "blendEquation", PB).name("").onChange((t) => i.blendingEquation = Number(t)), e.add(i, "blendSrc", LB).name("").onChange((t) => i.blendingSrc = Number(t)), e.add(i, "blendDst", IB).name("").onChange((t) => i.blendingDst = Number(t));
}
function GB(i) {
  return {
    enabled: i.enabled,
    multPixel: i.multPixel
  };
}
function VB(i, e) {
  e && (i.enabled = e.enabled, i.multPixel != e.multPixel && (i.multPixel = e.multPixel, i.resize()));
}
function WB(i, e) {
  e.add(i, "enabled").name(""), e.add(i, "multPixel").name("").onChange(i.resize);
}
function XB(i) {
  if (!i) return;
  const { uniforms: e } = i;
  return {
    enabled: i.enabled,
    intensity: e.intensity.value,
    maskColor: e.maskColor.value.getHex(),
    R: e.R.value,
    sr: e.sr.value
  };
}
function qB(i, e) {
  if (!i) return;
  const { uniforms: t } = i;
  e && (i.enabled = e.enabled, t.intensity.value = e.intensity, t.maskColor.value.set(e.maskColor), t.R.value = e.R, t.sr.value = e.sr);
}
function YB(i, e) {
  if (!i) return;
  const { uniforms: t } = i;
  e.add(i, "enabled").name(""), e.add(t.intensity, "value").name(""), e.addColor({ color: t.maskColor.value.getHex() }, "color").name("").onChange((n) => t.maskColor.value.set(n)), e.add(t.R, "value").name(""), e.add(t.sr, "value").name("sr");
}
function jB(i) {
  return {
    enabled: i.enabled,
    maxDistance: i.maxDistance,
    distanceAttenuation: i.distanceAttenuation,
    opacity: i.opacity,
    thickness: i.thickness,
    fresnel: i.fresnel,
    infiniteThick: i.infiniteThick,
    bouncing: i.bouncing
  };
}
function ZB(i, e) {
  e && (i.enabled = e.enabled, i.maxDistance = e.maxDistance, i.distanceAttenuation = e.distanceAttenuation, i.opacity = e.opacity, i.thickness = e.thickness, i.fresnel = e.fresnel, i.infiniteThick = e.infiniteThick, i.bouncing = e.bouncing);
}
function $B(i, e) {
  e.add(i, "enabled").name(""), e.add(i, "maxDistance").name(""), e.add(i, "distanceAttenuation").name(""), e.add(i, "opacity").name(""), e.add(i, "thickness").name(""), e.add(i, "fresnel").name(""), e.add(i, "infiniteThick").name(""), e.add(i, "bouncing").name("");
}
function KB(i) {
  return {
    enabled: i.enabled,
    saoBias: i.params.saoBias,
    saoIntensity: i.params.saoIntensity,
    saoScale: i.params.saoScale,
    saoKernelRadius: i.params.saoKernelRadius,
    saoMinResolution: i.params.saoMinResolution,
    saoBlur: i.params.saoBlur,
    saoBlurRadius: i.params.saoBlurRadius,
    saoBlurStdDev: i.params.saoBlurStdDev,
    saoBlurDepthCutoff: i.params.saoBlurDepthCutoff
  };
}
function QB(i, e) {
  e && (i.enabled = e.enabled, i.params.saoBias = e.saoBias, i.params.saoIntensity = e.saoIntensity, i.params.saoScale = e.saoScale, i.params.saoKernelRadius = e.saoKernelRadius, i.params.saoMinResolution = e.saoMinResolution, i.params.saoBlur = e.saoBlur, i.params.saoBlurRadius = e.saoBlurRadius, i.params.saoBlurStdDev = e.saoBlurStdDev, i.params.saoBlurDepthCutoff = e.saoBlurDepthCutoff);
}
function JB(i, e) {
  e.add(i, "enabled").name(""), e.add(i.params, "saoBias").name(""), e.add(i.params, "saoIntensity").name(""), e.add(i.params, "saoScale", 0).name(""), e.add(i.params, "saoKernelRadius", 0).name(""), e.add(i.params, "saoMinResolution", 0).name(""), e.add(i.params, "saoBlur").name(""), e.add(i.params, "saoBlurRadius", 0).name(""), e.add(i.params, "saoBlurStdDev").name(""), e.add(i.params, "saoBlurDepthCutoff").name("");
}
function ek(i) {
  const { unrealBloomPass: e, outlinePass: t, fxaaPass: n, screenMaskPass: s, ssrPass: r, saoPass: a } = i.effectPass;
  return {
    renderWay: i.renderWay,
    saoPass: KB(a),
    unrealBloomPass: AB(e),
    outlinePass: UB(t),
    fxaaPass: GB(n),
    screenMaskPass: XB(s),
    ssrPass: jB(r)
  };
}
function tk(i, e) {
  if (!e) return;
  const { saoPass: t, unrealBloomPass: n, outlinePass: s, fxaaPass: r, screenMaskPass: a, ssrPass: o } = i.effectPass;
  i.setRenderWay(e.renderWay), QB(t, e.saoPass), CB(n, e.unrealBloomPass), FB(s, e.outlinePass), VB(r, e.fxaaPass), qB(a, e.screenMaskPass), ZB(o, e.ssrPass);
}
function nk(i, e) {
  const { saoPass: t, unrealBloomPass: n, outlinePass: s, fxaaPass: r, screenMaskPass: a, ssrPass: o } = i.effectPass;
  e.add(i, "renderWay", ["", ""]).name("").onChange((l) => i.setRenderWay(l)), JB(t, e.addFolder("")), RB(n, e.addFolder("")), BB(s, e.addFolder("")), WB(r, e.addFolder("")), YB(a, e.addFolder("")), $B(o, e.addFolder(""));
}
function ik(i, e, t, n, s) {
  return {
    camera: ZF(e),
    controls: QF(n),
    renderer: qF(t),
    lightGroup: wB(i.tempStorage.lightList),
    environment: oB(i),
    composer: ek(s)
  };
}
function sk(i, e, t, n, s, r) {
  YF(t, r.renderer), tk(s, r.composer), lB(i, r.environment), TB(i, r.lightGroup), $F(e, r.camera), JF(n, r.controls);
}
function rk(i, e, t, n, s, r, a) {
  jF(t, a.addFolder("")), KF(e, a.addFolder("")), eB(n, a.addFolder("")), cB(i, a.addFolder("")), EB(i, a.addFolder(""), r), nk(s, a.addFolder(""));
}
function ak(i, e) {
  const t = e.addFolder(""), n = {
    axies: "x",
    rotation: 0,
    fn() {
      var c;
      (c = i.currentInfo) != null && c.currentRootModel && i.currentInfo.currentRootModel.rotation.set(0, 0, 0);
    },
    setFn() {
      var c;
      (c = i.currentInfo) != null && c.currentRootModel && (i.currentInfo.currentRootModel.rotation[this.axies] += this.rotation / 180 * Math.PI);
    }
  };
  t.add(n, "axies", ["x", "y", "z"]).name(""), t.add(n, "rotation").name(""), t.add(n, "fn").name(""), t.add(n, "setFn").name("");
  const s = e.addFolder(""), r = {
    recordModel: null,
    recordFn() {
      var c;
      for (this.recordModel = (c = i.currentInfo) == null ? void 0 : c.currentRootModel; s.__controllers.length > 0; )
        s.__controllers[0].remove();
      this.recordModel && (s.open(), s.add(this.recordModel, "visible").name(""), s.add(this.recordModel, "name").name(""), s.add(this.recordModel, "id").name("id"), s.add({ fn: () => {
        var h;
        return (h = i.currentInfo) == null ? void 0 : h.currentRootModel.position.copy(this.recordModel.position);
      } }, "fn").name(""), s.add({ fn: () => {
        var h;
        return (h = i.currentInfo) == null ? void 0 : h.currentRootModel.rotation.copy(this.recordModel.rotation);
      } }, "fn").name(""), s.add({ fn: () => {
        var h;
        return (h = i.currentInfo) == null ? void 0 : h.currentRootModel.scale.copy(this.recordModel.scale);
      } }, "fn").name(""));
    },
    // 
    syncTransformList: [],
    syncTransformFn() {
      var c;
      if ((c = i.currentInfo) != null && c.currentRootModel && this.syncTransformList.indexOf(i.currentInfo.currentRootModel) === -1) {
        a.open();
        const h = i.currentInfo.currentRootModel;
        this.syncTransformList.push(h);
        const u = a.addFolder(h.id + "[" + Date.now() + "]");
        u.add(h, "visible").name(""), u.add({
          fn: () => {
            this.syncTransformList.splice(this.syncTransformList.indexOf(h), 1), a.removeFolder(u);
          }
        }, "fn").name("");
      }
    }
  };
  e.add(r, "recordFn").name("#");
  const a = e.addFolder("");
  e.add(r, "syncTransformFn").name("#");
  const o = a.addFolder(""), l = {
    position: { x: 0, y: 0, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    scale: { x: 0, y: 0, z: 0 },
    oldPosition: { x: 0, y: 0, z: 0 },
    oldRotation: { x: 0, y: 0, z: 0 },
    oldScale: { x: 0, y: 0, z: 0 }
  };
  ["x", "y", "z"].forEach((c) => o.add(l.position, c).name("" + c).onChange((h) => {
    r.syncTransformList.forEach((u) => u.position[c] += h - l.oldPosition[c]), l.oldPosition[c] = h;
  })), ["x", "y", "z"].forEach((c) => o.add(l.rotation, c, -2 * Math.PI, 2 * Math.PI).name("" + c).onChange((h) => {
    r.syncTransformList.forEach((u) => u.rotation[c] += h - l.oldRotation[c]), l.oldRotation[c] = h;
  })), ["x", "y", "z"].forEach((c) => o.add(l.scale, c).step(0.01).name("" + c).onChange((h) => {
    r.syncTransformList.forEach((u) => u.scale[c] += u.scale[c] * (h - l.oldScale[c])), l.oldScale[c] = h;
  }));
}
const Uo = {
  list: [],
  reList: [],
  index: -1
};
function ok(i) {
  return i.drag_change_callback = function(e) {
    Uo.index = -1;
    const { list: t, reList: n } = Uo, { object: s } = i;
    e ? t.push({ object: s, transform: No(s) }) : n.push({ object: s, transform: No(s) });
  }, Uo;
}
function wy(i) {
  const { list: e, reList: t, index: n } = Uo;
  if (i === "z") {
    const s = e.at(n);
    s && (ju(s.object, s.transform), Uo.index -= 1);
  } else if (i === "y") {
    if (n === -1) return;
    const s = t.at(n + 1);
    s && (ju(s.object, s.transform), Uo.index += 1);
  }
}
function lk(i, e) {
  function t(s, r) {
    if (!e.object) return;
    const a = e.object;
    switch (e.mode) {
      case "translate":
        a.position[s] += r;
        break;
      case "scale":
        a.scale[s] += r * 1e-3 * a.scale[s];
        break;
      case "rotate":
        a.rotation[s] += r * Math.PI / 360;
        break;
    }
  }
  function n(s) {
    var r, a;
    if (s.target.tagName !== "INPUT" && !s.ctrlKey) {
      switch (s.key) {
        case "1":
          i.mode = "";
          break;
        case "2":
          i.mode = "";
          break;
        case "3":
          i.mode = "";
          break;
        case "4":
          i.mode = "";
          break;
        case "5":
          i.mode = "";
          break;
        case "Tab":
          const { currentInfo: o } = i;
          o && (i.mode === "" ? e.attach(o.currentModel) : i.mode === "" ? e.attach(o.currentRootModel) : i.mode === "" && (s.preventDefault(), s.shiftKey ? e.setSpace(e.space === "local" ? "world" : "local") : (i.isTransformChildren = !i.isTransformChildren, e.detach())));
          break;
        case "Delete":
          if (!i.currentInfo) break;
          const { currentModel: l, currentRootModel: c } = i.currentInfo;
          if (i.mode === "" && l)
            l.visible = !1;
          else if (i.mode === "" && c)
            e.detach(), c.parent.remove(c);
          else if (i.mode === "" && c && !i.isTransformChildren) {
            const h = e.object || c;
            e.detach(), (r = h.parent) == null || r.remove(h);
          } else i.mode === "" && l && i.isTransformChildren && (l.visible = !1);
          break;
        case "g":
          e.setMode("translate");
          break;
        case "t":
          e.setMode("scale");
          break;
        case "r":
          e.setMode("rotate");
          break;
        case "w":
          t("y", 1);
          break;
        case "s":
          t("y", -1);
          break;
        case "a":
          t("x", -1);
          break;
        case "d":
          t("x", 1);
          break;
        case "q":
          t("z", 1);
          break;
        case "e":
          t("z", -1);
          break;
        case "z":
          wy("z");
          break;
        case "y":
          wy("y");
          break;
        case "Escape":
          e.detach();
          break;
      }
      (a = i.keyDownCallback) == null || a.call(i, s.key);
    }
  }
  return n;
}
const ck = {
  showAxes: !0,
  axesLength: 1e3,
  axesHelper: null
};
function hk(i) {
  return {
    showAxes: i.showAxes,
    axesLength: i.axesLength
  };
}
function uk(i, e, t) {
  t && (e.showAxes = t.showAxes, e.axesLength = t.axesLength, Pc(i, e));
}
function dk(i, e, t) {
  t.add(e, "showAxes").name("").listen().onChange(() => Pc(i, e)), t.add(e, "axesLength").name("").onFinishChange(() => Pc(i, e));
}
function fk(i = 1e3) {
  const e = new wg(i);
  return e.name = "AxesHelper", e;
}
function Pc(i, e) {
  e.axesHelper && (i.remove(e.axesHelper), e.axesHelper.geometry.dispose(), e.axesHelper.material.dispose(), e.axesHelper = null), e.showAxes && (e.axesHelper = fk(e.axesLength), i.add(e.axesHelper));
}
const pk = {
  showGrid: !0,
  size: 1e3,
  divisions: 100,
  colorCenterLine: 4473924,
  colorGrid: 8947848,
  gridHelper: null
};
function mk(i) {
  return {
    showGrid: i.showGrid,
    size: i.size,
    divisions: i.divisions,
    colorCenterLine: i.colorCenterLine,
    colorGrid: i.colorGrid
  };
}
function gk(i, e, t) {
  t && (e.showGrid = t.showGrid, e.size = t.size, e.divisions = t.divisions, e.colorCenterLine = t.colorCenterLine, e.colorGrid = t.colorGrid, cr(i, e));
}
function vk(i, e, t) {
  t.add(e, "showGrid").name("").listen().onChange(() => cr(i, e)), t.add(e, "size").name("").onFinishChange(() => cr(i, e)).min(1), t.add(e, "divisions").name("").onFinishChange(() => cr(i, e)).min(1), t.addColor(e, "colorCenterLine").name("").onFinishChange(() => cr(i, e)), t.addColor(e, "colorGrid").name("").onFinishChange(() => cr(i, e));
}
function _k(i = 1e3, e = 100, t = 4473924, n = 8947848) {
  const s = new Sg(i, e, t, n);
  return s.name = "GridHelper", s;
}
function cr(i, e) {
  e.gridHelper && (i.remove(e.gridHelper), e.gridHelper.geometry.dispose(), e.gridHelper.material.dispose(), e.gridHelper = null), e.showGrid && (e.gridHelper = _k(e.size, e.divisions, e.colorCenterLine, e.colorGrid), i.add(e.gridHelper));
}
const yk = {
  useBox3: !0,
  color: 16776960
};
function xk(i) {
  return {
    useBox3: i.useBox3,
    color: i.color
  };
}
function Mk(i, e, t, n) {
  n && (t.useBox3 = n.useBox3, t.color = n.color, Tm(i, e, t));
}
function bk(i, e, t, n) {
  n.add(t, "useBox3").name("Box3").listen().onChange(() => Tm(i, e, t)), n.addColor(t, "color").name("").onFinishChange(() => Tm(i, e, t));
}
function Tm(i, e, t) {
  e.box3Helper && (i.remove(e.box3Helper), e.box3Helper.geometry.dispose(), e.box3Helper.material.dispose(), e.box3Helper = null), t.useBox3 && (e.box3Helper = Sk(t.color), i.add(e.box3Helper), e.object && (e.box3Helper.box = new ln().setFromObject(e.object), e.box3Helper.visible = !0));
}
function Sk(i = 16776960) {
  const e = new ln(), t = new mM(e, i);
  return t.name = "Box3Helper", t.visible = !1, t;
}
const wk = {
  axes: ck,
  grid: pk,
  box3: yk
};
function Tk(i) {
  return {
    axes: hk(i.axes),
    grid: mk(i.grid),
    box3: xk(i.box3)
  };
}
function Ek(i, e, t, n) {
  n && (uk(i, t.axes, n.axes), gk(i, t.grid, n.grid), Mk(i, e, t.box3, n.box3));
}
function Ak(i, e, t, n) {
  const { axes: s, grid: r, box3: a } = t;
  dk(i, s, n.addFolder("")), vk(i, r, n.addFolder("")), bk(i, e, a, n.addFolder("Box3"));
}
const Ck = {
  showStats: !1,
  statsMode: 0
};
function Rk(i) {
  const { showStats: e, statsMode: t } = i;
  return {
    showStats: e,
    statsMode: t
  };
}
function Pk(i, e, t) {
  if (!t) return;
  const { showStats: n, statsMode: s } = t;
  e.showStats = n, e.statsMode = s, Ju(i, e);
}
function Lk(i, e, t) {
  t.add(e, "showStats").name("").listen().onChange(() => Ju(i, e)), t.add(e, "statsMode", [0, 1, 2]).name("").listen().onChange(() => Ju(i, e));
}
function Ju(i, e) {
  e.showStats ? (i.setStats(), i.setMode(Number(e.statsMode))) : i.destroy();
}
function Ik(i) {
  return {
    mode: i.mode,
    size: i.size,
    showX: i.showX,
    showY: i.showY,
    showZ: i.showZ,
    translationSnap: i.translationSnap,
    rotationSnap: i.rotationSnap,
    scaleSnap: i.scaleSnap
  };
}
function Dk(i, e) {
  e && (i.mode = e.mode, i.size = e.size, i.showX = e.showX, i.showY = e.showY, i.showZ = e.showZ, i.translationSnap = e.translationSnap, i.rotationSnap = e.rotationSnap, i.scaleSnap = e.scaleSnap);
}
function Ok(i, e) {
  e.add(i, "mode", ["translate", "rotate", "scale"]), e.add(i, "size"), e.add(i, "showX"), e.add(i, "showY"), e.add(i, "showZ"), !i.rotationSnap && (i.rotationSnap = 0), !i.translationSnap && (i.translationSnap = 0), !i.scaleSnap && (i.scaleSnap = 0), e.add(i, "translationSnap"), e.add(i, "rotationSnap"), e.add(i, "scaleSnap");
}
const uo = {
  mode: "",
  openKey: !1,
  keyDown: null,
  keyDownCallback: null,
  modeList: ["", "", "", "", ""],
  isTransformChildren: !1,
  handlerHistory: null,
  stats: Ck,
  helpers: wk
};
function Nk(i, e, t, n) {
  t.transformControls = n, t.keyDown = lk(t, n), Pc(i, t.helpers.axes), cr(i, t.helpers.grid), t.keyDownCallback = () => {
  }, t.setHandlerOption = (s, r) => {
    switch (s) {
      case "stats":
        t.stats.showStats = r, Ju(e, t.stats);
        break;
      case "axes":
        t.helpers.axes.showAxes = r, Pc(i, t.helpers.axes);
        break;
      case "grid":
        t.helpers.grid.showGrid = r, cr(i, t.helpers.grid);
        break;
      case "openKey":
        t.openKey = r, o0(t.keyDown, r);
        break;
    }
  }, t.handlerHistory = ok(n);
}
function Uk(i) {
  const { mode: e, openKey: t, isTransformChildren: n, stats: s, helpers: r, transformControls: a } = i;
  return {
    mode: e,
    openKey: t,
    isTransformChildren: n,
    stats: Rk(s),
    helpers: Tk(r),
    transformControls: Ik(a)
  };
}
function Fk(i, e, t, n, s) {
  s && (n.mode = s.mode, n.openKey = s.openKey, s.openKey && o0(n.keyDown, s.openKey), n.isTransformChildren = s.isTransformChildren, Pk(t, n.stats, s.stats), Ek(i, e, n.helpers, s.helpers), Dk(e, s.transformControls));
}
function Bk(i, e, t, n, s) {
  const { helpers: r } = n;
  s.add(n, "mode", n.modeList).name("").listen(), s.add(n, "isTransformChildren").name("").listen(), s.add(n, "openKey").name("").listen().onChange((a) => o0(n.keyDown, a)), ak(n, s.addFolder("")), Lk(t, n.stats, s.addFolder("")), Ak(i, e, r, s), Ok(e, s.addFolder(""));
}
function o0(i, e) {
  e ? document.addEventListener("keydown", i) : document.removeEventListener("keydown", i);
}
function kk(i, e, t, n = () => {
}) {
  switch (e) {
    case "GLTF":
      return bU(i, t, (s) => n(s));
    case "FBX":
      return MU(i, (s) => n(s));
    case "OBJ":
      return SU(i, (s) => n(s));
  }
}
function zk(i, e) {
  e.add(i.globalConfig, "isSaveChildren").name(""), e.add(i.globalConfig, "isSaveMaterials").name(""), e.add(i.globalConfig, "useGlobalConfig").name(""), Hk(i, e.addFolder("")), Gk(i, e.addFolder(""));
}
function Hk(i, e) {
  e.add(i.globalConfig.mesh, "castShadow").name("").onChange((t) => i.traverse((n) => n.castShadow = t)), e.add(i.globalConfig.mesh, "receiveShadow").name("").onChange((t) => i.traverse((n) => n.receiveShadow = t));
}
function Gk(i, e) {
  e.add(i.globalConfig.material, "envMap").name("").onChange((t) => {
    i.RootMaterials.forEach((n) => {
      n.envMap = t ? i.parent.background : null;
    });
  }), e.add(i.globalConfig.material, "envMapIntensity").name("").onChange((t) => i.RootMaterials.forEach((n) => n.envMapIntensity = t)).onFinishChange((t) => i.RootMaterials.forEach((n) => n.needsUpdate = !0)), e.add(i.globalConfig.material, "reflectivity", 0, 1).name("").onChange((t) => i.RootMaterials.forEach((n) => n.reflectivity = t)).onFinishChange((t) => i.RootMaterials.forEach((n) => n.needsUpdate = !0)), e.add(i.globalConfig.material, "isGlobalMap").name("").onChange((t) => {
    i.RootMaterials.forEach((n) => {
      t ? (n.map = n.recordMap, n.needsUpdate = !0) : (n.recordMap = n.map, n.map = null, n.needsUpdate = !0);
    });
  }).onFinishChange((t) => i.RootMaterials.forEach((n) => n.needsUpdate = !0));
}
function Vk(i, e) {
  if (i.globalConfig = e, !e.useGlobalConfig) return;
  const { mesh: t, material: n } = e;
  Wk(i, t), Xk(i, n);
}
function Wk(i, e) {
  i.traverse((t) => {
    t.castShadow = e.castShadow, t.receiveShadow = e.receiveShadow;
  });
}
function Xk(i, e) {
  i.RootMaterials.forEach((t) => {
    t.envMapIntensity = e.envMapIntensity, t.reflectivity = e.reflectivity, e.envMap && (t.envMap = i.parent.EnvBackground), e.isGlobalMap === !1 && (t.recordMap = t.map, t.map = null), t.needsUpdate = !0;
  }), e.envMap && i.parent.MeshEnvMapChangeUseList.push(() => i.RootMaterials.forEach((t) => t.envMap = i.parent.EnvBackground));
}
function qk(i, e, t) {
  t && (e.animationPlayParams = t, t.initPlay && l0(i, e, t));
}
function Yk(i, e, t) {
  if (!e.animationPlayParams) return;
  t.add(e.animationPlayParams, "initPlay").name(""), t.add(e.animationPlayParams, "speed").min(-10).max(10).name(""), t.add(e.animationPlayParams, "startTime").name(""), t.add(e.animationPlayParams, "loop").name("");
  const n = t.addFolder("");
  e.animations.map((s, r) => n.add(e.animationPlayParams.actionIndexs, r).name(s.name + ":" + s.duration.toFixed(2) + "s")), n.add({ fn: () => l0(i, e, e.animationPlayParams) }, "fn").name("");
}
function l0(i, e, t) {
  const n = IU(e, () => t.frameCallback), s = t.actionIndexs.map((r, a) => r && DU(n, e.animations[a], t.speed, t.startTime, t.loop).play()).filter((r) => r);
  return !i.find((r) => r === e) && i.push(e), { actions: s, mixer: n };
}
function jk(i) {
  var e;
  return i.globalConfig = {
    useGlobalConfig: !1,
    isSaveChildren: !0,
    isSaveMaterials: !0,
    mesh: {
      castShadow: !1,
      receiveShadow: !1
    },
    material: {
      envMap: !1,
      envMapIntensity: 1,
      reflectivity: 0.98,
      isGlobalMap: !0
    },
    geometry: {}
  }, i.RootMaterials = Kg(i), ((e = i.animations) == null ? void 0 : e.length) > 0 && (i.animationPlayParams = {
    initPlay: !1,
    speed: 0.5,
    actionIndexs: new Array(i.animations.length).fill(!1),
    startTime: 0,
    loop: !1,
    frameCallback: () => {
    }
  }), i;
}
function Zk(i) {
  const { animationPlayParams: e, children: t, RootMaterials: n, rootInfo: s } = i;
  return {
    group: {
      ...Vr(i),
      globalConfig: i.globalConfig,
      animationPlayParams: e,
      RootMaterials: i.globalConfig.isSaveMaterials ? n.map((r) => s0(r)) : void 0,
      children: i.globalConfig.isSaveChildren ? Wd(t) : void 0
    },
    rootInfo: s
  };
}
function $k(i, e, t) {
  t && (Wr(e, t), Vk(e, t.globalConfig), e.globalConfig.isSaveChildren && Xd(e.children, t.children), e.globalConfig.isSaveMaterials && e.RootMaterials.forEach((n, s) => r0(n, t.RootMaterials[s])), qk(i, e, t.animationPlayParams));
}
function Kk(i, e, t, n, s, r) {
  $s(s, r.addFolder("")), zk(s, r.addFolder("")), Yk(n, s, r.addFolder("")), r.add({ fn: () => e.attach(s) }, "fn").name(""), r.add({
    focus: () => {
      const { position: a, target: o } = r1(s);
      Cc(i.object.position, a), Cc(i.target, o), e.attach(s), t.effectPass.outlinePass.selectedObjects = [s];
    }
  }, "focus").name(""), r.add({
    delete: () => {
      e.detach(), s.parent.remove(s), r.parent.removeFolder(r);
    }
  }, "delete").name("");
}
function Wd(i) {
  return i.map((e) => ({
    ...Vr(e),
    children: Wd(e.children)
  }));
}
function Xd(i, e) {
  i.forEach((t, n) => {
    Wr(t, e[n]), t.children && Xd(t.children, e[n].children);
  });
}
const tc = {
  rootFolder: null,
  sceneInsertModel: null,
  animationPlay: l0
};
function Qk(i, e, t, n, s) {
  tc.sceneInsertModel = (r, a, o) => {
    const { url: l, type: c } = a;
    return kk(l, c, r, (h) => {
      i.add(jk(h)), h.rootInfo = a, $k(s, h, o), tc.rootFolder && Kk(e, t, n, s, h, tc.rootFolder.addFolder(h.name + h.id));
    });
  };
}
function Jk(i) {
  return i.map((e) => Zk(e));
}
function ez(i, e) {
  i.rootFolder = e;
}
const tz = ["", "", "", "", "", "", "", "", ""];
function hl(i, e = {}) {
  let t = null;
  switch (i) {
    case "":
      t = Ty(e);
      break;
    case "":
      t = nz(e);
      break;
    case "":
      t = iz(e);
      break;
    case "":
      t = rz(e);
      break;
    case "":
      t = az(e);
      break;
    case "":
      t = sz(e);
      break;
    case "":
      t = oz(e);
      break;
    case "":
      t = lz(e);
      break;
    case "":
      t = cz(e);
      break;
    default:
      t = Ty(e);
  }
  return t.geometryType = i, t;
}
function Ty(i = {}) {
  return new Pt(i.width || 5, i.height || 5, i.depth || 5, i.widthSegments || 1, i.heightSegments || 1, i.depthSegments || 1);
}
function nz(i = {}) {
  return new Fa(i.radius || 5, i.widthSegments || 32, i.heightSegments || 32);
}
function iz(i = {}) {
  return new Fr(i.width || 5, i.height || 5, i.widthSegments || 32, i.heightSegments || 32);
}
function sz(i = {}) {
  return new Hc(i.radius || 5, i.segments || 32, i.thetaStart || 0, i.thetaLength || Math.PI * 2);
}
function rz(i = {}) {
  return new zc(i.radius || 5, i.length || 5, i.capSegments || 32, i.radialSegments || 32);
}
function az(i = {}) {
  return new Gc(i.radius || 5, i.height || 5, i.radialSegments || 32);
}
function oz(i = {}) {
  return new qt(i.radiusTop || 5, i.radiusBottom || 5, i.height || 5, i.radialSegments || 32);
}
function lz(i = {}) {
  return new os(i.radius || 10, i.tube || 3, i.radialSegments || 32, i.tubularSegments || 32, i.arc || Math.PI * 2);
}
function cz(i = {}) {
  return new Vc(i.innerRadius || 5, i.outerRadius || 10, i.thetaSegments || 32, i.phiSegments || 32, i.thetaStart || 0, i.thetaLength || Math.PI * 2);
}
function hz(i, e) {
  const { geometry: t } = i, { parameters: n } = t, s = () => {
    t.dispose(), i.geometry = hl(t.geometryType, n);
  };
  switch (t.geometryType) {
    case "":
      e.add(n, "width", 0).name("").onChange(s), e.add(n, "height", 0).name("").onChange(s), e.add(n, "depth", 0).name("").onChange(s), e.add(n, "widthSegments", 0).name("").onChange(s).step(1), e.add(n, "heightSegments", 0).name("").onChange(s).step(1), e.add(n, "depthSegments", 0).name("").onChange(s).step(1);
      break;
    case "":
      e.add(n, "radius", 0).name("").onChange(s), e.add(n, "widthSegments", 0).name("").onChange(s), e.add(n, "heightSegments", 0).name("").onChange(s);
      break;
    case "":
      e.add(n, "width", 0).name("").onChange(s), e.add(n, "height", 0).name("").onChange(s), e.add(n, "widthSegments", 0).name("").onChange(s), e.add(n, "heightSegments", 0).name("").onChange(s);
      break;
    case "":
      e.add(n, "radius", 0).name("").onChange(s), e.add(n, "length", 0).name("").onChange(s), e.add(n, "capSegments", 0).name("").onChange(s), e.add(n, "radialSegments", 0).name("").onChange(s);
      break;
    case "":
      e.add(n, "radius", 0).name("").onChange(s), e.add(n, "height", 0).name("").onChange(s), e.add(n, "radialSegments", 0).name("").onChange(s);
      break;
    case "":
      e.add(n, "radius", 0).name("").onChange(s), e.add(n, "thetaStart", 0).name("").onChange(s), e.add(n, "thetaLength", 0, Math.PI * 2).name("").onChange(s);
      break;
    case "":
      e.add(n, "radiusTop", 0).name("").onChange(s), e.add(n, "radiusBottom", 0).name("").onChange(s), e.add(n, "height", 0).name("").onChange(s), e.add(n, "radialSegments", 0).name("").onChange(s);
      break;
    case "":
      e.add(n, "radius", 0).name("").onChange(s), e.add(n, "tube", 0).name("").onChange(s), e.add(n, "radialSegments", 0).name("").onChange(s), e.add(n, "tubularSegments", 0).name("").onChange(s), e.add(n, "arc", 0, Math.PI * 2).name("").onChange(s);
      break;
    case "":
      e.add(n, "innerRadius", 0).name("").onChange(s), e.add(n, "outerRadius", 0).name("").onChange(s), e.add(n, "thetaSegments", 0).name("").onChange(s), e.add(n, "phiSegments", 0).name("").onChange(s), e.add(n, "thetaStart", 0).name("").onChange(s), e.add(n, "thetaLength", 0, Math.PI * 2).name("").onChange(s);
      break;
  }
}
function uz(i) {
  switch (i.type) {
    case "MeshBasicMaterial":
      return {
        envMap: !!i.envMap,
        reflectivity: i.reflectivity
      };
    case "MeshStandardMaterial":
      return {
        emissive: i.emissive.getHex(),
        emissiveIntensity: i.emissiveIntensity,
        metalness: i.metalness,
        roughness: i.roughness,
        envMap: !!i.envMap,
        envMapIntensity: i.envMapIntensity
      };
    case "MeshLambertMaterial":
      return {
        emissive: i.emissive.getHex(),
        emissiveIntensity: i.emissiveIntensity,
        envMap: !!i.envMap,
        reflectivity: i.reflectivity
      };
    case "MeshPhongMaterial":
      return {
        shininess: i.shininess,
        specular: i.specular.getHex(),
        emissive: i.emissive.getHex(),
        emissiveIntensity: i.emissiveIntensity,
        envMap: !!i.envMap,
        reflectivity: i.reflectivity
      };
    case "MeshToonMaterial":
      return {
        emissive: i.emissive.getHex(),
        emissiveIntensity: i.emissiveIntensity
      };
    case "MeshPhysicalMaterial":
      return {
        metalness: i.metalness,
        roughness: i.roughness,
        clearcoat: i.clearcoat,
        clearcoatRoughness: i.clearcoatRoughness,
        sheen: i.sheen,
        sheenRoughness: i.sheenRoughness,
        sheenColor: i.sheenColor.getHex(),
        specularColor: i.specularColor.getHex(),
        specularIntensity: i.specularIntensity,
        transmission: i.transmission,
        emissive: i.emissive.getHex(),
        emissiveIntensity: i.emissiveIntensity,
        envMap: !!i.envMap,
        envMapIntensity: i.envMapIntensity,
        reflectivity: i.reflectivity
      };
  }
}
function dz(i, e, t) {
  switch (e.type) {
    case "MeshBasicMaterial":
      t.envMap && (e.envMap = i.EnvBackground, i.MeshEnvMapChangeUseList.push(() => e.envMap = i.EnvBackground)), e.reflectivity = t.reflectivity;
      break;
    case "MeshStandardMaterial":
      e.emissive.setHex(t.emissive), e.emissiveIntensity = t.emissiveIntensity, t.envMap && (e.envMap = i.EnvBackground, i.MeshEnvMapChangeUseList.push(() => e.envMap = i.EnvBackground)), e.envMapIntensity = t.envMapIntensity, e.metalness = t.metalness, e.roughness = t.roughness;
      break;
    case "MeshLambertMaterial":
      e.emissive.setHex(t.emissive), e.emissiveIntensity = t.emissiveIntensity, t.envMap && (e.envMap = i.EnvBackground, i.MeshEnvMapChangeUseList.push(() => e.envMap = i.EnvBackground)), e.reflectivity = t.reflectivity;
      break;
    case "MeshPhongMaterial":
      e.shininess = t.shininess, e.specular.setHex(t.specular), e.emissive.setHex(t.emissive), e.emissiveIntensity = t.emissiveIntensity, t.envMap && (e.envMap = i.EnvBackground, i.MeshEnvMapChangeUseList.push(() => e.envMap = i.EnvBackground)), e.reflectivity = t.reflectivity;
      break;
    case "MeshToonMaterial":
      e.emissive.setHex(t.emissive), e.emissiveIntensity = t.emissiveIntensity;
      break;
    case "MeshPhysicalMaterial":
      e.metalness = t.metalness, e.roughness = t.roughness, e.clearcoat = t.clearcoat, e.clearcoatRoughness = t.clearcoatRoughness, e.sheen = t.sheen, e.sheenRoughness = t.sheenRoughness, e.sheenColor.setHex(t.sheenColor), e.specularColor.setHex(t.specularColor), e.specularIntensity = t.specularIntensity, e.transmission = t.transmission, e.emissive.setHex(t.emissive), e.emissiveIntensity = t.emissiveIntensity, t.envMap && (e.envMap = i.EnvBackground, i.MeshEnvMapChangeUseList.push(() => e.envMap = i.EnvBackground)), e.envMapIntensity = t.envMapIntensity, e.reflectivity = t.reflectivity;
      break;
  }
}
function fz(i, e, t) {
  switch (e.type) {
    case "MeshBasicMaterial":
      t.add({ isEnvMap: !!e.envMap }, "isEnvMap").name("").onChange((n) => e.envMap = n ? i.EnvBackground : null), t.add(e, "reflectivity", 0, 1).name("");
      break;
    case "MeshStandardMaterial":
      t.addColor({ color: e.emissive.getHex() }, "color").name("").onChange((n) => e.emissive.setHex(n)), t.add(e, "emissiveIntensity", 0).name(""), t.add(e, "metalness", 0, 1).name(""), t.add(e, "roughness", 0, 1).name(""), t.add({ isEnvMap: !!e.envMap }, "isEnvMap").name("").onChange((n) => e.envMap = n ? i.EnvBackground : null), t.add(e, "envMapIntensity", 0).name("");
      break;
    case "MeshLambertMaterial":
      t.addColor({ color: e.emissive.getHex() }, "color").name("").onChange((n) => e.emissive.setHex(n)), t.add(e, "emissiveIntensity", 0).name(""), t.add({ isEnvMap: !!e.envMap }, "isEnvMap").name("").onChange((n) => e.envMap = n ? i.EnvBackground : null), t.add(e, "reflectivity", 0, 1).name("");
      break;
    case "MeshPhongMaterial":
      t.add(e, "shininess", 0, 100).name("").onChange((n) => e.needsUpdate = !0), t.addColor({ color: e.specular.getHex() }, "color").name("").onChange((n) => e.specular.setHex(n)), t.addColor({ color: e.emissive.getHex() }, "color").name("").onChange((n) => e.emissive.setHex(n)), t.add(e, "emissiveIntensity", 0).name(""), t.add({ isEnvMap: !!e.envMap }, "isEnvMap").name("").onChange((n) => e.envMap = n ? i.EnvBackground : null), t.add(e, "reflectivity", 0, 1).name("");
      break;
    case "MeshToonMaterial":
      t.addColor({ color: e.emissive.getHex() }, "color").name("").onChange((n) => e.emissive.setHex(n)), t.add(e, "emissiveIntensity", 0).name("");
      break;
    case "MeshPhysicalMaterial":
      t.add(e, "metalness", 0, 1).name(""), t.add(e, "roughness", 0, 1).name(""), t.add(e, "clearcoat", 0, 1).name(""), t.add(e, "clearcoatRoughness", 0, 1).name(""), t.add(e, "sheen", 0, 1).name(""), t.add(e, "sheenRoughness", 0, 1).name(""), t.addColor({ color: e.sheenColor.getHex() }, "color").name("").onChange((n) => e.sheenColor.setHex(n)), t.addColor({ color: e.specularColor.getHex() }, "color").name("").onChange((n) => e.specularColor.setHex(n)), t.add(e, "specularIntensity", 0, 1).name(""), t.add(e, "transmission", 0, 1).name(""), t.addColor({ color: e.emissive.getHex() }, "color").name("").onChange((n) => e.emissive.setHex(n)), t.add(e, "emissiveIntensity", 0).name(""), t.add({ isEnvMap: !!e.envMap }, "isEnvMap").name("").onChange((n) => e.envMap = n ? i.EnvBackground : null), t.add(e, "envMapIntensity", 0).name(""), t.add(e, "reflectivity", 0, 1).name("");
      break;
  }
}
function c0(i) {
  return {
    materialType: i.materialType,
    ...DB(i),
    ...uz(i)
  };
}
function h0(i, e, t, n) {
  n && (OB(e, t, n), dz(i, t, n));
}
function u0(i, e, t, n) {
  NB(e, t, n), fz(i, t, n.addFolder(t.materialType + ""));
}
const eh = ["", "", "", "Lambert", "", ""];
function Ni(i, e = null) {
  let t = null;
  switch (i) {
    case "":
      t = Ey(e);
      break;
    case "":
      t = pz(e);
      break;
    case "":
      t = mz(e);
      break;
    case "Lambert":
      t = gz(e);
      break;
    case "":
      t = vz(e);
      break;
    case "":
      t = _z(e);
      break;
    default:
      t = Ey(e);
  }
  return t.materialType = i, t.transparent = !0, t;
}
function Ey(i) {
  return new on({ color: 16777215, side: $t, ...i });
}
function pz(i) {
  return new al({ color: 16777215, side: $t, ...i });
}
function mz(i) {
  return new yr({ color: 16777215, side: $t, ...i });
}
function gz(i) {
  return new Od({ color: 16777215, side: $t, ...i });
}
function vz(i) {
  return new Xi({ color: 16777215, side: $t, ...i });
}
function _z(i) {
  return new lg({ color: 16777215, side: $t, ...i });
}
function yz(i) {
  const { material: e, geometry: t } = i, { geometryType: n, parameters: s } = t;
  return {
    ...Vr(i),
    geometry: {
      geometryType: n,
      parameters: s
    },
    material: c0(e)
  };
}
function xz(i, e, t) {
  if (!t) return;
  const { geometry: n, material: s } = t, { geometryType: r, parameters: a } = n, o = hl(r, a), l = Ni(s.materialType), c = th(o, l);
  return i.add(c), h0(i, e, c.material, s), Wr(c, t), c;
}
function Ay(i, e, t, n, s) {
  $s(n, s.addFolder("")), hz(n, s.addFolder("")), u0(i, t, n.material, s.addFolder("")), s.add({
    fn: () => {
      e.detach(), i.remove(n);
      const r = t.findIndex((a) => a.uuid == n.uuid);
      r > -1 && t.splice(r, 1), s.parent.removeFolder(s);
    }
  }, "fn").name("");
}
function th(i, e) {
  const t = new le(i, e);
  return t.isInnerMesh = !0, t;
}
const ss = {
  geometryType: "",
  materialType: "",
  meshList: null
};
function Mz(i) {
  return i.map((e) => yz(e));
}
function bz(i, e, t) {
  ss.meshList = t == null ? void 0 : t.map((n) => xz(i, e, n));
}
function Sz(i, e, t, n) {
  var s;
  ss.listFolder = n.addFolder(""), n.add(ss, "geometryType", tz).name(""), n.add(ss, "materialType", eh).name(""), n.add({
    add: () => {
      const r = hl(ss.geometryType), a = Ni(ss.materialType), o = th(r, a);
      i.add(o), e.attach(o), Ay(i, e, t, o, ss.listFolder.addFolder(o.geometry.geometryType + ":" + o.name + o.id));
    }
  }, "add").name(""), (s = ss.meshList) == null || s.forEach((r) => Ay(i, e, t, r, ss.listFolder.addFolder(r.geometry.geometryType + ":" + r.name + r.id)));
}
function wz(i, e) {
  var o, l;
  const t = [...e.drawPointList];
  if (t.length < 2) {
    e.mesh && (i.remove(e.mesh), e.mesh = null, (o = e.callback) == null || o.call(e, "remove"));
    return;
  }
  e.fenceClose && e.drawPointList.length > 2 && t.push(e.drawPointList[0]);
  const n = t.reduce((c, h) => {
    const u = new T().copy(h);
    return u.y += e.fenceHeight, [...c, u, h];
  }, []), { indexGroup: s, faceGroup: r, uvGroup: a } = a1(n);
  if (n.length > 3 && !e.mesh) {
    const c = o1(r, s, a), h = Ni(e.materialType, { color: 16777215 }), u = new le(c, h);
    u.isDrawMesh = !0, u.drawParams = e, e.mesh = u, i.add(e.mesh), (l = e.callback) == null || l.call(e, "set");
  } else e.mesh && l1(e.mesh.geometry, r, s, a);
}
function Tz(i, e) {
  var a, o;
  const t = [...e.drawPointList];
  if (t.length < 3) {
    e.mesh && (i.remove(e.mesh), e.mesh = null, (a = e.callback) == null || a.call(e, "remove"));
    return;
  }
  t.forEach((l) => l.y += 0.1);
  const { indexGroup: n, faceGroup: s, uvGroup: r } = a1(t, "face");
  if (e.drawPointList.length > 2 && !e.mesh) {
    const l = o1(s, n, r), c = Ni(e.materialType, { color: 16777215 }), h = new le(l, c);
    h.isDrawMesh = !0, h.drawParams = e, e.mesh = h, i.add(e.mesh), (o = e.callback) == null || o.call(e, "set");
  } else e.mesh && l1(e.mesh.geometry, s, n, r);
}
function Ez(i, e) {
  var u, d;
  const { drawPointList: t, height: n, axial: s, tubularSegments: r, radius: a, radialSegments: o, closed: l } = e;
  if (t.length < 2) {
    e.mesh && (i.remove(e.mesh), e.mesh = null, (u = e.callback) == null || u.call(e, "remove"));
    return;
  }
  const c = t.map((f) => new T(f.x, f.y, f.z)).map((f, m, g) => {
    if (g[m + 1]) {
      const p = f.clone().add(g[m + 1]).divideScalar(2);
      return p[s] += n, [f, p];
    } else return [f];
  }).flat(), h = new Ed(c);
  if (e.mesh)
    e.mesh.geometry.dispose(), e.mesh.geometry = new Vs(h, r, a, o, l);
  else {
    const f = new Vs(h, r, a, o, l), m = Ni(e.materialType, { color: 16777215 }), g = new le(f, m);
    g.isCurveMesh = !0, g.isDrawMesh = !0, g.drawParams = e, e.mesh = g, i.add(e.mesh), (d = e.callback) == null || d.call(e, "set");
  }
}
function Az(i, e) {
  var s, r;
  const { drawPointList: t } = e;
  if (t.length < 2) {
    e.mesh && (i.remove(e.mesh), e.mesh = null, (s = e.callback) == null || s.call(e, "remove"));
    return;
  }
  const n = e.drawPointList.reduce((a, o) => [...a, o.x, o.y + 1, o.z], []);
  if (!e.mesh && e.drawPointList.length > 1) {
    const a = UU(n);
    a.isDrawMesh = !0, a.drawParams = e, e.mesh = a, i.add(e.mesh), (r = e.callback) == null || r.call(e, "set");
  } else e.mesh && e.drawPointList.length > 0 && (e.mesh.geometry.dispose(), e.mesh.geometry.setPositions(n), e.mesh.computeLineDistances(), e.mesh.geometry.attributes.position.needsUpdate = !0);
}
function Cy(i, e, t, n, s, r) {
  const a = s.addFolder("");
  a.open();
  const o = r || {
    mode: i.mode,
    materialType: i.materialType,
    drawPointList: [],
    mesh: null
  };
  o.callback = function(c) {
    if (c === "remove")
      for (const h in a.__folders)
        a.removeFolder(a.__folders[h]);
    else {
      $s(this.mesh, a.addFolder(""));
      const h = a.addFolder("");
      u0(e, n, this.mesh.material, h), this.mode === "" && h.add(this.mesh.material, "linewidth").name("");
    }
  }, Cz(e, o, s, r), r && (o.drawPointList.forEach((c) => Ry(e, o, c, s)), o.callback("set"));
  function l(c) {
    o.drawPointList.push(c), Hi(e, o), Ry(e, o, c, s);
  }
  s.add({ fn: () => o.mesh && t.attach(o.mesh) }, "fn").name(""), s.add({ fn: () => {
    i.drawEventCall = l;
  } }, "fn").name(""), s.add({
    delete: () => {
      t.detach(), s.parent.removeFolder(s), o.mesh && e.remove(o.mesh), i.drawEventCall = null;
    }
  }, "delete").name(""), i.drawEventCall = l;
}
function Ry(i, e, t, n) {
  const s = e.drawPointList, r = n.add({
    fn: () => {
      const a = s.indexOf(t);
      s.splice(a, 1), Hi(i, e), n.remove(r);
    }
  }, "fn").name("" + [t.x, t.y, t.z].map((a) => a.toFixed(2)).join(","));
}
function Cz(i, e, t, n) {
  if (e.mode === "")
    n || (e.fenceHeight = 50, e.fenceClose = !0), t.add(e, "fenceHeight").name("").onChange(() => Hi(i, e)), t.add(e, "fenceClose").name("").onChange(() => Hi(i, e));
  else if (e.mode === "") {
    n || (e.height = 10, e.axial = "y", e.tubularSegments = 64, e.radius = 0.08, e.radialSegments = 8, e.closed = !1);
    const s = t.addFolder("");
    s.add(e, "height").name("").onChange(() => Hi(i, e)), s.add(e, "axial", ["x", "y", "z"]).name("").onChange(() => Hi(i, e)), s.add(e, "tubularSegments", 1).name("").onChange(() => Hi(i, e)).step(1), s.add(e, "radius", 0.01).name("").onChange(() => Hi(i, e)), s.add(e, "radialSegments", 1).name("").onChange(() => Hi(i, e)).step(1), s.add(e, "closed").name("").onChange(() => Hi(i, e));
  }
}
function Hi(i, e) {
  switch (e.mode) {
    case "":
      wz(i, e);
      break;
    case "":
      Tz(i, e);
      break;
    case "":
      Ez(i, e);
      break;
    case "":
      Az(i, e);
      break;
  }
}
function Rz(i) {
  const e = {};
  return Object.keys(i.drawParams).forEach((t) => {
    ["mesh", "folder", "callback"].includes(t) || (e[t] = i.drawParams[t]);
  }), {
    ...Vr(i),
    material: c0(i.material),
    draw_Params: e
  };
}
function Pz(i, e, t) {
  if (!t) return;
  const { draw_Params: n } = t;
  return Hi(i, n), Wr(n.mesh, t), h0(i, e, n.mesh.material, t.material), n;
}
const yn = {
  mode: "",
  pointMode: "",
  pointModeList: ["", "", ""],
  modeList: ["", "", "", ""],
  materialType: "",
  meshList: null,
  drawRootFolder: null,
  sceneEventCall: function(i, e) {
    var t, n, s, r, a;
    switch (this.pointMode) {
      case "":
        return (t = this.drawEventCall) == null ? void 0 : t.call(this, i);
      case "":
        return (n = e.geoInfo) != null && n.properties.centroidCoord3 ? (s = this.drawEventCall) == null ? void 0 : s.call(this, e.parent.getTransformedVector(e.geoInfo.properties.centroidCoord3.clone().add(e.position).sub(e.initTranslate))) : void 0;
      case "":
        return (r = e.geoInfo) != null && r.properties.centerCoord3 ? (a = this.drawEventCall) == null ? void 0 : a.call(this, e.parent.getTransformedVector(e.geoInfo.properties.centerCoord3.clone().add(e.position).sub(e.initTranslate))) : void 0;
    }
  },
  drawEventCall: null,
  currentDrawFolder: null
};
function Lz(i) {
  return i.map((e) => Rz(e));
}
function Iz(i, e, t, n) {
  i.meshList = n == null ? void 0 : n.map((s) => Pz(e, t, s));
}
function Dz(i, e, t, n) {
  var s;
  yn.drawRootFolder = n, n.add(yn, "mode", yn.modeList).name(""), n.add(yn, "pointMode", yn.pointModeList).name(""), n.add(yn, "materialType", eh).name(""), n.add({
    fn: () => {
      yn.currentDrawFolder && yn.currentDrawFolder.close(), yn.currentDrawFolder = n.addFolder(yn.mode + "-" + Date.now(), {}), Cy(yn, i, e, t, yn.currentDrawFolder), yn.currentDrawFolder.open();
    }
  }, "fn").name(""), (s = yn.meshList) == null || s.forEach((r) => {
    const { mesh: a } = r;
    Cy(yn, i, e, t, n.addFolder(a.name + a.id), r);
  });
}
function Oz(i, e) {
  i.forEach((t) => {
    t.geometry.type === "MultiPolygon" ? t.geometry.coordinates.forEach((n) => n.forEach((s) => Py(s, e, t))) : t.geometry.type === "Polygon" && t.geometry.coordinates.forEach((n) => Py(n, e, t));
  });
}
function Py(i, e, t = null) {
  const { globalConfig: n } = e, s = i.map((h) => pm(h)), r = new Wo(s), a = new _r();
  a.path = r, n.geometry.isEmpty ? a.holes.push(r) : a.curves.push(r);
  const o = new Ua(a, { depth: 20, bevelEnabled: !1, ...n.geometry.parameters }), l = Ni(e.materialType, { color: 16777215 * Math.random(), transparent: !0 }), c = new le(o, l);
  Nz(c, t), c1(c), e.attach(c);
}
function Nz(i, e) {
  var t, n;
  if (i.name = (t = e == null ? void 0 : e.properties) == null ? void 0 : t.name, e != null && e.properties.center) {
    const s = pm(e.properties.center);
    e.properties.centerCoord3 = new T(s.x, s.y, 0);
  }
  if ((n = e == null ? void 0 : e.properties) != null && n.centroid) {
    const s = pm(e.properties.centroid);
    e.properties.centroidCoord3 = new T(s.x, s.y, 0);
  }
  i.geoInfo = e;
}
function Uz(i, e) {
  const { label: t } = e.globalConfig;
  t.show && Em(i, e, t);
}
function Fz(i, e, t) {
  const { label: n } = e.globalConfig;
  t.add(n, "show").name("").onChange((a) => {
    a ? Em(i, e, n) : r();
  }), t.add(n, "type", ["2D", "3D"]).name("").onChange((a) => s("type")), t.addColor(n, "color").name("").onChange((a) => s("color")), t.add(n, "fontSize", 0).name("").onChange((a) => s("fontSize")), t.add(n, "fontWeight", ["400", "500", "600", "700", "800", "900"]).name("").onChange((a) => s("fontWeight")), t.add(n, "px").name("X").onChange((a) => s("px")), t.add(n, "py").name("Y").onChange((a) => s("py")), t.add(n, "pz").name("Z").onChange((a) => s("pz")), t.add(n, "rx", 0, Math.PI * 2).name("X").onChange((a) => s("rx")), t.add(n, "ry", 0, Math.PI * 2).name("Y").onChange((a) => s("ry")), t.add(n, "rz", 0, Math.PI * 2).name("Z").onChange((a) => s("rz")), t.add(n, "ss").name("").onChange((a) => s("ss")), t.add(n, "sx").name("X").onChange((a) => s("sx")), t.add(n, "sy").name("Y").onChange((a) => s("sy")), t.add(n, "sz").name("Z").onChange((a) => s("sz"));
  function s(a) {
    if (!e.labelGroup) return;
    const o = Object.values(e.labelGroup);
    switch (a) {
      case "type":
        r(), Em(i, e, n);
        break;
      case "color":
        o.forEach((l) => l.element.style.color = n[a]);
        break;
      case "fontSize":
        o.forEach((l) => l.element.style.fontSize = n[a] + "px");
        break;
      case "fontWeight":
        o.forEach((l) => l.element.style.fontWeight = n[a]);
        break;
      case "px":
        o.forEach((l) => l.position.x = l._position.x + n[a]);
        break;
      case "py":
        o.forEach((l) => l.position.y = l._position.y + n[a]);
        break;
      case "pz":
        o.forEach((l) => l.position.z = l._position.z + n[a]);
        break;
      case "rx":
        o.forEach((l) => l.rotation.x = n[a]);
        break;
      case "ry":
        o.forEach((l) => l.rotation.y = n[a]);
        break;
      case "rz":
        o.forEach((l) => l.rotation.z = n[a]);
        break;
      case "ss":
        o.forEach((l) => l.scale.setScalar(n[a]));
        break;
      case "sx":
        o.forEach((l) => l.scale.x = n[a]);
        break;
      case "sy":
        o.forEach((l) => l.scale.y = n[a]);
        break;
      case "sz":
        o.forEach((l) => l.scale.z = n[a]);
        break;
    }
  }
  function r() {
    e.labelGroup && Object.keys(e.labelGroup).forEach((a) => {
      i.remove(e.labelGroup[a]), delete e.labelGroup[a];
    });
  }
}
function Em(i, e, t) {
  e.labelGroup = {};
  const { type: n, color: s, fontSize: r, fontWeight: a, px: o, py: l, pz: c, rx: h, ry: u, rz: d, ss: f, sx: m, sy: g, sz: p } = t;
  e.children.forEach((v) => {
    var y, _, x, M, S, w, E;
    if ((y = v.geoInfo) != null && y.properties.name && !e.labelGroup[v.geoInfo.properties.name]) {
      const b = (((_ = v.geoInfo) == null ? void 0 : _.properties.centroidCoord3) || ((x = v.geoInfo) == null ? void 0 : x.properties.centerCoord3)).add(v.position).sub(v.initTranslate), A = e.getTransformedVector(b), D = document.createElement("div");
      D.innerText = ((S = (M = v.geoInfo) == null ? void 0 : M.properties) == null ? void 0 : S.name) || "", D.style.color = s, D.style.fontSize = r + "px", D.style.fontWeight = a;
      const B = n === "2D" ? new Rb(D) : new Pb(D);
      B._position = A, B.position.set(B._position.x + o, B._position.y + l, B._position.z + c), B.rotation.set(h, u, d), B.scale.set(m, g, p), B.scale.setScalar(f), i.add(B), D.style.pointerEvents = "none", e.labelGroup[(E = (w = v.geoInfo) == null ? void 0 : w.properties) == null ? void 0 : E.name] = B;
    }
  });
}
function Bz(i) {
  if (!i.globalConfig)
    return i.globalConfig = {
      useGlobalConfig: !1,
      isSaveChildren: !0,
      isSaveMaterials: !0,
      mesh: {
        castShadow: !1,
        receiveShadow: !1
      },
      material: {
        color: 16777215,
        wireframe: !1,
        transparent: !0,
        opacity: 1,
        metalness: 0,
        roughness: 0,
        emissive: 0,
        emissiveIntensity: 1,
        // 
        clearcoat: 0,
        clearcoatRoughness: 0,
        sheen: 0,
        sheenRoughness: 0,
        sheenColor: 0,
        transmission: 0,
        envMap: !1,
        envMapIntensity: 1,
        reflectivity: 0.98,
        mapUrl: "",
        textureAnimation: {
          isTextureAnimation: !1,
          offset: { x: 0, y: 0.01 },
          rotation: 0
        },
        map: {
          repeat: { x: 1, y: 1 },
          offset: { x: 0, y: 0 },
          center: { x: 0, y: 0 },
          rotation: 0
        }
      },
      geometry: {
        geometryType: "",
        isEmpty: !1,
        parameters: {
          depth: 16,
          bevelEnabled: !1,
          bevelThickness: 0,
          bevelSize: 0,
          bevelOffset: 0
        }
      },
      label: {
        show: !1,
        type: "2D",
        color: "#fff",
        fontSize: 12,
        fontWeight: 400,
        px: 0,
        py: 0,
        pz: 0,
        rx: 0,
        ry: 0,
        rz: 0,
        ss: 1,
        sx: 1,
        sy: 1,
        sz: 1
      }
    }, i;
}
function A1(i, e, t) {
  const { globalConfig: n } = t;
  if (!n.useGlobalConfig) return;
  const { mesh: s, material: r } = n;
  if (t.children.forEach((o) => {
    o.castShadow = s.castShadow, o.receiveShadow = s.receiveShadow;
  }), r.mapUrl) {
    const o = new Ys().load(r.mapUrl);
    o.wrapS = Tn, o.wrapT = Tn, o.repeat.set(r.map.repeat.x, r.map.repeat.y), o.offset.set(r.map.offset.x, r.map.offset.y), o.center.set(r.map.center.x, r.map.center.y), o.rotation = r.map.rotation, t.texture = o, t.frameAnimationRender = function() {
      this.texture.offset.x += this.globalConfig.material.textureAnimation.offset.x, this.texture.offset.y += this.globalConfig.material.textureAnimation.offset.y, this.texture.rotation += this.globalConfig.material.textureAnimation.rotation;
    }, e.push(t);
  }
  t.RootMaterials.forEach((o) => {
    o.color.set(r.color), o.wireframe = r.wireframe, o.transparent = r.transparent, o.opacity = r.opacity, ["", ""].includes(t.materialType) && (o.metalness = r.metalness, o.roughness = r.roughness), t.materialType !== "" && (o.emissive.set(r.emissive), o.emissiveIntensity = r.emissiveIntensity), t.materialType === "" && (o.clearcoat = r.clearcoat, o.clearcoatRoughness = r.clearcoatRoughness, o.sheen = r.sheen, o.sheenRoughness = r.sheenRoughness, o.sheenColor.set(r.sheenColor), o.transmission = r.transmission), o.envMap = r.envMap ? i.EnvBackground : null, o.envMapIntensity = r.envMapIntensity, o.reflectivity = r.reflectivity, o.map = t.texture, o.needsUpdate = !0;
  });
  const a = () => t.RootMaterials.forEach((o) => {
    o.envMap = t.parent.EnvBackground, o.envMapIntensity = r.envMapIntensity, o.reflectivity = r.reflectivity;
  });
  t.parent.MeshEnvMapChangeUseList.push(a);
}
function kz(i, e, t, n) {
  const { globalConfig: s } = t;
  n.add(s, "isSaveChildren").name(""), n.add(s, "isSaveMaterials").name(""), n.add(s, "useGlobalConfig").name("");
  const r = n.addFolder("");
  r.add(s.mesh, "castShadow").name("").onChange(() => t.children.forEach((a) => a.castShadow = s.mesh.castShadow)), r.add(s.mesh, "receiveShadow").name("").onChange(() => t.children.forEach((a) => a.receiveShadow = s.mesh.receiveShadow)), zz(t, n.addFolder("")), C1(i, e, t, n.addFolder(""));
}
function zz(i, e) {
  const { globalConfig: t } = i;
  let n = null;
  function s() {
    n && clearTimeout(n), n = setTimeout(() => {
      i.children.forEach((r) => {
        r.geometry.dispose(), t.geometry.isEmpty ? (r.geometry.parameters.shapes.holes = [r.geometry.parameters.shapes.path], r.geometry.parameters.shapes.curves = []) : (r.geometry.parameters.shapes.curves = [r.geometry.parameters.shapes.path], r.geometry.parameters.shapes.holes = []), r.geometry = new Ua(r.geometry.parameters.shapes, t.geometry.parameters), r.geometry.center();
      }), n = null;
    }, 200);
  }
  e.add(t.geometry, "isEmpty").name("").onChange(s), e.add(t.geometry.parameters, "depth").name("").onChange(s).min(1e-3), e.add(t.geometry.parameters, "bevelEnabled").name("").onChange(s), e.add(t.geometry.parameters, "bevelThickness").name("").onChange(s).min(0), e.add(t.geometry.parameters, "bevelSize").name("").onChange(s).min(0), e.add(t.geometry.parameters, "bevelOffset").name("").onChange(s).min(0);
}
function C1(i, e, t, n) {
  const { globalConfig: s } = t, { material: r } = s;
  n.addColor(r, "color").name("").onChange((a) => t.RootMaterials.forEach((o) => o.color.set(a))), n.add(r, "wireframe").name("").onChange((a) => t.RootMaterials.forEach((o) => o.wireframe = a)), n.add(r, "transparent").name("").onChange((a) => t.RootMaterials.forEach((o) => o.transparent = a)), n.add(r, "opacity", 0, 1).name("").onChange((a) => t.RootMaterials.forEach((o) => o.opacity = a)), ["", ""].includes(t.materialType) && (n.add(r, "metalness", 0, 1).name("").onChange((a) => t.RootMaterials.forEach((o) => o.metalness = a)), n.add(r, "roughness", 0, 1).name("").onChange((a) => t.RootMaterials.forEach((o) => o.roughness = a))), t.materialType !== "" && (n.addColor(r, "emissive").name("").onChange((a) => t.RootMaterials.forEach((o) => o.emissive.set(a))), n.add(r, "emissiveIntensity", 0).name("").onChange((a) => t.RootMaterials.forEach((o) => o.emissiveIntensity = a))), t.materialType !== "" && (n.add(r, "envMap").name("").onChange((a) => t.RootMaterials.forEach((o) => a ? o.envMap = i.EnvBackground : o.envMap = null)), n.add(r, "envMapIntensity", 0).name("").onChange((a) => t.RootMaterials.forEach((o) => o.envMapIntensity = a)), n.add(r, "reflectivity", 0, 1).name("").onChange((a) => t.RootMaterials.forEach((o) => o.reflectivity = a))), t.materialType === "" && (n.add(r, "clearcoat", 0, 1).name("").onChange((a) => t.RootMaterials.forEach((o) => o.clearcoat = a)), n.add(r, "clearcoatRoughness", 0, 1).name("").onChange((a) => t.RootMaterials.forEach((o) => o.clearcoatRoughness = a)), n.add(r, "sheen", 0, 1).name("").onChange((a) => t.RootMaterials.forEach((o) => o.sheen = a)), n.add(r, "sheenRoughness", 0, 1).name("").onChange((a) => t.RootMaterials.forEach((o) => o.sheenRoughness = a)), n.addColor(r, "sheenColor").name("").onChange((a) => t.RootMaterials.forEach((o) => o.sheenColor.set(a))), n.add(r, "transmission", 0, 1).name("").onChange((a) => t.RootMaterials.forEach((o) => o.transmission = a))), n.add({ fn: () => t.RootMaterials.forEach((a) => a.needsUpdate = !0) }, "fn").name(""), Hz(e, t, n.addFolder(""));
}
function Hz(i, e, t) {
  const { material: n } = e.globalConfig;
  if (n.mapUrl) {
    r();
    const { textureAnimation: o } = n;
    o.isTextureAnimation && a(!0);
  }
  t.add(n, "mapUrl").name("");
  function s(o) {
    e.RootMaterials.forEach((l) => {
      l.map && (l.map[o] = n.map[o]);
    });
  }
  function r() {
    const { mapUrl: o, map: l } = n;
    if (!o) return;
    const c = new Ys().load(o);
    c.wrapS = Tn, c.wrapT = Tn, c.repeat.set(l.repeat.x, l.repeat.y), c.offset.set(l.offset.x, l.offset.y), c.center.set(l.center.x, l.center.y), c.rotation = l.rotation, e.texture = c, e.RootMaterials.forEach((h) => {
      h.map = c, h.needsUpdate = !0;
    });
  }
  function a(o) {
    o ? (e.frameAnimationRender = function() {
      this.texture.offset.x += this.globalConfig.material.textureAnimation.offset.x, this.texture.offset.y += this.globalConfig.material.textureAnimation.offset.y, this.texture.rotation += this.globalConfig.material.textureAnimation.rotation;
    }, i.push(e)) : (delete e.texture.frameAnimationRender, i.splice(i.findIndex((l) => l.uuid == e.uuid), 1));
  }
  t.add(n.map.repeat, "x").name("").onChange((o) => s("repeat")), t.add(n.map.repeat, "y").name("").onChange((o) => s("repeat")), t.add(n.map.offset, "x").name("").onChange((o) => s("offset")), t.add(n.map.offset, "y").name("").onChange((o) => s("offset")), t.add(n.map, "rotation", 0, Math.PI * 2).name("").onChange((o) => s("rotation")), t.add(n.map.center, "x").name("").onChange((o) => s("center")), t.add(n.map.center, "y").name("").onChange((o) => s("center")), t.add(n.textureAnimation, "isTextureAnimation").name("").onChange((o) => a(o)), t.add(n.textureAnimation.offset, "x").name(""), t.add(n.textureAnimation.offset, "y").name(""), t.add(n.textureAnimation, "rotation", 0, Math.PI * 2).name(""), t.add({ fn: () => r() }, "fn").name("");
}
function Gz(i) {
  const { children: e, RootMaterials: t } = i;
  return {
    ...Vr(i),
    globalConfig: i.globalConfig,
    url: i.url,
    materialType: i.materialType,
    RootMaterials: i.globalConfig.isSaveMaterials ? t.map((n) => s0(n)) : void 0,
    children: i.globalConfig.isSaveChildren ? Wd(e) : void 0
  };
}
async function Vz(i, e, t) {
  if (!t) return;
  const n = new Gn();
  return n.url = t.url, n.materialType = t.materialType, n.globalConfig = t.globalConfig, await R1(i, n), Wr(n, t), A1(i, e, n), n.globalConfig.isSaveChildren && Xd(n.children, t.children), n.globalConfig.isSaveMaterials && n.RootMaterials.forEach((s, r) => r0(s, t.RootMaterials[r])), Uz(i, n), n;
}
function Wz(i, e) {
  const t = new Gn();
  return t.url = i, t.materialType = e, Bz(t), t;
}
async function R1(i, e) {
  const t = await fetch(e.url).then((n) => n.json());
  return Oz(t.features, e), h1(e), e.RootMaterials = Kg(e), e.rotation.x = -Math.PI / 2, e.isGeoGroup = !0, i.add(e), e;
}
function Ly(i, e, t, n, s) {
  $s(n, s.addFolder("")), kz(i, t, n, s.addFolder("")), Fz(i, n, s.addFolder("")), s.add({
    fn: () => {
      var r;
      s.parent.removeFolder(s), e.detach(), i.remove(n), (r = n.disposeRoot) == null || r.call(n);
    }
  }, "fn").name("");
}
const bn = {
  url: "",
  materialType: "",
  geoGroupCallPanel: null,
  geoGroupLoadCall: null,
  geoGroupAllLoadedCall: null
};
function Xz(i, e, t, n) {
  const s = n.addFolder("");
  n.add(bn, "url").name(""), n.add(bn, "materialType", eh).name(""), n.add({
    fn: () => {
      R1(i, Wz(bn.url || "https://z2586300277.github.io/3d-file-server/files/json/guangdong.json", bn.materialType)).then((r) => {
        Ly(i, e, t, r, s.addFolder(r.name + r.id));
      });
    }
  }, "fn").name(""), bn.geoGroupCallPanel = (r) => Ly(i, e, t, r, s.addFolder(r.name + r.id));
}
function qz(i) {
  return i.map((e) => Gz(e));
}
function Yz(i, e, t) {
  if (!t) return;
  const n = t == null ? void 0 : t.map((s) => Vz(i, e, s).then((r) => {
    var a, o;
    (a = bn.geoGroupCallPanel) == null || a.call(bn, r), (o = bn.geoGroupLoadCall) == null || o.call(bn, r);
  }));
  Promise.all(n).then(() => {
    var s;
    return (s = bn.geoGroupAllLoadedCall) == null ? void 0 : s.call(bn);
  });
}
function P1(i, e, t, n) {
  const s = L1(n), r = jz(e, n), a = new ya(s, r);
  return a.parameters = n, a.frameAnimationRender = () => {
    var o, l, c, h;
    (l = (o = a.geometry).geometryRender) == null || l.call(o), (h = (c = a.material).materialRender) == null || h.call(c);
  }, a.isParticleMesh = !0, i.add(a), t.push(a), a;
}
function L1(i) {
  if (i.outer - i.inner < 1) return new Be();
  const e = new Float32Array(i.particlesSum * 3), t = new Float32Array(i.particlesSum * 3), n = {
    : (a) => {
      t[a * 3] += (Math.random() - 0.5) * i.maxVelocity / 1e3, t[a * 3 + 1] += (Math.random() - 0.5) * i.maxVelocity / 1e3, t[a * 3 + 2] += (Math.random() - 0.5) * i.maxVelocity / 1e3;
    },
    : (a) => {
      t[a * 3] += (Math.random() - 0.5) * i.maxVelocity / 1e3, t[a * 3 + 1] += Math.abs((Math.random() - 0.5) * i.maxVelocity / 1e5), t[a * 3 + 2] += (Math.random() - 0.5) * i.maxVelocity / 1e3;
    },
    : (a) => {
      t[a * 3] += (Math.random() - 0.5) * i.maxVelocity / 1e3, t[a * 3 + 1] -= Math.abs((Math.random() - 0.5) * i.maxVelocity / 1e5), t[a * 3 + 2] += (Math.random() - 0.5) * i.maxVelocity / 1e3;
    },
    : (a) => {
      t[a * 3] = 0, t[a * 3 + 1] += i.maxVelocity / 2 / 1e5, t[a * 3 + 2] = 0;
    },
    : (a) => {
      t[a * 3] = 0, t[a * 3 + 1] -= i.maxVelocity / 2 / 1e5, t[a * 3 + 2] = 0;
    }
  }[i.sportType];
  function s() {
    let a, o, l;
    do
      a = Math.random() * 2 * i.outer - i.outer, o = Math.random() * 2 * i.outer - i.outer, l = Math.random() * 2 * i.outer - i.outer;
    while (Math.abs(a) <= i.inner && Math.abs(o) <= i.inner && Math.abs(l) <= i.inner);
    return [a, o, l];
  }
  for (let a = 0; a < i.particlesSum; a++)
    e.set(s(), a * 3);
  const r = new Be();
  return r.setAttribute("position", new dt(e, 3)), r.geometryRender = () => {
    for (let a = 0; a < i.particlesSum; a++)
      if (n(a), e[a * 3] += t[a * 3], e[a * 3 + 1] += t[a * 3 + 1], e[a * 3 + 2] += t[a * 3 + 2], Math.abs(e[a * 3]) > i.outer || Math.abs(e[a * 3 + 1]) > i.outer || Math.abs(e[a * 3 + 2]) > i.outer || Math.abs(e[a * 3]) < i.inner && Math.abs(e[a * 3 + 1]) < i.inner && Math.abs(e[a * 3 + 2]) < i.inner) {
        const [o, l, c] = s();
        e[a * 3] = o, e[a * 3 + 1] = l, e[a * 3 + 2] = c, t[a * 3] = 0, t[a * 3 + 1] = 0, t[a * 3 + 2] = 0;
      }
    r.attributes.position.needsUpdate = !0;
  }, r;
}
function jz(i, e) {
  const { uniforms: t, glslProps: n, ShaderAnimateRender: s } = f1[e.shaderCodeName](i), r = {
    pointTexture: {
      value: new Ys().load(e.mapUrl),
      type: "texture",
      unit: "sampler2D"
    },
    size: {
      value: 100,
      type: "number",
      unit: "float"
    },
    discardVal: {
      value: 0.5,
      type: "number",
      unit: "float"
    },
    opacity: {
      value: 1,
      type: "opacity",
      unit: "float"
    },
    // 
    isdecaySize: {
      value: !0,
      type: "bool",
      unit: "bool"
    }
  }, a = Object.assign(t, r), o = new mt({
    uniforms: a,
    vertexShader: `

        uniform float size;

        uniform bool isdecaySize;

        void main() {

            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

            gl_PointSize = isdecaySize ? size * ( 300.0 / -mvPosition.z ) : size;

            gl_Position = projectionMatrix * mvPosition;

        } `,
    fragmentShader: Xn(a) + (n.fragFunc || "") + `

        void main() {

            vec2 vUv = gl_PointCoord.xy - .5;` + n.fragBody + n.pointFragIn + `vec3 useColor = effect_color;
            vec4 textureColor = texture2D( pointTexture, gl_PointCoord );
            if (textureColor.a < discardVal) discard;
            else useColor *= textureColor.rgb;
            gl_FragColor = vec4( mix( mixColor, useColor * vec3( intensity, intensity, intensity), mixRatio ) , opacity );
        }`,
    transparent: !0,
    depthTest: !0,
    blending: Ta
  });
  return o.materialRender = s, o;
}
function Zz(i) {
  const { material: e } = i, { uniforms: t, blending: n, depthTest: s } = e;
  return {
    ...Vr(i),
    parameters: i.parameters,
    material: {
      uniforms: p1(t),
      blending: n,
      depthTest: s
    }
  };
}
function $z(i, e, t, n) {
  if (!n) return;
  const s = P1(i, e, t, n.parameters);
  Wr(s, n);
  const { material: r } = n;
  return s.material.blending = r.blending, s.material.depthTest = r.depthTest, m1(s.material.uniforms, r.uniforms), r.needsUpdate = !0, s;
}
function Iy(i, e, t, n) {
  $s(t, n.addFolder("")), Kz(t, n.addFolder("")), Qz(t.material, n.addFolder("")), n.add({ fn: () => e.attach(t) }, "fn").name(""), n.add({
    fn: () => {
      e.detach(), i.remove(t), n.parent.removeFolder(n);
    }
  }, "fn").name("");
}
function Kz(i, e) {
  let t = null;
  function n() {
    t || (i.geometry.dispose(), i.geometry = new Be(), t = setTimeout(() => {
      i.geometry = L1(i.parameters), t = null;
    }, 200));
  }
  e.add(i.parameters, "particlesSum", 1).name("").onChange(n), e.add(i.parameters, "inner", 0).name("").onChange(n), e.add(i.parameters, "outer", 500).name("").onChange(n), e.add(i.parameters, "maxVelocity").name("").onChange(n), e.add(i.parameters, "sportType", ["", "", "", "", ""]).name("").onChange(n);
}
function Qz(i, e) {
  e.add(i, "depthTest").name("").onChange(() => i.needsUpdate = !0), e.add(i, "blending", [0, 1, 2, 3, 4, 5]).name("").onChange((t) => {
    i.blending = a0[t], i.needsUpdate = !0;
  }), gm(i.uniforms, e.addFolder(""));
}
const fi = {
  particlesSum: 1e5,
  inner: 0,
  outer: 2e3,
  maxVelocity: 50,
  mapUrl: "https://z2586300277.github.io/three-editor/dist/files/channels/snow.png",
  sportType: "",
  shaderCodeName: "",
  meshList: null
};
function Jz(i, e, t, n) {
  fi.meshList = n == null ? void 0 : n.map((s) => $z(i, e, t, s));
}
function e4(i) {
  return i.map((e) => Zz(e));
}
function t4(i, e, t, n, s) {
  var o;
  const r = s.addFolder(""), a = s.addFolder("");
  a.add(fi, "particlesSum").name(""), a.add(fi, "inner").name(""), a.add(fi, "outer").name(""), a.add(fi, "maxVelocity").name(""), a.add(fi, "mapUrl").name(""), a.add(fi, "shaderCodeName", Object.keys(f1)).name(""), a.add(fi, "sportType", ["", "", "", "", ""]).name(""), s.add({
    fn: () => {
      const { particlesSum: l, inner: c, outer: h, maxVelocity: u, sportType: d, mapUrl: f, shaderCodeName: m } = fi, g = P1(i, t, n, {
        particlesSum: l,
        inner: c,
        outer: h,
        maxVelocity: u,
        sportType: d,
        mapUrl: f,
        shaderCodeName: m
      });
      Iy(i, e, g, r.addFolder(g.name + g.id)), r.open();
    }
  }, "fn").name(""), (o = fi.meshList) == null || o.forEach((l) => Iy(i, e, l, r.addFolder(l.name + l.id)));
}
function n4(i) {
  const { children: e, RootMaterials: t } = i;
  return {
    ...Vr(i),
    globalConfig: i.globalConfig,
    url: i.url,
    dlength: i.dlength,
    materialType: i.materialType,
    RootMaterials: i.globalConfig.isSaveMaterials ? t.map((n) => s0(n)) : void 0,
    children: i.globalConfig.isSaveChildren ? Wd(e) : void 0
  };
}
async function i4(i, e, t) {
  if (!t) return;
  const n = await I1(t.url, t.materialType, t.dlength);
  n.globalConfig = t.globalConfig;
  const { geometry: s } = n.globalConfig;
  return n.children.forEach((r) => {
    r.geometry.dispose(), r.geometry = new Vs(r.curve, (r.curve.points.length - 1) * s.tubularSegmentsMultiple, s.radius, s.radialSegments, s.closed), r.geometry.center();
  }), i.add(n), Wr(n, t), A1(i, e, n), n.globalConfig.isSaveChildren && Xd(n.children, t.children), n.globalConfig.isSaveMaterials && n.RootMaterials.forEach((r, a) => r0(r, t.RootMaterials[a])), n;
}
function Dy(i, e, t, n, s) {
  $s(n, s.addFolder(""));
  const { globalConfig: r } = n;
  s.add(r, "isSaveChildren").name(""), s.add(r, "isSaveMaterials").name(""), s.add(r, "useGlobalConfig").name("");
  const a = s.addFolder("");
  a.add(r.mesh, "castShadow").name("").onChange(() => n.children.forEach((o) => o.castShadow = r.mesh.castShadow)), a.add(r.mesh, "receiveShadow").name("").onChange(() => n.children.forEach((o) => o.receiveShadow = r.mesh.receiveShadow)), r4(n, s.addFolder("")), C1(i, t, n, s.addFolder("")), s.add({
    fn: () => {
      var o;
      s.parent.removeFolder(s), e.detach(), i.remove(n), (o = n.disposeRoot) == null || o.call(n);
    }
  }, "fn").name("");
}
function I1(i, e, t = 0) {
  const n = new Gn();
  return n.materialType = e, n.url = i, n.dlength = t, s4(n), fetch(i).then((s) => s.json()).then((s) => {
    const { features: r } = s;
    return r.forEach((a) => {
      a.geometry.type === "MultiPolygon" ? a.geometry.coordinates.forEach((o) => o.forEach((l) => rp(n, l))) : a.geometry.type === "Polygon" ? a.geometry.coordinates.forEach((o) => rp(n, o)) : a.geometry.type === "LineString" && a.geometry.coordinates.length > 1 && rp(n, a.geometry.coordinates);
    }), h1(n), n.RootMaterials = Kg(n), n.rotation.x = -Math.PI / 2, n.isBorderGroup = !0, n;
  });
}
function rp(i, e) {
  if (e.length < i.dlength) return;
  const t = e.map((o) => NU(o)), n = new Ed(t), s = new Vs(n, t.length - 1, 2, 4, !1), r = Ni(i.materialType, { color: 16777215 * Math.random(), transparent: !0, alphaHash: !0 }), a = new le(s, r);
  a.curve = n, c1(a), i.attach(a);
}
function s4(i) {
  return i.globalConfig = {
    useGlobalConfig: !1,
    isSaveMaterials: !0,
    isSaveChildren: !0,
    mesh: {
      castShadow: !1,
      receiveShadow: !1
    },
    material: {
      color: 16777215,
      wireframe: !1,
      transparent: !0,
      opacity: 1,
      metalness: 0,
      roughness: 0,
      emissive: 0,
      emissiveIntensity: 1,
      // 
      clearcoat: 0,
      clearcoatRoughness: 0,
      sheen: 0,
      sheenRoughness: 0,
      sheenColor: 0,
      transmission: 0,
      envMap: !1,
      envMapIntensity: 1,
      reflectivity: 0.98,
      mapUrl: "",
      textureAnimation: {
        isTextureAnimation: !1,
        offset: { x: 0, y: 0.01 },
        rotation: 0
      },
      map: {
        repeat: { x: 1, y: 1 },
        offset: { x: 0, y: 0 },
        center: { x: 0, y: 0 },
        rotation: 0
      }
    },
    geometry: {
      radialSegments: 4,
      radius: 2,
      closed: !1,
      tubularSegmentsMultiple: 1
    }
  }, i;
}
function r4(i, e) {
  const { globalConfig: t } = i, { geometry: n } = t;
  let s = null;
  function r() {
    s && clearTimeout(s), s = setTimeout(() => {
      i.children.forEach((a) => {
        a.geometry.dispose(), a.geometry = new Vs(a.curve, (a.curve.points.length - 1) * n.tubularSegmentsMultiple, n.radius, n.radialSegments, n.closed), a.geometry.center();
      }), s = null;
    }, 200);
  }
  e.add(n, "tubularSegmentsMultiple", 1).name("").onChange(r).step(1), e.add(n, "radius", 0.01).name("").onChange(r), e.add(n, "radialSegments", 2).name("").onChange(r).step(1), e.add(n, "closed").name("").onChange(r);
}
const Li = {
  url: "https://geo.datav.aliyun.com/areas_v3/bound/100000.json",
  materialType: "",
  borderGroupCallPanel: null,
  dlength: 0
};
function a4(i, e, t, n) {
  const s = n.addFolder("");
  n.add(Li, "url").name(""), n.add(Li, "materialType", eh).name(""), n.add(Li, "dlength", 0).name(""), n.add({
    fn: () => {
      I1(Li.url, Li.materialType, Li.dlength).then((r) => {
        i.add(r), e.attach(r), Dy(i, e, t, r, s.addFolder(r.name + r.id));
      });
    }
  }, "fn").name(""), Li.borderGroupCallPanel = (r) => Dy(i, e, t, r, s.addFolder(r.name + r.id));
}
function o4(i) {
  return i.map((e) => n4(e));
}
function l4(i, e, t) {
  t && t.forEach((n) => i4(i, e, n).then((s) => {
    var r;
    (r = Li.borderGroupCallPanel) == null || r.call(Li, s);
  }));
}
function c4(i) {
  const { material: e, geometry: t } = i, { parameters: n } = t, { options: s } = n;
  return {
    ...Vr(i),
    fontLink: i.fontLink,
    text: i.text,
    geometry: {
      geometryType: "TextGeometry",
      parameters: {
        size: s.size,
        depth: s.depth,
        height: s.height,
        curveSegments: s.curveSegments,
        bevelEnabled: s.bevelEnabled,
        bevelThickness: s.bevelThickness,
        bevelSize: s.bevelSize,
        bevelSegments: s.bevelSegments
      }
    },
    material: c0(e)
  };
}
async function h4(i, e, t) {
  if (!t) return;
  const { geometry: n, material: s } = t, { parameters: r } = n, a = await u1(t.fontLink, t.text, r), o = Ni(s.materialType), l = new le(a, o);
  return l.fontLink = t.fontLink, l.text = t.text, l.isTextMesh = !0, i.add(l), h0(i, e, l.material, s), Wr(l, t), l;
}
function Oy(i, e, t, n, s) {
  $s(n, s.addFolder("")), u4(n, s.addFolder("")), u0(i, t, n.material, s.addFolder("")), s.add({
    fn: () => {
      e.detach(), i.remove(n);
      const r = t.findIndex((a) => a.uuid == n.uuid);
      r > -1 && t.splice(r, 1), s.parent.removeFolder(s);
    }
  }, "fn").name("");
}
function u4(i, e) {
  const { geometry: t } = i, { parameters: n } = t, { options: s } = n;
  let r = null;
  function a() {
    r && clearTimeout(r), r = setTimeout(() => {
      i.geometry.dispose(), i.geometry = new Db(i.text, s), r = null;
    }, 200);
  }
  e.add(i, "text").onChange(a).name(""), e.add(s, "size").onChange(a).name(""), e.add(s, "depth").onChange(a).name(""), e.add(s, "height").onChange(a).name(""), e.add(s, "curveSegments").onChange(a).name("").step(1).min(1), e.add(s, "bevelEnabled").onChange(a).name(""), e.add(s, "bevelThickness").onChange(a).name(""), e.add(s, "bevelSize").onChange(a).name(""), e.add(s, "bevelSegments").onChange(a).name("").step(1).min(0);
}
const kn = {
  fontLink: "https://z2586300277.github.io/three-editor/dist/files/font/cn1.json",
  text: "",
  materialType: "",
  textMeshCallPanel: null
};
function d4(i) {
  return i.map((e) => c4(e));
}
function f4(i, e, t) {
  t && t.forEach((n) => h4(i, e, n).then((s) => {
    var r;
    (r = kn.textMeshCallPanel) == null || r.call(kn, s);
  }));
}
function p4(i, e, t, n) {
  const s = n.addFolder("");
  n.add(kn, "fontLink").name(""), n.add(kn, "materialType", eh).name(""), n.add(kn, "text").name(""), n.add({
    fn: () => {
      kn.text && (u1(kn.fontLink, kn.text).then((r) => {
        const a = Ni(kn.materialType), o = new le(r, a);
        o.fontLink = kn.fontLink, o.text = kn.text, o.isTextMesh = !0, i.add(o), e.attach(o), Oy(i, e, t, o, s.addFolder(o.text + o.id));
      }), s.open());
    }
  }, "fn").name(""), kn.textMeshCallPanel = (r) => Oy(i, e, t, r, s.addFolder(r.text + r.id));
}
function m4(i, e) {
  const t = e.addFolder("");
  i.viewAngleList ? i.viewAngleList.forEach((n, s) => Ny(i, n, t.addFolder((n.name || "") + "[" + Date.now() + s + "]"))) : i.viewAngleList = [], e.add({
    fn: () => {
      const n = g4(i);
      i.viewAngleList.push(n), Ny(i, n, t.addFolder(n.name || "[" + Date.now() + "]")), t.open();
    }
  }, "fn").name("");
}
function g4(i) {
  return {
    name: "",
    target: { x: i.target.x, y: i.target.y, z: i.target.z },
    position: { x: i.object.position.x, y: i.object.position.y, z: i.object.position.z }
  };
}
function Ny(i, e, t) {
  t.add(e, "name").name(""), t.add({ fn: () => v4(i, e) }, "fn").name(""), t.add({
    fn: () => {
      Cc(i.target, e.target), Cc(i.object.position, e.position);
    }
  }, "fn").name(""), t.add({
    fn: () => {
      const n = i.viewAngleList.indexOf(e);
      n !== -1 && i.viewAngleList.splice(n, 1), t.parent.removeFolder(t);
    }
  }, "fn").name("");
}
function v4(i, e) {
  i.target.set(e.target.x, e.target.y, e.target.z), i.object.position.set(e.position.x, e.position.y, e.position.z), i.update();
}
function _4(i, e, t) {
  const n = y4(t.addFolder(""));
  let s = null;
  t.add({
    fn: function() {
      const { currentInfo: r } = i;
      if (!r) return;
      let a;
      i.mode == "" ? a = r.currentModel : i.mode == "" ? a = r.currentRootModel : i.mode == "" && (a = i.isTransformChildren ? r.currentModel : r.currentRootModel), s && t.removeFolder(s), s = t.addFolder(a.name + a.id + ""), e.attach(a), x4(a, n, s);
    }
  }, "fn").name("");
}
function y4(i) {
  const e = {
    mode: "to",
    query: {
      duration: 2,
      ease: "none",
      repeat: 0,
      yoyo: !1
    }
  };
  return i.add(e, "mode", ["to", "from", "fromTo"]).name(""), i.add(e.query, "duration", 0, 10).name(""), i.add(e.query, "ease", ["none", "power1", "power2", "power3", "power4", "back", "elastic", "bounce"]).name(""), i.add(e.query, "repeat", 0).name(""), i.add(e.query, "yoyo").name(""), e;
}
function x4(i, e, t) {
  const n = t.addFolder("");
  i._transformInfo = No(i), i.transformAnimationList ? i.transformAnimationList.forEach((s, r) => Uy(i, s, n.addFolder("[" + Date.now() + r + "]"))) : i.transformAnimationList = [], t.add({ fn: () => ju(i, i._transformInfo) }, "fn").name(""), t.add({ fn: () => i._transformInfo = No(i) }, "fn").name(""), t.add({ fn: () => Qg(i, i._transformInfo, No(i), e) }, "fn").name(""), t.add({
    fn: () => {
      const s = VU(i, e);
      i.transformAnimationList.push(s), n.open(), Uy(i, s, n.addFolder("[" + Date.now() + "]"));
    }
  }, "fn").name("");
}
function Uy(i, e, t) {
  t.add(e, "name").name("");
  const n = {
    play: () => {
      const { gsapParams: s, _transformInfo: r, transformInfo_: a } = e;
      Qg(i, r, a, s);
    },
    del: () => {
      i.transformAnimationList.splice(i.transformAnimationList.indexOf(e), 1), t.parent.removeFolder(t);
    }
  };
  t.add(n, "play").name(""), t.add(n, "del").name("");
}
function M4(i, e, t, n) {
  n.add({
    fn: function() {
      const { currentInfo: s } = i;
      if (!s) return;
      let r;
      if (i.mode == "" ? r = s.currentModel : i.mode == "" ? r = s.currentRootModel : i.mode == "" && (r = i.isTransformChildren ? s.currentModel : s.currentRootModel), !r) return;
      function a(o, l) {
        const c = o.position.y, h = o.position.y + l;
        return function u(d, f) {
          f == "down" ? o.frameAnimationRender = () => {
            o.position.y -= d, o.position.y < c && u(d, "up");
          } : f == "up" && (o.frameAnimationRender = () => {
            o.position.y += d, o.position.y > h && u(d, "down");
          });
        };
      }
      r.frameAnimationRender = () => a(r, 1)(0.01, "down"), t.push(r);
    }
  }, "fn").name("");
}
function b4(i, e, t, n, s) {
  m4(e, s.addFolder("")), _4(i, t, s.addFolder("")), M4(i, t, n, s.addFolder(""));
}
const ap = {
  type: ""
};
function S4(i, e, t, n, s, r) {
  const a = r.addFolder("");
  r.add(ap, "type", Sm.map((o) => o.name)).name(""), r.add({
    fn: () => {
      const o = Sm.find((c) => ap.type === c.name), l = o.createFunc(null, { DOM: n, renderer: e });
      l.designType = ap.type, i.add(l), o.setPanel(l, a.addFolder(l.id + (l.name || "")));
    }
  }, "fn").name("");
}
function w4(i, e, t, n, s, r, a, o, l, c, h, u, d = () => {
}, f) {
  function m() {
    i.tempStorage = { lightList: [], axes: null, gridHelper: null, modelList: [], innerMeshList: [], drawMeshList: [], geoGroupList: [], particleList: [], borderGroupList: [], textMeshList: [] }, i.children.forEach((v) => {
      v instanceof Ss ? i.tempStorage.lightList.push(v) : v instanceof wg ? i.tempStorage.axes = v : v instanceof Sg ? i.tempStorage.gridHelper = v : v.rootInfo ? i.tempStorage.modelList.push(v) : v.isInnerMesh ? i.tempStorage.innerMeshList.push(v) : v.isDrawMesh ? i.tempStorage.drawMeshList.push(v) : v.isGeoGroup ? i.tempStorage.geoGroupList.push(v) : v.isParticleMesh ? i.tempStorage.particleList.push(v) : v.isBorderGroup ? i.tempStorage.borderGroupList.push(v) : v.isTextMesh && i.tempStorage.textMeshList.push(v);
    }), d({
      ...ik(i, e, t, n, r),
      handler: Uk(uo),
      innerMeshList: Mz(i.tempStorage.innerMeshList),
      textMeshList: d4(i.tempStorage.textMeshList),
      drawMeshList: Lz(i.tempStorage.drawMeshList),
      geoGroupList: qz(i.tempStorage.geoGroupList),
      borderGroupList: o4(i.tempStorage.borderGroupList),
      particleList: e4(i.tempStorage.particleList),
      core: T4(bn, fi, Li, kn)
    }, Jk(i.tempStorage.modelList)), s.detach(), r.effectPass.outlinePass.selectedObjects = [];
  }
  Nk(i, c, uo, s), Qk(i, n, s, r, a), cF(o, h), E4({ chartsMapControls: bn, particleControls: fi, borderGroupControls: Li, textMeshControls: kn }, u.core), sk(i, e, t, n, r, u), Fk(i, s, c, uo, u.handler), Iz(yn, i, l, u.drawMeshList), bz(i, l, u.innerMeshList), f4(i, l, u.textMeshList), Yz(i, l, u.geoGroupList), Jz(i, h, l, u.particleList), l4(i, l, u.borderGroupList);
  const g = DF(f.proxy, f.autoPlace);
  rk(i, e, t, n, r, s, g.addFolder("")), Bk(i, s, c, uo, g.addFolder(""));
  const p = g.addFolder("3D");
  return p.open(), ez(tc, p.addFolder("")), Dz(i, s, l, p.addFolder("")), Sz(i, s, l, p.addFolder("")), Xz(i, s, l, p.addFolder("")), t4(i, s, h, l, p.addFolder("")), a4(i, s, l, p.addFolder("")), p4(i, s, l, p.addFolder("")), S4(i, t, s, h, l, p.addFolder("")), b4(uo, n, s, l, g.addFolder("")), XF(i, t, o, h, l, g), { handler: uo, GUI: g, modelControls: tc, chartsMapControls: bn, drawControls: yn, innerMeshControls: ss, particleControls: fi, saveSceneEditor: m };
}
function T4(i, e, t, n) {
  return {
    chartsMapControls: {
      url: i.url,
      materialType: i.materialType
    },
    particleControls: {
      mapUrl: e.mapUrl,
      shaderCodeName: e.shaderCodeName
    },
    borderGroupControls: {
      url: t.url,
      materialType: t.materialType,
      dlength: t.dlength
    },
    textMeshControls: {
      fontLink: n.fontLink,
      materialType: n.materialType
    }
  };
}
function E4(i, e) {
  e && Object.keys(e).forEach((t) => {
    Object.keys(e[t]).forEach((n) => {
      i[t][n] = e[t][n];
    });
  });
}
function A4(i, e, t, n) {
  const s = gU(), r = vU(s, i), a = _U(e, i), o = yU(r, a), l = EU(s, r, a, o), { Composer: c } = CU(s, r, a, i), { Css3Render: h, CSS3DObject: u } = PU(i), { CssRender: d, CSS2DObject: f } = RU(i), m = [], g = [], p = [], v = wU(i), y = w4(s, r, a, o, l, c, m, g, p, v, i, { ...t }, (E, b) => n(E, b), e.userPermissions), _ = TU(e.fps);
  let x = null;
  w();
  function M() {
    r.aspect = i.clientWidth / i.clientHeight, r.updateProjectionMatrix(), a.setSize(i.clientWidth, i.clientHeight), c.resize(), g.forEach((E) => E.uniforms.iResolution && (E.uniforms.iResolution.value = new k(i.clientWidth, i.clientHeight))), h.resize(), d.resize();
  }
  function S() {
    var E, b;
    for (cancelAnimationFrame(x), WU(s), a.dispose(), (b = (E = y.GUI) == null ? void 0 : E.destroy) == null || b.call(E); i.children.length; ) i.removeChild(i.firstChild);
  }
  function w() {
    _(() => {
      v.update(), o.update(), m.forEach((E) => E.mixerRender()), g.forEach((E) => E.ShaderAnimateRender()), p.forEach((E) => {
        var b;
        return (b = E.frameAnimationRender) == null ? void 0 : b.call(E);
      }), c.EffectComposerRender(), h.render(s, r), d.render(s, r);
    }), x = requestAnimationFrame(w);
  }
  return { scene: s, camera: r, renderer: a, controls: o, transformControls: l, MixerList: m, ShaderList: g, CommonFrameList: p, Stats: v, Composer: c, CSS3DObject: u, CSS2DObject: f, renderSceneResize: M, destroySceneRender: S, ...y };
}
const C4 = (i, e, t) => {
  var y, _;
  const { scene: n, camera: s, handler: r, drawControls: a, transformControls: o, Composer: l, GUI: c } = e, { outlinePass: h } = l.effectPass;
  o.detach();
  const u = n1(i), f = AU(u, s, n).find((x) => x.object.visible == !0 && oy(x.object).visible);
  if (!f) return;
  const { object: m, point: g } = f, p = oy(m);
  switch (r.mode) {
    case "":
      h.selectedObjects = [], r.isTransformChildren ? o.attach(m) : o.attach(p);
      break;
    case "":
      h.selectedObjects = [m], (y = c == null ? void 0 : c.createSelectMeshPanel) == null || y.call(c, m);
      break;
    case "":
      h.selectedObjects = [p], (_ = c == null ? void 0 : c.createSelectRootGroupPanel) == null || _.call(c, p);
      break;
    case "":
      a.sceneEventCall(g, m);
      break;
  }
  const v = { currentModel: m, currentRootModel: p, point: g, mode: r.mode };
  e.currentInfo = v, r.currentInfo = v, t(v);
};
function R4(i) {
  const e = new Fd();
  return {
    raycaster: e,
    getIntersects: (t, n) => (e.setFromCamera(n1(t), i.camera), e.intersectObjects(n))
  };
}
function I4(i = {}) {
  const e = hl(""), t = Ni(i.materialType || ""), n = th(e, t);
  return e0(n, ""), n;
}
function D4(i = {}) {
  const e = hl(""), t = Ni(i.materialType || "");
  i.url && (t.map = new Ys().load(i.url));
  const n = th(e, t);
  return e0(n, ""), n.uniforms.circleWidth.value = 0.4, n.uniforms.isDisCard.value = !0, n;
}
function O4(i = {}) {
  const e = hl(i.geometryType || ""), t = Ni(i.materialType || ""), n = th(e, t);
  return e0(n, ""), n;
}
const ed = class ed {
  constructor(e) {
    // THREE 
    $i(this, "THREE", oR);
    // GSAP 
    $i(this, "gsap", Hd);
    // 
    $i(this, "progressList", []);
    // 
    $i(this, "pointSyncTransform", GU);
    // 
    $i(this, "getDistanceScalePoint", LU);
    // gsap 
    $i(this, "setGsapMeshAction", Qg);
    // 
    $i(this, "getBestViewTarget", r1);
    // 
    $i(this, "meshGroupCloneMaterial", zU);
    var t;
    this.viewer = A4(
      // HTML DOM
      e.threeBoxRef,
      // 
      e.rendererParams,
      // 
      e.sceneParams,
      // 
      (n, s) => e.saveEditorCallBack(n, s)
    ), (t = e.meshListParams) == null || t.map((n) => this.setModelFromInfo(n.rootInfo, n.group)), e.skyParams && (ly(this.viewer.scene, e.skyParams), cy(this.viewer.scene, e.skyParams));
  }
  // 2D Dom 
  setCss2dDOM(e, t) {
    e.style.pointerEvents = "auto";
    const { CSS2DObject: n, scene: s } = this.viewer, r = new n(e);
    return r.position.copy(t), s.add(r), r.destroy = () => s.remove(r), r;
  }
  // 3D Dom 
  setCss3dDOM(e, t) {
    const { CSS3DObject: n, scene: s } = this.viewer, r = new n(e);
    return r.position.copy(t), s.add(r), r.destroy = () => s.remove(r), r;
  }
  // 
  setModelFromInfo(e, t = null) {
    const n = this.viewer.modelControls.sceneInsertModel(ed.dracoPath, e, t);
    return this.progressList.push({ loaderService: n, rootInfo: e, params: t }), { loaderService: n, rootInfo: e, params: t };
  }
  // 
  setSky(e) {
    ly(this.viewer.scene, e);
  }
  // 
  setGlobalEnvBackground(e) {
    cy(this.viewer.scene, e);
  }
  // 
  getSceneEvent(e, t = () => {
  }) {
    C4(e, this.viewer, (n) => t(n));
  }
  // 
  getRawSceneEvent() {
    return R4(this.viewer);
  }
  // GUI DOM 
  setGUIDomPosition(e) {
    if (!(!e || !this.viewer.GUI.domElement))
      return e.appendChild(this.viewer.GUI.domElement), { GUIDom: this.viewer.GUI.domElement, remove: () => e.removeChild(this.viewer.GUI.domElement) };
  }
  // 
  setGsapAnimation(e, t, n) {
    return Cc(e, t, n);
  }
  // 
  setOutlinePass(e = []) {
    return this.viewer.Composer.effectPass.outlinePass.selectedObjects = e;
  }
  // 
  saveSceneEditor() {
    return this.viewer.saveSceneEditor();
  }
  // GUI
  refreshGUI() {
    var e, t;
    return (t = (e = this.viewer.GUI).updateDisplay) == null ? void 0 : t.call(e);
  }
  // 
  getSceneEditorImage(e = []) {
    return this.viewer.renderer.render(this.viewer.scene, this.viewer.camera), this.viewer.Composer.render(), this.viewer.renderer.domElement.toDataURL(...e);
  }
  // 
  setSceneControlMode(e) {
    const { handler: t } = this.viewer;
    t.mode = e;
  }
  // 
  setTransformControlsProperty(e, t) {
    const { transformControls: n } = this.viewer;
    n.hasOwnProperty(e) && (n[e] = t);
  }
  // 
  setOperateOption(e, t) {
    this.viewer.handler.setHandlerOption(e, t);
  }
  // 
  setModelAnimationPlay(e) {
    if (e != null && e.animationPlayParams)
      return this.viewer.modelControls.animationPlay(this.viewer.MixerList, e, e.animationPlayParams);
  }
  // 
  removeModelAnimation(e) {
    e && this.viewer.MixerList.splice(this.viewer.MixerList.findIndex((t) => t == e), 1);
  }
  // 
  setBoxGeometry(...e) {
    return xU(...e);
  }
  // 
  changeMeshMaterial(e, ...t) {
    return e.isMesh ? FU(e, ...t) : BU(e, ...t);
  }
  // 
  changeMeshTransform(e, ...t) {
    return kU(e, ...t);
  }
  // 
  getSceneCurveList() {
    return this.viewer.scene.children.filter((e) => e.isCurveMesh).map((e) => {
      var t, n;
      return {
        path: e.curvePath || ((n = (t = e.geometry) == null ? void 0 : t.parameters) == null ? void 0 : n.path),
        mesh: e
      };
    });
  }
  // 
  setCurveAnimation(e, t = 1) {
    if (e)
      return HU(e, t, this.viewer.CommonFrameList);
  }
  // 
  setSceneFromClassify(e) {
    XU(this.viewer.scene, e);
  }
  // 
  getObjectViews(e, t = this.viewer.camera.fov) {
    return qU(e, t);
  }
};
//  draco 
$i(ed, "dracoPath", "/draco/");
let Fy = ed;
export {
  Fy as ThreeEditor,
  O4 as createOneHeatMap,
  D4 as createScanPlane,
  I4 as createSkySphereShader,
  E1 as getLight
};
